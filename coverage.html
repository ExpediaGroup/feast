
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>embedded: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/feast-dev/feast/go/embedded/online_features.go (0.0%)</option>
				
				<option value="file1">github.com/feast-dev/feast/go/internal/feast/featurestore.go (0.0%)</option>
				
				<option value="file2">github.com/feast-dev/feast/go/internal/feast/model/basefeatureview.go (90.9%)</option>
				
				<option value="file3">github.com/feast-dev/feast/go/internal/feast/model/entity.go (100.0%)</option>
				
				<option value="file4">github.com/feast-dev/feast/go/internal/feast/model/featureservice.go (100.0%)</option>
				
				<option value="file5">github.com/feast-dev/feast/go/internal/feast/model/featureview.go (56.0%)</option>
				
				<option value="file6">github.com/feast-dev/feast/go/internal/feast/model/featureviewprojection.go (100.0%)</option>
				
				<option value="file7">github.com/feast-dev/feast/go/internal/feast/model/field.go (100.0%)</option>
				
				<option value="file8">github.com/feast-dev/feast/go/internal/feast/model/ondemandfeatureview.go (73.1%)</option>
				
				<option value="file9">github.com/feast-dev/feast/go/internal/feast/onlineserving/serving.go (49.1%)</option>
				
				<option value="file10">github.com/feast-dev/feast/go/internal/feast/onlinestore/cassandraonlinestore.go (36.3%)</option>
				
				<option value="file11">github.com/feast-dev/feast/go/internal/feast/onlinestore/onlinestore.go (0.0%)</option>
				
				<option value="file12">github.com/feast-dev/feast/go/internal/feast/onlinestore/redisonlinestore.go (45.7%)</option>
				
				<option value="file13">github.com/feast-dev/feast/go/internal/feast/onlinestore/sqliteonlinestore.go (77.9%)</option>
				
				<option value="file14">github.com/feast-dev/feast/go/internal/feast/registry/http.go (66.7%)</option>
				
				<option value="file15">github.com/feast-dev/feast/go/internal/feast/registry/local.go (0.0%)</option>
				
				<option value="file16">github.com/feast-dev/feast/go/internal/feast/registry/registry.go (0.0%)</option>
				
				<option value="file17">github.com/feast-dev/feast/go/internal/feast/registry/repoconfig.go (88.5%)</option>
				
				<option value="file18">github.com/feast-dev/feast/go/internal/feast/server/grpc_server.go (75.0%)</option>
				
				<option value="file19">github.com/feast-dev/feast/go/internal/feast/server/http_server.go (18.1%)</option>
				
				<option value="file20">github.com/feast-dev/feast/go/internal/feast/server/logging/featureserviceschema.go (78.0%)</option>
				
				<option value="file21">github.com/feast-dev/feast/go/internal/feast/server/logging/filelogsink.go (75.0%)</option>
				
				<option value="file22">github.com/feast-dev/feast/go/internal/feast/server/logging/logger.go (71.0%)</option>
				
				<option value="file23">github.com/feast-dev/feast/go/internal/feast/server/logging/memorybuffer.go (82.4%)</option>
				
				<option value="file24">github.com/feast-dev/feast/go/internal/feast/server/logging/offlinestoresink.go (0.0%)</option>
				
				<option value="file25">github.com/feast-dev/feast/go/internal/feast/server/logging/service.go (0.0%)</option>
				
				<option value="file26">github.com/feast-dev/feast/go/internal/feast/server/server_commons.go (100.0%)</option>
				
				<option value="file27">github.com/feast-dev/feast/go/internal/feast/transformation/transformation.go (30.0%)</option>
				
				<option value="file28">github.com/feast-dev/feast/go/internal/feast/transformation/transformation_service.go (6.7%)</option>
				
				<option value="file29">github.com/feast-dev/feast/go/internal/feast/utils/key_utils.go (81.8%)</option>
				
				<option value="file30">github.com/feast-dev/feast/go/internal/test/go_integration_test_utils.go (82.5%)</option>
				
				<option value="file31">github.com/feast-dev/feast/go/main.go (3.4%)</option>
				
				<option value="file32">github.com/feast-dev/feast/go/protos/feast/core/Aggregation.pb.go (28.9%)</option>
				
				<option value="file33">github.com/feast-dev/feast/go/protos/feast/core/DataFormat.pb.go (8.4%)</option>
				
				<option value="file34">github.com/feast-dev/feast/go/protos/feast/core/DataSource.pb.go (13.3%)</option>
				
				<option value="file35">github.com/feast-dev/feast/go/protos/feast/core/DatastoreTable.pb.go (27.1%)</option>
				
				<option value="file36">github.com/feast-dev/feast/go/protos/feast/core/DynamoDBTable.pb.go (33.3%)</option>
				
				<option value="file37">github.com/feast-dev/feast/go/protos/feast/core/Entity.pb.go (24.8%)</option>
				
				<option value="file38">github.com/feast-dev/feast/go/protos/feast/core/Feature.pb.go (28.9%)</option>
				
				<option value="file39">github.com/feast-dev/feast/go/protos/feast/core/FeatureService.pb.go (18.3%)</option>
				
				<option value="file40">github.com/feast-dev/feast/go/protos/feast/core/FeatureTable.pb.go (12.8%)</option>
				
				<option value="file41">github.com/feast-dev/feast/go/protos/feast/core/FeatureView.pb.go (21.2%)</option>
				
				<option value="file42">github.com/feast-dev/feast/go/protos/feast/core/FeatureViewProjection.pb.go (30.4%)</option>
				
				<option value="file43">github.com/feast-dev/feast/go/protos/feast/core/InfraObject.pb.go (22.8%)</option>
				
				<option value="file44">github.com/feast-dev/feast/go/protos/feast/core/OnDemandFeatureView.pb.go (21.5%)</option>
				
				<option value="file45">github.com/feast-dev/feast/go/protos/feast/core/Permission.pb.go (11.1%)</option>
				
				<option value="file46">github.com/feast-dev/feast/go/protos/feast/core/Policy.pb.go (20.3%)</option>
				
				<option value="file47">github.com/feast-dev/feast/go/protos/feast/core/Project.pb.go (19.6%)</option>
				
				<option value="file48">github.com/feast-dev/feast/go/protos/feast/core/Registry.pb.go (28.6%)</option>
				
				<option value="file49">github.com/feast-dev/feast/go/protos/feast/core/SavedDataset.pb.go (9.1%)</option>
				
				<option value="file50">github.com/feast-dev/feast/go/protos/feast/core/SortedFeatureView.pb.go (10.1%)</option>
				
				<option value="file51">github.com/feast-dev/feast/go/protos/feast/core/SqliteTable.pb.go (33.3%)</option>
				
				<option value="file52">github.com/feast-dev/feast/go/protos/feast/core/Store.pb.go (5.6%)</option>
				
				<option value="file53">github.com/feast-dev/feast/go/protos/feast/core/StreamFeatureView.pb.go (16.4%)</option>
				
				<option value="file54">github.com/feast-dev/feast/go/protos/feast/core/Transformation.pb.go (14.3%)</option>
				
				<option value="file55">github.com/feast-dev/feast/go/protos/feast/core/ValidationProfile.pb.go (10.8%)</option>
				
				<option value="file56">github.com/feast-dev/feast/go/protos/feast/serving/Connector.pb.go (8.5%)</option>
				
				<option value="file57">github.com/feast-dev/feast/go/protos/feast/serving/Connector_grpc.pb.go (0.0%)</option>
				
				<option value="file58">github.com/feast-dev/feast/go/protos/feast/serving/GrpcServer.pb.go (8.3%)</option>
				
				<option value="file59">github.com/feast-dev/feast/go/protos/feast/serving/GrpcServer_grpc.pb.go (0.0%)</option>
				
				<option value="file60">github.com/feast-dev/feast/go/protos/feast/serving/ServingService.pb.go (25.7%)</option>
				
				<option value="file61">github.com/feast-dev/feast/go/protos/feast/serving/ServingService_grpc.pb.go (56.2%)</option>
				
				<option value="file62">github.com/feast-dev/feast/go/protos/feast/serving/TransformationService.pb.go (6.7%)</option>
				
				<option value="file63">github.com/feast-dev/feast/go/protos/feast/serving/TransformationService_grpc.pb.go (3.1%)</option>
				
				<option value="file64">github.com/feast-dev/feast/go/protos/feast/storage/Redis.pb.go (0.0%)</option>
				
				<option value="file65">github.com/feast-dev/feast/go/protos/feast/types/EntityKey.pb.go (40.0%)</option>
				
				<option value="file66">github.com/feast-dev/feast/go/protos/feast/types/Field.pb.go (21.7%)</option>
				
				<option value="file67">github.com/feast-dev/feast/go/protos/feast/types/Value.pb.go (43.8%)</option>
				
				<option value="file68">github.com/feast-dev/feast/go/types/typeconversion.go (86.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package embedded

import (
        "context"
        "fmt"
        "log"
        "net"
        "os"
        "os/signal"
        "strings"
        "syscall"
        "time"

        "gopkg.in/DataDog/dd-trace-go.v1/ddtrace/tracer"

        "github.com/apache/arrow/go/v17/arrow"
        "github.com/apache/arrow/go/v17/arrow/array"
        "github.com/apache/arrow/go/v17/arrow/cdata"
        "github.com/apache/arrow/go/v17/arrow/memory"
        "google.golang.org/grpc"

        "github.com/feast-dev/feast/go/internal/feast"
        "github.com/feast-dev/feast/go/internal/feast/model"
        "github.com/feast-dev/feast/go/internal/feast/onlineserving"
        "github.com/feast-dev/feast/go/internal/feast/registry"
        "github.com/feast-dev/feast/go/internal/feast/server"
        "github.com/feast-dev/feast/go/internal/feast/server/logging"
        "github.com/feast-dev/feast/go/internal/feast/transformation"
        "github.com/feast-dev/feast/go/protos/feast/serving"
        prototypes "github.com/feast-dev/feast/go/protos/feast/types"
        "github.com/feast-dev/feast/go/types"
        jsonlog "github.com/rs/zerolog/log"
        "google.golang.org/grpc/health"
        "google.golang.org/grpc/health/grpc_health_v1"
        grpctrace "gopkg.in/DataDog/dd-trace-go.v1/contrib/google.golang.org/grpc"
)

type OnlineFeatureService struct {
        fs         *feast.FeatureStore
        grpcStopCh chan os.Signal
        httpStopCh chan os.Signal

        statusColumnBuildersToRelease []*array.Int32Builder
        tsColumnBuildersToRelease     []*array.Int64Builder
        arraysToRelease               []arrow.Array
        resultsToRelease              []arrow.Record

        err error
}

type OnlineFeatureServiceConfig struct {
        RepoPath   string
        RepoConfig string
}

type DataTable struct {
        DataPtr   uintptr
        SchemaPtr uintptr
}

// LoggingOptions is a public (embedded) copy of logging.LoggingOptions struct.
// See logging.LoggingOptions for properties description
type LoggingOptions struct {
        ChannelCapacity int
        EmitTimeout     time.Duration
        WriteInterval   time.Duration
        FlushInterval   time.Duration
}

func NewOnlineFeatureService(conf *OnlineFeatureServiceConfig, transformationCallback transformation.TransformationCallback) *OnlineFeatureService <span class="cov0" title="0">{
        repoConfig, err := registry.NewRepoConfigFromJSON(conf.RepoPath, conf.RepoConfig)
        if err != nil </span><span class="cov0" title="0">{
                jsonlog.Error().Stack().Err(err).Msg("Failed to convert to RepoConfig")
                return &amp;OnlineFeatureService{
                        err: err,
                }
        }</span>

        <span class="cov0" title="0">fs, err := feast.NewFeatureStore(repoConfig, transformationCallback)
        if err != nil </span><span class="cov0" title="0">{
                jsonlog.Error().Stack().Err(err).Msg("Failed to create NewFeatureStore")
                return &amp;OnlineFeatureService{
                        err: err,
                }
        }</span>

        // Notify these channels when receiving interrupt or termination signals from OS
        <span class="cov0" title="0">httpStopCh := make(chan os.Signal, 1)
        grpcStopCh := make(chan os.Signal, 1)
        signal.Notify(httpStopCh, syscall.SIGINT, syscall.SIGTERM)
        signal.Notify(grpcStopCh, syscall.SIGINT, syscall.SIGTERM)

        return &amp;OnlineFeatureService{fs: fs, httpStopCh: httpStopCh, grpcStopCh: grpcStopCh}</span>
}

func (s *OnlineFeatureService) GetEntityTypesMap(featureRefs []string) (map[string]int32, error) <span class="cov0" title="0">{
        viewNames := make(map[string]interface{})
        for _, featureRef := range featureRefs </span><span class="cov0" title="0">{
                viewName, _, err := onlineserving.ParseFeatureReference(featureRef)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">viewNames[viewName] = nil</span>
        }

        <span class="cov0" title="0">joinKeyTypes := make(map[string]int32)

        for viewName := range viewNames </span><span class="cov0" title="0">{
                view, err := s.fs.GetFeatureView(viewName, true)
                if err != nil </span><span class="cov0" title="0">{
                        // skip on demand feature views
                        continue</span>
                }
                <span class="cov0" title="0">for _, entityColumn := range view.EntityColumns </span><span class="cov0" title="0">{
                        joinKeyTypes[entityColumn.Name] = int32(entityColumn.Dtype.Number())
                }</span>
        }

        <span class="cov0" title="0">return joinKeyTypes, nil</span>
}

func (s *OnlineFeatureService) GetEntityTypesMapByFeatureService(featureServiceName string) (map[string]int32, error) <span class="cov0" title="0">{
        featureService, err := s.fs.GetFeatureService(featureServiceName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">joinKeyTypes := make(map[string]int32)

        for _, projection := range featureService.Projections </span><span class="cov0" title="0">{
                view, err := s.fs.GetFeatureView(projection.Name, true)
                if err != nil </span><span class="cov0" title="0">{
                        // skip on demand feature views
                        continue</span>
                }
                <span class="cov0" title="0">for _, entityColumn := range view.EntityColumns </span><span class="cov0" title="0">{
                        joinKeyTypes[entityColumn.Name] = int32(entityColumn.Dtype.Number())
                }</span>
        }

        <span class="cov0" title="0">return joinKeyTypes, nil</span>
}

func (s *OnlineFeatureService) CheckForInstantiationError() error <span class="cov0" title="0">{
        return s.err
}</span>

func (s *OnlineFeatureService) GetOnlineFeatures(
        featureRefs []string,
        featureServiceName string,
        entities DataTable,
        requestData DataTable,
        fullFeatureNames bool,
        output DataTable) error <span class="cov0" title="0">{

        entitiesRecord, err := readArrowRecord(entities)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer entitiesRecord.Release()

        numRows := entitiesRecord.Column(0).Len()

        entitiesProto, err := recordToProto(entitiesRecord)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">requestDataRecords, err := readArrowRecord(requestData)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer requestDataRecords.Release()

        requestDataProto, err := recordToProto(requestDataRecords)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var featureService *model.FeatureService
        if featureServiceName != "" </span><span class="cov0" title="0">{
                featureService, err = s.fs.GetFeatureService(featureServiceName)
        }</span>

        <span class="cov0" title="0">resp, err := s.fs.GetOnlineFeatures(
                context.Background(),
                featureRefs,
                featureService,
                entitiesProto,
                requestDataProto,
                fullFeatureNames)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Release all objects that are no longer required.
        <span class="cov0" title="0">for _, statusColumnBuilderToRelease := range s.statusColumnBuildersToRelease </span><span class="cov0" title="0">{
                statusColumnBuilderToRelease.Release()
        }</span>
        <span class="cov0" title="0">for _, tsColumnBuilderToRelease := range s.tsColumnBuildersToRelease </span><span class="cov0" title="0">{
                tsColumnBuilderToRelease.Release()
        }</span>
        <span class="cov0" title="0">for _, arrayToRelease := range s.arraysToRelease </span><span class="cov0" title="0">{
                arrayToRelease.Release()
        }</span>
        <span class="cov0" title="0">for _, resultsToRelease := range s.resultsToRelease </span><span class="cov0" title="0">{
                resultsToRelease.Release()
        }</span>
        <span class="cov0" title="0">s.statusColumnBuildersToRelease = nil
        s.tsColumnBuildersToRelease = nil
        s.arraysToRelease = nil
        s.resultsToRelease = nil

        outputFields := make([]arrow.Field, 0)
        outputColumns := make([]arrow.Array, 0)
        pool := memory.NewGoAllocator()
        for _, featureVector := range resp </span><span class="cov0" title="0">{
                outputFields = append(outputFields,
                        arrow.Field{
                                Name: featureVector.Name,
                                Type: featureVector.Values.DataType()})
                outputFields = append(outputFields,
                        arrow.Field{
                                Name: fmt.Sprintf("%s__status", featureVector.Name),
                                Type: arrow.PrimitiveTypes.Int32})
                outputFields = append(outputFields,
                        arrow.Field{
                                Name: fmt.Sprintf("%s__timestamp", featureVector.Name),
                                Type: arrow.PrimitiveTypes.Int64})

                outputColumns = append(outputColumns, featureVector.Values)

                statusColumnBuilder := array.NewInt32Builder(pool)
                for _, status := range featureVector.Statuses </span><span class="cov0" title="0">{
                        statusColumnBuilder.Append(int32(status))
                }</span>
                <span class="cov0" title="0">statusColumn := statusColumnBuilder.NewArray()
                outputColumns = append(outputColumns, statusColumn)

                tsColumnBuilder := array.NewInt64Builder(pool)
                for _, ts := range featureVector.Timestamps </span><span class="cov0" title="0">{
                        tsColumnBuilder.Append(ts.GetSeconds())
                }</span>
                <span class="cov0" title="0">tsColumn := tsColumnBuilder.NewArray()
                outputColumns = append(outputColumns, tsColumn)

                // Mark builders and arrays for release.
                s.statusColumnBuildersToRelease = append(s.statusColumnBuildersToRelease, statusColumnBuilder)
                s.tsColumnBuildersToRelease = append(s.tsColumnBuildersToRelease, tsColumnBuilder)
                s.arraysToRelease = append(s.arraysToRelease, statusColumn)
                s.arraysToRelease = append(s.arraysToRelease, tsColumn)
                s.arraysToRelease = append(s.arraysToRelease, featureVector.Values)</span>
        }

        <span class="cov0" title="0">result := array.NewRecord(arrow.NewSchema(outputFields, nil), outputColumns, int64(numRows))
        s.resultsToRelease = append(s.resultsToRelease, result)

        cdata.ExportArrowRecordBatch(result, cdata.ArrayFromPtr(output.DataPtr), cdata.SchemaFromPtr(output.SchemaPtr))

        return nil</span>
}

// StartGprcServer starts gRPC server with disabled feature logging and blocks the thread
func (s *OnlineFeatureService) StartGprcServer(host string, port int) error <span class="cov0" title="0">{
        return s.StartGrpcServerWithLogging(host, port, nil, LoggingOptions{})
}</span>

// StartGprcServerWithLoggingDefaultOpts starts gRPC server with enabled feature logging but default configuration for logging
// Caller of this function must provide Python callback to flush buffered logs
func (s *OnlineFeatureService) StartGprcServerWithLoggingDefaultOpts(host string, port int, writeLoggedFeaturesCallback logging.OfflineStoreWriteCallback) error <span class="cov0" title="0">{
        defaultOpts := LoggingOptions{
                ChannelCapacity: logging.DefaultOptions.ChannelCapacity,
                EmitTimeout:     logging.DefaultOptions.EmitTimeout,
                WriteInterval:   logging.DefaultOptions.WriteInterval,
                FlushInterval:   logging.DefaultOptions.FlushInterval,
        }
        return s.StartGrpcServerWithLogging(host, port, writeLoggedFeaturesCallback, defaultOpts)
}</span>

func (s *OnlineFeatureService) constructLoggingService(writeLoggedFeaturesCallback logging.OfflineStoreWriteCallback, loggingOpts LoggingOptions) (*logging.LoggingService, error) <span class="cov0" title="0">{
        var loggingService *logging.LoggingService = nil
        if writeLoggedFeaturesCallback != nil </span><span class="cov0" title="0">{
                sink, err := logging.NewOfflineStoreSink(writeLoggedFeaturesCallback)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">loggingService, err = logging.NewLoggingService(s.fs, sink, logging.LoggingOptions{
                        ChannelCapacity: loggingOpts.ChannelCapacity,
                        EmitTimeout:     loggingOpts.EmitTimeout,
                        WriteInterval:   loggingOpts.WriteInterval,
                        FlushInterval:   loggingOpts.FlushInterval,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">return loggingService, nil</span>
}

// StartGrpcServerWithLogging starts gRPC server with enabled feature logging
// Caller of this function must provide Python callback to flush buffered logs as well as logging configuration (loggingOpts)
func (s *OnlineFeatureService) StartGrpcServerWithLogging(host string, port int, writeLoggedFeaturesCallback logging.OfflineStoreWriteCallback, loggingOpts LoggingOptions) error <span class="cov0" title="0">{
        if strings.ToLower(os.Getenv("ENABLE_DATADOG_TRACING")) == "true" </span><span class="cov0" title="0">{
                tracer.Start(tracer.WithRuntimeMetrics())
                defer tracer.Stop()
        }</span>

        <span class="cov0" title="0">loggingService, err := s.constructLoggingService(writeLoggedFeaturesCallback, loggingOpts)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">ser := server.NewGrpcServingServiceServer(s.fs, loggingService)
        log.Printf("Starting a gRPC server on host %s port %d\n", host, port)
        lis, err := net.Listen("tcp", fmt.Sprintf("%s:%d", host, port))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">grpcServer := grpc.NewServer(grpc.UnaryInterceptor(grpctrace.UnaryServerInterceptor()))

        serving.RegisterServingServiceServer(grpcServer, ser)
        healthService := health.NewServer()
        grpc_health_v1.RegisterHealthServer(grpcServer, healthService)

        go func() </span><span class="cov0" title="0">{
                // As soon as these signals are received from OS, try to gracefully stop the gRPC server
                &lt;-s.grpcStopCh
                log.Println("Stopping the gRPC server...")
                grpcServer.GracefulStop()
                if loggingService != nil </span><span class="cov0" title="0">{
                        loggingService.Stop()
                }</span>
                <span class="cov0" title="0">log.Println("gRPC server terminated")</span>
        }()

        <span class="cov0" title="0">err = grpcServer.Serve(lis)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// StartHttpServer starts HTTP server with disabled feature logging and blocks the thread
func (s *OnlineFeatureService) StartHttpServer(host string, port int) error <span class="cov0" title="0">{
        return s.StartHttpServerWithLogging(host, port, nil, LoggingOptions{})
}</span>

// StartHttpServerWithLoggingDefaultOpts starts HTTP server with enabled feature logging but default configuration for logging
// Caller of this function must provide Python callback to flush buffered logs
func (s *OnlineFeatureService) StartHttpServerWithLoggingDefaultOpts(host string, port int, writeLoggedFeaturesCallback logging.OfflineStoreWriteCallback) error <span class="cov0" title="0">{
        defaultOpts := LoggingOptions{
                ChannelCapacity: logging.DefaultOptions.ChannelCapacity,
                EmitTimeout:     logging.DefaultOptions.EmitTimeout,
                WriteInterval:   logging.DefaultOptions.WriteInterval,
                FlushInterval:   logging.DefaultOptions.FlushInterval,
        }
        return s.StartHttpServerWithLogging(host, port, writeLoggedFeaturesCallback, defaultOpts)
}</span>

// StartHttpServerWithLogging starts HTTP server with enabled feature logging
// Caller of this function must provide Python callback to flush buffered logs as well as logging configuration (loggingOpts)
func (s *OnlineFeatureService) StartHttpServerWithLogging(host string, port int, writeLoggedFeaturesCallback logging.OfflineStoreWriteCallback, loggingOpts LoggingOptions) error <span class="cov0" title="0">{
        loggingService, err := s.constructLoggingService(writeLoggedFeaturesCallback, loggingOpts)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">ser := server.NewHttpServer(s.fs, loggingService)
        log.Printf("Starting a HTTP server on host %s port %d\n", host, port)

        go func() </span><span class="cov0" title="0">{
                // As soon as these signals are received from OS, try to gracefully stop the gRPC server
                &lt;-s.httpStopCh
                log.Println("Stopping the HTTP server...")
                err := ser.Stop()
                if err != nil </span><span class="cov0" title="0">{
                        log.Printf("Error when stopping the HTTP server: %v\n", err)
                }</span>
                <span class="cov0" title="0">if loggingService != nil </span><span class="cov0" title="0">{
                        loggingService.Stop()
                }</span>
                <span class="cov0" title="0">log.Println("HTTP server terminated")</span>
        }()

        <span class="cov0" title="0">return ser.Serve(host, port)</span>
}

func (s *OnlineFeatureService) StopHttpServer() <span class="cov0" title="0">{
        s.httpStopCh &lt;- syscall.SIGINT
}</span>

func (s *OnlineFeatureService) StopGrpcServer() <span class="cov0" title="0">{
        s.grpcStopCh &lt;- syscall.SIGINT
}</span>

/*
Read Record Batch from memory managed by Python caller.
Python part uses C ABI interface to export this record into C Data Interface,
and then it provides pointers (dataPtr &amp; schemaPtr) to the Go part.
Here we import this data from given pointers and wrap the underlying values
into Go Arrow Interface (array.Record).
See export code here https://github.com/feast-dev/feast/blob/master/sdk/python/feast/embedded_go/online_features_service.py
*/
func readArrowRecord(data DataTable) (arrow.Record, error) <span class="cov0" title="0">{
        return cdata.ImportCRecordBatch(
                cdata.ArrayFromPtr(data.DataPtr),
                cdata.SchemaFromPtr(data.SchemaPtr))
}</span>

func recordToProto(rec arrow.Record) (map[string]*prototypes.RepeatedValue, error) <span class="cov0" title="0">{
        r := make(map[string]*prototypes.RepeatedValue)
        schema := rec.Schema()
        for idx, column := range rec.Columns() </span><span class="cov0" title="0">{
                field := schema.Field(idx)
                values, err := types.ArrowValuesToProtoValues(column)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">r[field.Name] = &amp;prototypes.RepeatedValue{Val: values}</span>
        }
        <span class="cov0" title="0">return r, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package feast

import (
        "context"
        "errors"
        "fmt"
        "os"
        "strings"

        "github.com/apache/arrow/go/v17/arrow/memory"
        "gopkg.in/DataDog/dd-trace-go.v1/ddtrace/tracer"

        "github.com/feast-dev/feast/go/internal/feast/model"
        "github.com/feast-dev/feast/go/internal/feast/onlineserving"
        "github.com/feast-dev/feast/go/internal/feast/onlinestore"
        "github.com/feast-dev/feast/go/internal/feast/registry"
        "github.com/feast-dev/feast/go/internal/feast/transformation"
        "github.com/feast-dev/feast/go/protos/feast/serving"
        prototypes "github.com/feast-dev/feast/go/protos/feast/types"
)

type FeatureStore struct {
        config                 *registry.RepoConfig
        registry               *registry.Registry
        onlineStore            onlinestore.OnlineStore
        transformationCallback transformation.TransformationCallback
        transformationService  *transformation.GrpcTransformationService
}

// A Features struct specifies a list of features to be retrieved from the online store. These features
// can be specified either as a list of string feature references or as a feature service. String
// feature references must have format "feature_view:feature", e.g. "customer_fv:daily_transactions".
type Features struct {
        FeaturesRefs   []string
        FeatureService *model.FeatureService
}

func (fs *FeatureStore) Registry() *registry.Registry <span class="cov0" title="0">{
        return fs.registry
}</span>

func (fs *FeatureStore) GetRepoConfig() *registry.RepoConfig <span class="cov0" title="0">{
        return fs.config
}</span>

// NewFeatureStore constructs a feature store fat client using the
// repo config (contents of feature_store.yaml converted to JSON map).
func NewFeatureStore(config *registry.RepoConfig, callback transformation.TransformationCallback) (*FeatureStore, error) <span class="cov0" title="0">{
        onlineStore, err := onlinestore.NewOnlineStore(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">registryConfig, err := config.GetRegistryConfig()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">registry, err := registry.NewRegistry(registryConfig, config.RepoPath, config.Project)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">err = registry.InitializeRegistry()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">sanitizedProjectName := strings.Replace(config.Project, "_", "-", -1)
        productName := os.Getenv("PRODUCT")
        endpoint := fmt.Sprintf("%s-transformations.%s.svc.cluster.local:80", sanitizedProjectName, productName)
        transformationService, _ := transformation.NewGrpcTransformationService(config, endpoint)

        return &amp;FeatureStore{
                config:                 config,
                registry:               registry,
                onlineStore:            onlineStore,
                transformationCallback: callback,
                transformationService:  transformationService,
        }, nil</span>
}

// TODO: Review all functions that use ODFV and Request FV since these have not been tested
// ToDo: Split GetOnlineFeatures interface into two: GetOnlinFeaturesByFeatureService and GetOnlineFeaturesByFeatureRefs
func (fs *FeatureStore) GetOnlineFeatures(
        ctx context.Context,
        featureRefs []string,
        featureService *model.FeatureService,
        joinKeyToEntityValues map[string]*prototypes.RepeatedValue,
        requestData map[string]*prototypes.RepeatedValue,
        fullFeatureNames bool) ([]*onlineserving.FeatureVector, error) <span class="cov0" title="0">{
        fvs, odFvs, err := fs.listAllViews()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">entities, err := fs.ListEntities(false)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var requestedFeatureViews []*onlineserving.FeatureViewAndRefs
        var requestedOnDemandFeatureViews []*model.OnDemandFeatureView
        if featureService != nil </span><span class="cov0" title="0">{
                requestedFeatureViews, requestedOnDemandFeatureViews, err =
                        onlineserving.GetFeatureViewsToUseByService(featureService, fvs, odFvs)
        }</span> else<span class="cov0" title="0"> {
                requestedFeatureViews, requestedOnDemandFeatureViews, err =
                        onlineserving.GetFeatureViewsToUseByFeatureRefs(featureRefs, fvs, odFvs)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">entityNameToJoinKeyMap, expectedJoinKeysSet, err := onlineserving.GetEntityMaps(requestedFeatureViews, entities)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">err = onlineserving.ValidateFeatureRefs(requestedFeatureViews, fullFeatureNames)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">numRows, err := onlineserving.ValidateEntityValues(joinKeyToEntityValues, requestData, expectedJoinKeysSet)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">err = transformation.EnsureRequestedDataExist(requestedOnDemandFeatureViews, requestData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">result := make([]*onlineserving.FeatureVector, 0)
        arrowMemory := memory.NewGoAllocator()
        featureViews := make([]*model.FeatureView, len(requestedFeatureViews))
        index := 0
        for _, featuresAndView := range requestedFeatureViews </span><span class="cov0" title="0">{
                featureViews[index] = featuresAndView.View
                index += 1
        }</span>

        <span class="cov0" title="0">entitylessCase := false
        for _, featureView := range featureViews </span><span class="cov0" title="0">{
                if featureView.HasEntity(model.DUMMY_ENTITY_NAME) </span><span class="cov0" title="0">{
                        entitylessCase = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if entitylessCase </span><span class="cov0" title="0">{
                dummyEntityColumn := &amp;prototypes.RepeatedValue{Val: make([]*prototypes.Value, numRows)}
                for index := 0; index &lt; numRows; index++ </span><span class="cov0" title="0">{
                        dummyEntityColumn.Val[index] = &amp;model.DUMMY_ENTITY_VALUE
                }</span>
                <span class="cov0" title="0">joinKeyToEntityValues[model.DUMMY_ENTITY_ID] = dummyEntityColumn</span>
        }

        <span class="cov0" title="0">groupedRefs, err := onlineserving.GroupFeatureRefs(requestedFeatureViews, joinKeyToEntityValues, entityNameToJoinKeyMap, fullFeatureNames)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, groupRef := range groupedRefs </span><span class="cov0" title="0">{
                featureData, err := fs.readFromOnlineStore(ctx, groupRef.EntityKeys, groupRef.FeatureViewNames, groupRef.FeatureNames)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">vectors, err := onlineserving.TransposeFeatureRowsIntoColumns(
                        featureData,
                        groupRef,
                        requestedFeatureViews,
                        arrowMemory,
                        numRows,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">result = append(result, vectors...)</span>
        }

        <span class="cov0" title="0">if fs.transformationCallback != nil || fs.transformationService != nil </span><span class="cov0" title="0">{
                onDemandFeatures, err := transformation.AugmentResponseWithOnDemandTransforms(
                        ctx,
                        requestedOnDemandFeatureViews,
                        requestData,
                        joinKeyToEntityValues,
                        result,
                        fs.transformationCallback,
                        fs.transformationService,
                        arrowMemory,
                        numRows,
                        fullFeatureNames,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">result = append(result, onDemandFeatures...)</span>
        }

        <span class="cov0" title="0">result, err = onlineserving.KeepOnlyRequestedFeatures(result, featureRefs, featureService, fullFeatureNames)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">entityColumns, err := onlineserving.EntitiesToFeatureVectors(joinKeyToEntityValues, arrowMemory, numRows)
        result = append(entityColumns, result...)
        return result, nil</span>
}

func (fs *FeatureStore) DestructOnlineStore() <span class="cov0" title="0">{
        fs.onlineStore.Destruct()
}</span>

// ParseFeatures parses the kind field of a GetOnlineFeaturesRequest protobuf message
// and populates a Features struct with the result.
func (fs *FeatureStore) ParseFeatures(kind interface{}) (*Features, error) <span class="cov0" title="0">{
        if featureList, ok := kind.(*serving.GetOnlineFeaturesRequest_Features); ok </span><span class="cov0" title="0">{
                return &amp;Features{FeaturesRefs: featureList.Features.GetVal(), FeatureService: nil}, nil
        }</span>
        <span class="cov0" title="0">if featureServiceRequest, ok := kind.(*serving.GetOnlineFeaturesRequest_FeatureService); ok </span><span class="cov0" title="0">{
                featureService, err := fs.registry.GetFeatureService(fs.config.Project, featureServiceRequest.FeatureService)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return &amp;Features{FeaturesRefs: nil, FeatureService: featureService}, nil</span>
        }
        <span class="cov0" title="0">return nil, errors.New("cannot parse kind from GetOnlineFeaturesRequest")</span>
}

func (fs *FeatureStore) GetFeatureService(name string) (*model.FeatureService, error) <span class="cov0" title="0">{
        return fs.registry.GetFeatureService(fs.config.Project, name)
}</span>

func (fs *FeatureStore) listAllViews() (map[string]*model.FeatureView, map[string]*model.OnDemandFeatureView, error) <span class="cov0" title="0">{
        fvs := make(map[string]*model.FeatureView)
        odFvs := make(map[string]*model.OnDemandFeatureView)

        featureViews, err := fs.ListFeatureViews()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">for _, featureView := range featureViews </span><span class="cov0" title="0">{
                fvs[featureView.Base.Name] = featureView
        }</span>

        <span class="cov0" title="0">streamFeatureViews, err := fs.ListStreamFeatureViews()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">for _, streamFeatureView := range streamFeatureViews </span><span class="cov0" title="0">{
                fvs[streamFeatureView.Base.Name] = streamFeatureView
        }</span>

        <span class="cov0" title="0">onDemandFeatureViews, err := fs.registry.ListOnDemandFeatureViews(fs.config.Project)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">for _, onDemandFeatureView := range onDemandFeatureViews </span><span class="cov0" title="0">{
                odFvs[onDemandFeatureView.Base.Name] = onDemandFeatureView
        }</span>
        <span class="cov0" title="0">return fvs, odFvs, nil</span>
}

func (fs *FeatureStore) ListFeatureViews() ([]*model.FeatureView, error) <span class="cov0" title="0">{
        featureViews, err := fs.registry.ListFeatureViews(fs.config.Project)
        if err != nil </span><span class="cov0" title="0">{
                return featureViews, err
        }</span>
        <span class="cov0" title="0">return featureViews, nil</span>
}

func (fs *FeatureStore) ListStreamFeatureViews() ([]*model.FeatureView, error) <span class="cov0" title="0">{
        streamFeatureViews, err := fs.registry.ListStreamFeatureViews(fs.config.Project)
        if err != nil </span><span class="cov0" title="0">{
                return streamFeatureViews, err
        }</span>
        <span class="cov0" title="0">return streamFeatureViews, nil</span>
}

func (fs *FeatureStore) ListEntities(hideDummyEntity bool) ([]*model.Entity, error) <span class="cov0" title="0">{

        allEntities, err := fs.registry.ListEntities(fs.config.Project)
        if err != nil </span><span class="cov0" title="0">{
                return allEntities, err
        }</span>
        <span class="cov0" title="0">entities := make([]*model.Entity, 0)
        for _, entity := range allEntities </span><span class="cov0" title="0">{
                if entity.Name != model.DUMMY_ENTITY_NAME || !hideDummyEntity </span><span class="cov0" title="0">{
                        entities = append(entities, entity)
                }</span>
        }
        <span class="cov0" title="0">return entities, nil</span>
}

func (fs *FeatureStore) ListOnDemandFeatureViews() ([]*model.OnDemandFeatureView, error) <span class="cov0" title="0">{
        return fs.registry.ListOnDemandFeatureViews(fs.config.Project)
}</span>

/*
Group feature views that share the same set of join keys. For each group, we store only unique rows and save indices to retrieve those
rows for each requested feature
*/

func (fs *FeatureStore) GetFeatureView(featureViewName string, hideDummyEntity bool) (*model.FeatureView, error) <span class="cov0" title="0">{
        fv, err := fs.registry.GetFeatureView(fs.config.Project, featureViewName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if fv.HasEntity(model.DUMMY_ENTITY_NAME) &amp;&amp; hideDummyEntity </span><span class="cov0" title="0">{
                fv.EntityNames = []string{}
        }</span>
        <span class="cov0" title="0">return fv, nil</span>
}

func (fs *FeatureStore) readFromOnlineStore(ctx context.Context, entityRows []*prototypes.EntityKey,
        requestedFeatureViewNames []string,
        requestedFeatureNames []string,
) ([][]onlinestore.FeatureData, error) <span class="cov0" title="0">{
        // Create a Datadog span from context
        span, _ := tracer.StartSpanFromContext(ctx, "fs.readFromOnlineStore")
        defer span.Finish()

        numRows := len(entityRows)
        entityRowsValue := make([]*prototypes.EntityKey, numRows)
        for index, entityKey := range entityRows </span><span class="cov0" title="0">{
                entityRowsValue[index] = &amp;prototypes.EntityKey{JoinKeys: entityKey.JoinKeys, EntityValues: entityKey.EntityValues}
        }</span>
        <span class="cov0" title="0">return fs.onlineStore.OnlineRead(ctx, entityRowsValue, requestedFeatureViewNames, requestedFeatureNames)</span>
}

func (fs *FeatureStore) GetFcosMap() (map[string]*model.Entity, map[string]*model.FeatureView, map[string]*model.OnDemandFeatureView, error) <span class="cov0" title="0">{
        odfvs, err := fs.ListOnDemandFeatureViews()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, err
        }</span>
        <span class="cov0" title="0">fvs, err := fs.ListFeatureViews()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, err
        }</span>
        <span class="cov0" title="0">entities, err := fs.ListEntities(true)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, err
        }</span>

        <span class="cov0" title="0">entityMap := make(map[string]*model.Entity)
        for _, entity := range entities </span><span class="cov0" title="0">{
                entityMap[entity.Name] = entity
        }</span>
        <span class="cov0" title="0">fvMap := make(map[string]*model.FeatureView)
        for _, fv := range fvs </span><span class="cov0" title="0">{
                fvMap[fv.Base.Name] = fv
        }</span>
        <span class="cov0" title="0">odfvMap := make(map[string]*model.OnDemandFeatureView)
        for _, odfv := range odfvs </span><span class="cov0" title="0">{
                odfvMap[odfv.Base.Name] = odfv
        }</span>
        <span class="cov0" title="0">return entityMap, fvMap, odfvMap, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package model

import (
        "fmt"

        "github.com/feast-dev/feast/go/protos/feast/core"
)

type BaseFeatureView struct {
        Name       string
        Features   []*Field
        Projection *FeatureViewProjection
}

func NewBaseFeatureView(name string, featureProtos []*core.FeatureSpecV2) *BaseFeatureView <span class="cov8" title="1">{
        base := &amp;BaseFeatureView{Name: name}
        features := make([]*Field, len(featureProtos))
        for index, featureSpecV2 := range featureProtos </span><span class="cov8" title="1">{
                features[index] = NewFieldFromProto(featureSpecV2)
        }</span>
        <span class="cov8" title="1">base.Features = features
        base.Projection = NewFeatureViewProjectionFromDefinition(base)
        return base</span>
}

func (fv *BaseFeatureView) WithProjection(projection *FeatureViewProjection) (*BaseFeatureView, error) <span class="cov8" title="1">{
        if projection.Name != fv.Name </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("the projection for the %s FeatureView cannot be applied because it differs "+
                        "in Name; the projection is named %s and the Name indicates which "+
                        "FeatureView the projection is for", fv.Name, projection.Name)
        }</span>
        <span class="cov8" title="1">features := make(map[string]bool)
        for _, feature := range fv.Features </span><span class="cov8" title="1">{
                features[feature.Name] = true
        }</span>
        <span class="cov8" title="1">for _, feature := range projection.Features </span><span class="cov8" title="1">{
                if _, ok := features[feature.Name]; !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("the projection for %s cannot be applied because it contains %s which the "+
                                "FeatureView doesn't have", projection.Name, feature.Name)
                }</span>
        }
        <span class="cov8" title="1">return &amp;BaseFeatureView{Name: fv.Name, Features: fv.Features, Projection: projection}, nil</span>
}

func (fv *BaseFeatureView) ProjectWithFeatures(featureNames []string) *FeatureViewProjection <span class="cov8" title="1">{
        features := make([]*Field, 0)
        for _, feature := range fv.Features </span><span class="cov8" title="1">{
                for _, allowedFeatureName := range featureNames </span><span class="cov8" title="1">{
                        if feature.Name == allowedFeatureName </span><span class="cov8" title="1">{
                                features = append(features, feature)
                        }</span>
                }
        }

        <span class="cov8" title="1">return &amp;FeatureViewProjection{
                Name:     fv.Name,
                Features: features,
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package model

import (
        "github.com/feast-dev/feast/go/protos/feast/core"
)

type Entity struct {
        Name    string
        JoinKey string
}

func NewEntityFromProto(proto *core.Entity) *Entity <span class="cov8" title="1">{
        return &amp;Entity{
                Name:    proto.Spec.Name,
                JoinKey: proto.Spec.JoinKey,
        }
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package model

import (
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"

        "github.com/feast-dev/feast/go/protos/feast/core"
)

type FeatureService struct {
        Name                 string
        Project              string
        CreatedTimestamp     *timestamppb.Timestamp
        LastUpdatedTimestamp *timestamppb.Timestamp
        Projections          []*FeatureViewProjection
        LoggingConfig        *FeatureServiceLoggingConfig
}

type FeatureServiceLoggingConfig struct {
        SampleRate float32
}

func NewFeatureServiceFromProto(proto *core.FeatureService) *FeatureService <span class="cov8" title="1">{
        projections := make([]*FeatureViewProjection, len(proto.Spec.Features))
        for index, projectionProto := range proto.Spec.Features </span><span class="cov8" title="1">{
                projections[index] = NewFeatureViewProjectionFromProto(projectionProto)
        }</span>
        <span class="cov8" title="1">var loggingConfig *FeatureServiceLoggingConfig
        if proto.GetSpec().GetLoggingConfig() != nil </span><span class="cov8" title="1">{
                loggingConfig = &amp;FeatureServiceLoggingConfig{
                        SampleRate: proto.GetSpec().GetLoggingConfig().SampleRate,
                }
        }</span>
        <span class="cov8" title="1">return &amp;FeatureService{Name: proto.Spec.Name,
                Project:              proto.Spec.Project,
                CreatedTimestamp:     proto.Meta.CreatedTimestamp,
                LastUpdatedTimestamp: proto.Meta.LastUpdatedTimestamp,
                Projections:          projections,
                LoggingConfig:        loggingConfig,
        }</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package model

import (
        durationpb "google.golang.org/protobuf/types/known/durationpb"

        "github.com/feast-dev/feast/go/protos/feast/core"
        "github.com/feast-dev/feast/go/protos/feast/types"
)

const (
        DUMMY_ENTITY_ID   = "__dummy_id"
        DUMMY_ENTITY_NAME = "__dummy"
        DUMMY_ENTITY_VAL  = ""
)

var DUMMY_ENTITY_VALUE types.Value = types.Value{Val: &amp;types.Value_StringVal{StringVal: DUMMY_ENTITY_VAL}}

type FeatureView struct {
        Base          *BaseFeatureView
        Ttl           *durationpb.Duration
        EntityNames   []string
        EntityColumns []*Field
}

func NewFeatureViewFromProto(proto *core.FeatureView) *FeatureView <span class="cov8" title="1">{
        featureView := &amp;FeatureView{Base: NewBaseFeatureView(proto.Spec.Name, proto.Spec.Features),
                Ttl: proto.Spec.Ttl,
        }
        if len(proto.Spec.Entities) == 0 </span><span class="cov0" title="0">{
                featureView.EntityNames = []string{DUMMY_ENTITY_NAME}
        }</span> else<span class="cov8" title="1"> {
                featureView.EntityNames = proto.Spec.Entities
        }</span>
        <span class="cov8" title="1">entityColumns := make([]*Field, len(proto.Spec.EntityColumns))
        for i, entityColumn := range proto.Spec.EntityColumns </span><span class="cov8" title="1">{
                entityColumns[i] = NewFieldFromProto(entityColumn)
        }</span>
        <span class="cov8" title="1">featureView.EntityColumns = entityColumns
        return featureView</span>
}

func NewFeatureViewFromStreamFeatureViewProto(proto *core.StreamFeatureView) *FeatureView <span class="cov0" title="0">{
        featureView := &amp;FeatureView{Base: NewBaseFeatureView(proto.Spec.Name, proto.Spec.Features),
                Ttl: proto.Spec.Ttl,
        }
        if len(proto.Spec.Entities) == 0 </span><span class="cov0" title="0">{
                featureView.EntityNames = []string{DUMMY_ENTITY_NAME}
        }</span> else<span class="cov0" title="0"> {
                featureView.EntityNames = proto.Spec.Entities
        }</span>
        <span class="cov0" title="0">entityColumns := make([]*Field, len(proto.Spec.EntityColumns))
        for i, entityColumn := range proto.Spec.EntityColumns </span><span class="cov0" title="0">{
                entityColumns[i] = NewFieldFromProto(entityColumn)
        }</span>
        <span class="cov0" title="0">featureView.EntityColumns = entityColumns
        return featureView</span>
}

func (fv *FeatureView) NewFeatureViewFromBase(base *BaseFeatureView) *FeatureView <span class="cov8" title="1">{
        ttl := durationpb.Duration{Seconds: fv.Ttl.Seconds, Nanos: fv.Ttl.Nanos}
        featureView := &amp;FeatureView{Base: base,
                Ttl:         &amp;ttl,
                EntityNames: fv.EntityNames,
        }
        return featureView
}</span>

func (fv *FeatureView) HasEntity(name string) bool <span class="cov8" title="1">{
        for _, entityName := range fv.EntityNames </span><span class="cov8" title="1">{
                if entityName == name </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package model

import (
        "github.com/feast-dev/feast/go/protos/feast/core"
)

type FeatureViewProjection struct {
        Name       string
        NameAlias  string
        Features   []*Field
        JoinKeyMap map[string]string
}

func (fv *FeatureViewProjection) NameToUse() string <span class="cov8" title="1">{
        if len(fv.NameAlias) == 0 </span><span class="cov8" title="1">{
                return fv.Name
        }</span>
        <span class="cov8" title="1">return fv.NameAlias</span>
}

func NewFeatureViewProjectionFromProto(proto *core.FeatureViewProjection) *FeatureViewProjection <span class="cov8" title="1">{
        featureProjection := &amp;FeatureViewProjection{Name: proto.FeatureViewName,
                NameAlias:  proto.FeatureViewNameAlias,
                JoinKeyMap: proto.JoinKeyMap,
        }

        features := make([]*Field, len(proto.FeatureColumns))
        for index, featureSpecV2 := range proto.FeatureColumns </span><span class="cov8" title="1">{
                features[index] = NewFieldFromProto(featureSpecV2)
        }</span>
        <span class="cov8" title="1">featureProjection.Features = features
        return featureProjection</span>
}

func NewFeatureViewProjectionFromDefinition(base *BaseFeatureView) *FeatureViewProjection <span class="cov8" title="1">{
        return &amp;FeatureViewProjection{Name: base.Name,
                NameAlias:  "",
                Features:   base.Features,
                JoinKeyMap: make(map[string]string),
        }
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package model

import (
        "github.com/feast-dev/feast/go/protos/feast/core"
        "github.com/feast-dev/feast/go/protos/feast/types"
)

type Field struct {
        Name  string
        Dtype types.ValueType_Enum
}

func NewFieldFromProto(proto *core.FeatureSpecV2) *Field <span class="cov8" title="1">{
        return &amp;Field{
                Name:  proto.Name,
                Dtype: proto.ValueType,
        }
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package model

import (
        "github.com/feast-dev/feast/go/protos/feast/core"
        "github.com/feast-dev/feast/go/protos/feast/types"
)

type OnDemandFeatureView struct {
        Base                         *BaseFeatureView
        SourceFeatureViewProjections map[string]*FeatureViewProjection
        SourceRequestDataSources     map[string]*core.DataSource_RequestDataOptions
}

func NewOnDemandFeatureViewFromProto(proto *core.OnDemandFeatureView) *OnDemandFeatureView <span class="cov8" title="1">{
        onDemandFeatureView := &amp;OnDemandFeatureView{Base: NewBaseFeatureView(proto.Spec.Name, proto.Spec.Features),
                SourceFeatureViewProjections: make(map[string]*FeatureViewProjection),
                SourceRequestDataSources:     make(map[string]*core.DataSource_RequestDataOptions),
        }
        for sourceName, onDemandSource := range proto.Spec.Sources </span><span class="cov8" title="1">{
                if onDemandSourceFeatureView, ok := onDemandSource.Source.(*core.OnDemandSource_FeatureView); ok </span><span class="cov0" title="0">{
                        featureViewProto := onDemandSourceFeatureView.FeatureView
                        featureView := NewFeatureViewFromProto(featureViewProto)
                        onDemandFeatureView.SourceFeatureViewProjections[sourceName] = featureView.Base.Projection
                }</span> else<span class="cov8" title="1"> if onDemandSourceFeatureViewProjection, ok := onDemandSource.Source.(*core.OnDemandSource_FeatureViewProjection); ok </span><span class="cov8" title="1">{
                        featureProjectionProto := onDemandSourceFeatureViewProjection.FeatureViewProjection
                        onDemandFeatureView.SourceFeatureViewProjections[sourceName] = NewFeatureViewProjectionFromProto(featureProjectionProto)
                }</span> else<span class="cov0" title="0"> if onDemandSourceRequestFeatureView, ok := onDemandSource.Source.(*core.OnDemandSource_RequestDataSource); ok </span><span class="cov0" title="0">{

                        if dataSourceRequestOptions, ok := onDemandSourceRequestFeatureView.RequestDataSource.Options.(*core.DataSource_RequestDataOptions_); ok </span><span class="cov0" title="0">{
                                onDemandFeatureView.SourceRequestDataSources[sourceName] = dataSourceRequestOptions.RequestDataOptions
                        }</span>
                }
        }

        <span class="cov8" title="1">return onDemandFeatureView</span>
}

func (fs *OnDemandFeatureView) NewWithProjection(projection *FeatureViewProjection) (*OnDemandFeatureView, error) <span class="cov8" title="1">{
        projectedBase, err := fs.Base.WithProjection(projection)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">featureView := &amp;OnDemandFeatureView{
                Base:                         projectedBase,
                SourceFeatureViewProjections: fs.SourceFeatureViewProjections,
                SourceRequestDataSources:     fs.SourceRequestDataSources,
        }
        return featureView, nil</span>
}

func NewOnDemandFeatureViewFromBase(base *BaseFeatureView) *OnDemandFeatureView <span class="cov8" title="1">{
        featureView := &amp;OnDemandFeatureView{
                Base:                         base,
                SourceFeatureViewProjections: map[string]*FeatureViewProjection{},
                SourceRequestDataSources:     map[string]*core.DataSource_RequestDataOptions{}}
        return featureView
}</span>

func (fs *OnDemandFeatureView) ProjectWithFeatures(featureNames []string) (*OnDemandFeatureView, error) <span class="cov8" title="1">{
        return fs.NewWithProjection(fs.Base.ProjectWithFeatures(featureNames))
}</span>

func (fs *OnDemandFeatureView) GetRequestDataSchema() map[string]types.ValueType_Enum <span class="cov8" title="1">{
        schema := make(map[string]types.ValueType_Enum)
        for _, requestDataSource := range fs.SourceRequestDataSources </span><span class="cov8" title="1">{
                for _, featureSpec := range requestDataSource.Schema </span><span class="cov8" title="1">{
                        schema[featureSpec.Name] = featureSpec.ValueType
                }</span>
        }
        <span class="cov8" title="1">return schema</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package onlineserving

import (
        "crypto/sha256"
        "errors"
        "fmt"
        "sort"
        "strings"

        "github.com/apache/arrow/go/v17/arrow"
        "github.com/apache/arrow/go/v17/arrow/memory"
        "google.golang.org/protobuf/proto"
        "google.golang.org/protobuf/types/known/durationpb"
        "google.golang.org/protobuf/types/known/timestamppb"

        "github.com/feast-dev/feast/go/internal/feast/model"
        "github.com/feast-dev/feast/go/internal/feast/onlinestore"
        "github.com/feast-dev/feast/go/protos/feast/serving"
        prototypes "github.com/feast-dev/feast/go/protos/feast/types"
        "github.com/feast-dev/feast/go/types"
)

/*
FeatureVector type represent result of retrieving single feature for multiple rows.
It can be imagined as a column in output dataframe / table.
It contains of feature name, list of values (across all rows),
list of statuses and list of timestamp. All these lists have equal length.
And this length is also equal to number of entity rows received in request.
*/
type FeatureVector struct {
        Name       string
        Values     arrow.Array
        Statuses   []serving.FieldStatus
        Timestamps []*timestamppb.Timestamp
}

type FeatureViewAndRefs struct {
        View        *model.FeatureView
        FeatureRefs []string
}

/*
We group all features from a single request by entities they attached to.
Thus, we will be able to call online retrieval per entity and not per each feature View.
In this struct we collect all features and views that belongs to a group.
We also store here projected entity keys (only ones that needed to retrieve these features)
and indexes to map result of retrieval into output response.
*/
type GroupedFeaturesPerEntitySet struct {
        // A list of requested feature references of the form featureViewName:featureName that share this entity set
        FeatureNames     []string
        FeatureViewNames []string
        // full feature references as they supposed to appear in response
        AliasedFeatureNames []string
        // Entity set as a list of EntityKeys to pass to OnlineRead
        EntityKeys []*prototypes.EntityKey
        // Reversed mapping to project result of retrieval from storage to response
        Indices [][]int
}

/*
Return

        (1) requested feature views and features grouped per View
        (2) requested on demand feature views

existed in the registry
*/
func GetFeatureViewsToUseByService(
        featureService *model.FeatureService,
        featureViews map[string]*model.FeatureView,
        onDemandFeatureViews map[string]*model.OnDemandFeatureView) ([]*FeatureViewAndRefs, []*model.OnDemandFeatureView, error) <span class="cov8" title="1">{

        viewNameToViewAndRefs := make(map[string]*FeatureViewAndRefs)
        odFvsToUse := make([]*model.OnDemandFeatureView, 0)

        for _, featureProjection := range featureService.Projections </span><span class="cov8" title="1">{
                // Create copies of FeatureView that may contains the same *FeatureView but
                // each differentiated by a *FeatureViewProjection
                featureViewName := featureProjection.Name
                if fv, ok := featureViews[featureViewName]; ok </span><span class="cov8" title="1">{
                        base, err := fv.Base.WithProjection(featureProjection)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, err
                        }</span>
                        <span class="cov8" title="1">if _, ok := viewNameToViewAndRefs[featureProjection.NameToUse()]; !ok </span><span class="cov8" title="1">{
                                viewNameToViewAndRefs[featureProjection.NameToUse()] = &amp;FeatureViewAndRefs{
                                        View:        fv.NewFeatureViewFromBase(base),
                                        FeatureRefs: []string{},
                                }
                        }</span>

                        <span class="cov8" title="1">for _, feature := range featureProjection.Features </span><span class="cov8" title="1">{
                                viewNameToViewAndRefs[featureProjection.NameToUse()].FeatureRefs =
                                        addStringIfNotContains(viewNameToViewAndRefs[featureProjection.NameToUse()].FeatureRefs,
                                                feature.Name)
                        }</span>

                } else<span class="cov8" title="1"> if odFv, ok := onDemandFeatureViews[featureViewName]; ok </span><span class="cov8" title="1">{
                        projectedOdFv, err := odFv.NewWithProjection(featureProjection)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, err
                        }</span>
                        <span class="cov8" title="1">odFvsToUse = append(odFvsToUse, projectedOdFv)
                        err = extractOdFvDependencies(
                                projectedOdFv,
                                featureViews,
                                viewNameToViewAndRefs)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, err
                        }</span>
                } else<span class="cov0" title="0"> {
                        return nil, nil, fmt.Errorf("the provided feature service %s contains a reference to a feature View"+
                                "%s which doesn't exist, please make sure that you have created the feature View"+
                                "%s and that you have registered it by running \"apply\"", featureService.Name, featureViewName, featureViewName)
                }</span>
        }

        <span class="cov8" title="1">fvsToUse := make([]*FeatureViewAndRefs, 0)
        for _, viewAndRef := range viewNameToViewAndRefs </span><span class="cov8" title="1">{
                fvsToUse = append(fvsToUse, viewAndRef)
        }</span>

        <span class="cov8" title="1">return fvsToUse, odFvsToUse, nil</span>
}

/*
Return

        (1) requested feature views and features grouped per View
        (2) requested on demand feature views

existed in the registry
*/
func GetFeatureViewsToUseByFeatureRefs(
        features []string,
        featureViews map[string]*model.FeatureView,
        onDemandFeatureViews map[string]*model.OnDemandFeatureView) ([]*FeatureViewAndRefs, []*model.OnDemandFeatureView, error) <span class="cov8" title="1">{
        viewNameToViewAndRefs := make(map[string]*FeatureViewAndRefs)
        odFvToFeatures := make(map[string][]string)

        for _, featureRef := range features </span><span class="cov8" title="1">{
                featureViewName, featureName, err := ParseFeatureReference(featureRef)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
                <span class="cov8" title="1">if fv, ok := featureViews[featureViewName]; ok </span><span class="cov8" title="1">{
                        if viewAndRef, ok := viewNameToViewAndRefs[fv.Base.Name]; ok </span><span class="cov8" title="1">{
                                viewAndRef.FeatureRefs = addStringIfNotContains(viewAndRef.FeatureRefs, featureName)
                        }</span> else<span class="cov8" title="1"> {
                                viewNameToViewAndRefs[fv.Base.Name] = &amp;FeatureViewAndRefs{
                                        View:        fv,
                                        FeatureRefs: []string{featureName},
                                }
                        }</span>
                } else<span class="cov8" title="1"> if odfv, ok := onDemandFeatureViews[featureViewName]; ok </span><span class="cov8" title="1">{
                        if _, ok := odFvToFeatures[odfv.Base.Name]; !ok </span><span class="cov8" title="1">{
                                odFvToFeatures[odfv.Base.Name] = []string{featureName}
                        }</span> else<span class="cov0" title="0"> {
                                odFvToFeatures[odfv.Base.Name] = append(
                                        odFvToFeatures[odfv.Base.Name], featureName)
                        }</span>
                } else<span class="cov0" title="0"> {
                        return nil, nil, fmt.Errorf("feature View %s doesn't exist, please make sure that you have created the"+
                                " feature View %s and that you have registered it by running \"apply\"", featureViewName, featureViewName)
                }</span>
        }

        <span class="cov8" title="1">odFvsToUse := make([]*model.OnDemandFeatureView, 0)

        for odFvName, featureNames := range odFvToFeatures </span><span class="cov8" title="1">{
                projectedOdFv, err := onDemandFeatureViews[odFvName].ProjectWithFeatures(featureNames)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>

                <span class="cov8" title="1">err = extractOdFvDependencies(
                        projectedOdFv,
                        featureViews,
                        viewNameToViewAndRefs)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
                <span class="cov8" title="1">odFvsToUse = append(odFvsToUse, projectedOdFv)</span>
        }

        <span class="cov8" title="1">fvsToUse := make([]*FeatureViewAndRefs, 0)
        for _, viewAndRefs := range viewNameToViewAndRefs </span><span class="cov8" title="1">{
                fvsToUse = append(fvsToUse, viewAndRefs)
        }</span>

        <span class="cov8" title="1">return fvsToUse, odFvsToUse, nil</span>
}

func extractOdFvDependencies(
        odFv *model.OnDemandFeatureView,
        sourceFvs map[string]*model.FeatureView,
        requestedFeatures map[string]*FeatureViewAndRefs,
) error <span class="cov8" title="1">{

        for _, sourceFvProjection := range odFv.SourceFeatureViewProjections </span><span class="cov8" title="1">{
                fv := sourceFvs[sourceFvProjection.Name]
                base, err := fv.Base.WithProjection(sourceFvProjection)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">newFv := fv.NewFeatureViewFromBase(base)

                if _, ok := requestedFeatures[sourceFvProjection.NameToUse()]; !ok </span><span class="cov8" title="1">{
                        requestedFeatures[sourceFvProjection.NameToUse()] = &amp;FeatureViewAndRefs{
                                View:        newFv,
                                FeatureRefs: []string{},
                        }
                }</span>

                <span class="cov8" title="1">for _, feature := range sourceFvProjection.Features </span><span class="cov8" title="1">{
                        requestedFeatures[sourceFvProjection.NameToUse()].FeatureRefs = addStringIfNotContains(
                                requestedFeatures[sourceFvProjection.NameToUse()].FeatureRefs, feature.Name)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func addStringIfNotContains(slice []string, element string) []string <span class="cov8" title="1">{
        found := false
        for _, item := range slice </span><span class="cov8" title="1">{
                if element == item </span><span class="cov8" title="1">{
                        found = true
                }</span>
        }
        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                slice = append(slice, element)
        }</span>
        <span class="cov8" title="1">return slice</span>
}

func GetEntityMaps(requestedFeatureViews []*FeatureViewAndRefs, entities []*model.Entity) (map[string]string, map[string]interface{}, error) <span class="cov0" title="0">{
        entityNameToJoinKeyMap := make(map[string]string)
        expectedJoinKeysSet := make(map[string]interface{})

        entitiesByName := make(map[string]*model.Entity)

        for _, entity := range entities </span><span class="cov0" title="0">{
                entitiesByName[entity.Name] = entity
        }</span>

        <span class="cov0" title="0">for _, featuresAndView := range requestedFeatureViews </span><span class="cov0" title="0">{
                featureView := featuresAndView.View
                var joinKeyToAliasMap map[string]string
                if featureView.Base.Projection != nil &amp;&amp; featureView.Base.Projection.JoinKeyMap != nil </span><span class="cov0" title="0">{
                        joinKeyToAliasMap = featureView.Base.Projection.JoinKeyMap
                }</span> else<span class="cov0" title="0"> {
                        joinKeyToAliasMap = map[string]string{}
                }</span>

                <span class="cov0" title="0">for _, entityName := range featureView.EntityNames </span><span class="cov0" title="0">{
                        joinKey := entitiesByName[entityName].JoinKey
                        entityNameToJoinKeyMap[entityName] = joinKey

                        if alias, ok := joinKeyToAliasMap[joinKey]; ok </span><span class="cov0" title="0">{
                                expectedJoinKeysSet[alias] = nil
                        }</span> else<span class="cov0" title="0"> {
                                expectedJoinKeysSet[joinKey] = nil
                        }</span>
                }
        }
        <span class="cov0" title="0">return entityNameToJoinKeyMap, expectedJoinKeysSet, nil</span>
}

func ValidateEntityValues(joinKeyValues map[string]*prototypes.RepeatedValue,
        requestData map[string]*prototypes.RepeatedValue,
        expectedJoinKeysSet map[string]interface{}) (int, error) <span class="cov0" title="0">{
        numRows := -1

        for joinKey, values := range joinKeyValues </span><span class="cov0" title="0">{
                if _, ok := expectedJoinKeysSet[joinKey]; !ok </span><span class="cov0" title="0">{
                        requestData[joinKey] = values
                        delete(joinKeyValues, joinKey)
                        // ToDo: when request data will be passed correctly (not as part of entity rows)
                        // ToDo: throw this error instead
                        // return 0, fmt.Errorf("JoinKey is not expected in this request: %s\n%v", JoinKey, expectedJoinKeysSet)
                }</span> else<span class="cov0" title="0"> {
                        if numRows &lt; 0 </span><span class="cov0" title="0">{
                                numRows = len(values.Val)
                        }</span> else<span class="cov0" title="0"> if len(values.Val) != numRows </span><span class="cov0" title="0">{
                                return -1, errors.New("valueError: All entity rows must have the same columns")
                        }</span>

                }
        }

        <span class="cov0" title="0">return numRows, nil</span>
}

func ValidateFeatureRefs(requestedFeatures []*FeatureViewAndRefs, fullFeatureNames bool) error <span class="cov0" title="0">{
        featureRefCounter := make(map[string]int)
        featureRefs := make([]string, 0)
        for _, viewAndFeatures := range requestedFeatures </span><span class="cov0" title="0">{
                for _, feature := range viewAndFeatures.FeatureRefs </span><span class="cov0" title="0">{
                        projectedViewName := viewAndFeatures.View.Base.Name
                        if viewAndFeatures.View.Base.Projection != nil </span><span class="cov0" title="0">{
                                projectedViewName = viewAndFeatures.View.Base.Projection.NameToUse()
                        }</span>

                        <span class="cov0" title="0">featureRefs = append(featureRefs,
                                fmt.Sprintf("%s:%s", projectedViewName, feature))</span>
                }
        }

        <span class="cov0" title="0">for _, featureRef := range featureRefs </span><span class="cov0" title="0">{
                if fullFeatureNames </span><span class="cov0" title="0">{
                        featureRefCounter[featureRef]++
                }</span> else<span class="cov0" title="0"> {
                        _, featureName, _ := ParseFeatureReference(featureRef)
                        featureRefCounter[featureName]++
                }</span>

        }
        <span class="cov0" title="0">for featureName, occurrences := range featureRefCounter </span><span class="cov0" title="0">{
                if occurrences == 1 </span><span class="cov0" title="0">{
                        delete(featureRefCounter, featureName)
                }</span>
        }
        <span class="cov0" title="0">if len(featureRefCounter) &gt;= 1 </span><span class="cov0" title="0">{
                collidedFeatureRefs := make([]string, 0)
                for collidedFeatureRef := range featureRefCounter </span><span class="cov0" title="0">{
                        if fullFeatureNames </span><span class="cov0" title="0">{
                                collidedFeatureRefs = append(collidedFeatureRefs, collidedFeatureRef)
                        }</span> else<span class="cov0" title="0"> {
                                for _, featureRef := range featureRefs </span><span class="cov0" title="0">{
                                        _, featureName, _ := ParseFeatureReference(featureRef)
                                        if featureName == collidedFeatureRef </span><span class="cov0" title="0">{
                                                collidedFeatureRefs = append(collidedFeatureRefs, featureRef)
                                        }</span>
                                }
                        }
                }
                <span class="cov0" title="0">return featureNameCollisionError{collidedFeatureRefs, fullFeatureNames}</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func TransposeFeatureRowsIntoColumns(featureData2D [][]onlinestore.FeatureData,
        groupRef *GroupedFeaturesPerEntitySet,
        requestedFeatureViews []*FeatureViewAndRefs,
        arrowAllocator memory.Allocator,
        numRows int) ([]*FeatureVector, error) <span class="cov0" title="0">{

        numFeatures := len(groupRef.AliasedFeatureNames)
        fvs := make(map[string]*model.FeatureView)
        for _, viewAndRefs := range requestedFeatureViews </span><span class="cov0" title="0">{
                fvs[viewAndRefs.View.Base.Name] = viewAndRefs.View
        }</span>

        <span class="cov0" title="0">var value *prototypes.Value
        var status serving.FieldStatus
        var eventTimeStamp *timestamppb.Timestamp
        var featureData *onlinestore.FeatureData
        var fv *model.FeatureView
        var featureViewName string

        vectors := make([]*FeatureVector, 0)

        for featureIndex := 0; featureIndex &lt; numFeatures; featureIndex++ </span><span class="cov0" title="0">{
                currentVector := &amp;FeatureVector{
                        Name:       groupRef.AliasedFeatureNames[featureIndex],
                        Statuses:   make([]serving.FieldStatus, numRows),
                        Timestamps: make([]*timestamppb.Timestamp, numRows),
                }
                vectors = append(vectors, currentVector)
                protoValues := make([]*prototypes.Value, numRows)

                for rowEntityIndex, outputIndexes := range groupRef.Indices </span><span class="cov0" title="0">{
                        if featureData2D[rowEntityIndex] == nil </span><span class="cov0" title="0">{
                                value = nil
                                status = serving.FieldStatus_NOT_FOUND
                                eventTimeStamp = &amp;timestamppb.Timestamp{}
                        }</span> else<span class="cov0" title="0"> {
                                featureData = &amp;featureData2D[rowEntityIndex][featureIndex]
                                eventTimeStamp = &amp;timestamppb.Timestamp{Seconds: featureData.Timestamp.Seconds, Nanos: featureData.Timestamp.Nanos}
                                featureViewName = featureData.Reference.FeatureViewName
                                fv = fvs[featureViewName]
                                if _, ok := featureData.Value.Val.(*prototypes.Value_NullVal); ok </span><span class="cov0" title="0">{
                                        value = nil
                                        status = serving.FieldStatus_NOT_FOUND
                                }</span> else<span class="cov0" title="0"> if checkOutsideTtl(eventTimeStamp, timestamppb.Now(), fv.Ttl) </span><span class="cov0" title="0">{
                                        value = &amp;prototypes.Value{Val: featureData.Value.Val}
                                        status = serving.FieldStatus_OUTSIDE_MAX_AGE
                                }</span> else<span class="cov0" title="0"> {
                                        value = &amp;prototypes.Value{Val: featureData.Value.Val}
                                        status = serving.FieldStatus_PRESENT
                                }</span>
                        }
                        <span class="cov0" title="0">for _, rowIndex := range outputIndexes </span><span class="cov0" title="0">{
                                protoValues[rowIndex] = value
                                currentVector.Statuses[rowIndex] = status
                                currentVector.Timestamps[rowIndex] = eventTimeStamp
                        }</span>
                }
                <span class="cov0" title="0">arrowValues, err := types.ProtoValuesToArrowArray(protoValues, arrowAllocator, numRows)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">currentVector.Values = arrowValues</span>
        }

        <span class="cov0" title="0">return vectors, nil</span>

}

func KeepOnlyRequestedFeatures(
        vectors []*FeatureVector,
        requestedFeatureRefs []string,
        featureService *model.FeatureService,
        fullFeatureNames bool) ([]*FeatureVector, error) <span class="cov0" title="0">{
        vectorsByName := make(map[string]*FeatureVector)
        expectedVectors := make([]*FeatureVector, 0)

        usedVectors := make(map[string]bool)

        for _, vector := range vectors </span><span class="cov0" title="0">{
                vectorsByName[vector.Name] = vector
        }</span>

        <span class="cov0" title="0">if featureService != nil </span><span class="cov0" title="0">{
                for _, projection := range featureService.Projections </span><span class="cov0" title="0">{
                        for _, f := range projection.Features </span><span class="cov0" title="0">{
                                requestedFeatureRefs = append(requestedFeatureRefs,
                                        fmt.Sprintf("%s:%s", projection.NameToUse(), f.Name))
                        }</span>
                }
        }

        <span class="cov0" title="0">for _, featureRef := range requestedFeatureRefs </span><span class="cov0" title="0">{
                viewName, featureName, err := ParseFeatureReference(featureRef)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">qualifiedName := getQualifiedFeatureName(viewName, featureName, fullFeatureNames)
                if _, ok := vectorsByName[qualifiedName]; !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("requested feature %s can't be retrieved", featureRef)
                }</span>
                <span class="cov0" title="0">expectedVectors = append(expectedVectors, vectorsByName[qualifiedName])
                usedVectors[qualifiedName] = true</span>
        }

        // Free arrow arrays for vectors that were not used.
        <span class="cov0" title="0">for _, vector := range vectors </span><span class="cov0" title="0">{
                if _, ok := usedVectors[vector.Name]; !ok </span><span class="cov0" title="0">{
                        vector.Values.Release()
                }</span>
        }

        <span class="cov0" title="0">return expectedVectors, nil</span>
}

func EntitiesToFeatureVectors(entityColumns map[string]*prototypes.RepeatedValue, arrowAllocator memory.Allocator, numRows int) ([]*FeatureVector, error) <span class="cov0" title="0">{
        vectors := make([]*FeatureVector, 0)
        presentVector := make([]serving.FieldStatus, numRows)
        timestampVector := make([]*timestamppb.Timestamp, numRows)
        for idx := 0; idx &lt; numRows; idx++ </span><span class="cov0" title="0">{
                presentVector[idx] = serving.FieldStatus_PRESENT
                timestampVector[idx] = timestamppb.Now()
        }</span>
        <span class="cov0" title="0">for entityName, values := range entityColumns </span><span class="cov0" title="0">{
                arrowColumn, err := types.ProtoValuesToArrowArray(values.Val, arrowAllocator, numRows)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">vectors = append(vectors, &amp;FeatureVector{
                        Name:       entityName,
                        Values:     arrowColumn,
                        Statuses:   presentVector,
                        Timestamps: timestampVector,
                })</span>
        }
        <span class="cov0" title="0">return vectors, nil</span>
}

func ParseFeatureReference(featureRef string) (featureViewName, featureName string, e error) <span class="cov8" title="1">{
        parsedFeatureName := strings.Split(featureRef, ":")

        if len(parsedFeatureName) == 0 </span><span class="cov0" title="0">{
                e = errors.New("featureReference should be in the format: 'FeatureViewName:FeatureName'")
        }</span> else<span class="cov8" title="1"> if len(parsedFeatureName) == 1 </span><span class="cov0" title="0">{
                featureName = parsedFeatureName[0]
        }</span> else<span class="cov8" title="1"> {
                featureViewName = parsedFeatureName[0]
                featureName = parsedFeatureName[1]
        }</span>
        <span class="cov8" title="1">return</span>
}

func entityKeysToProtos(joinKeyValues map[string]*prototypes.RepeatedValue) []*prototypes.EntityKey <span class="cov8" title="1">{
        keys := make([]string, len(joinKeyValues))
        index := 0
        var numRows int
        for k, v := range joinKeyValues </span><span class="cov8" title="1">{
                keys[index] = k
                index += 1
                numRows = len(v.Val)
        }</span>
        <span class="cov8" title="1">sort.Strings(keys)
        entityKeys := make([]*prototypes.EntityKey, numRows)
        numJoinKeys := len(keys)
        // Construct each EntityKey object
        for index = 0; index &lt; numRows; index++ </span><span class="cov8" title="1">{
                entityKeys[index] = &amp;prototypes.EntityKey{JoinKeys: keys, EntityValues: make([]*prototypes.Value, numJoinKeys)}
        }</span>

        <span class="cov8" title="1">for colIndex, key := range keys </span><span class="cov8" title="1">{
                for index, value := range joinKeyValues[key].GetVal() </span><span class="cov8" title="1">{
                        entityKeys[index].EntityValues[colIndex] = value
                }</span>
        }
        <span class="cov8" title="1">return entityKeys</span>
}

func GroupFeatureRefs(requestedFeatureViews []*FeatureViewAndRefs,
        joinKeyValues map[string]*prototypes.RepeatedValue,
        entityNameToJoinKeyMap map[string]string,
        fullFeatureNames bool,
) (map[string]*GroupedFeaturesPerEntitySet,
        error,
) <span class="cov8" title="1">{
        groups := make(map[string]*GroupedFeaturesPerEntitySet)

        for _, featuresAndView := range requestedFeatureViews </span><span class="cov8" title="1">{
                joinKeys := make([]string, 0)
                fv := featuresAndView.View
                featureNames := featuresAndView.FeatureRefs
                for _, entityName := range fv.EntityNames </span><span class="cov8" title="1">{
                        joinKeys = append(joinKeys, entityNameToJoinKeyMap[entityName])
                }</span>

                <span class="cov8" title="1">groupKeyBuilder := make([]string, 0)
                joinKeysValuesProjection := make(map[string]*prototypes.RepeatedValue)

                joinKeyToAliasMap := make(map[string]string)
                if fv.Base.Projection != nil &amp;&amp; fv.Base.Projection.JoinKeyMap != nil </span><span class="cov8" title="1">{
                        joinKeyToAliasMap = fv.Base.Projection.JoinKeyMap
                }</span>

                <span class="cov8" title="1">for _, joinKey := range joinKeys </span><span class="cov8" title="1">{
                        var joinKeyOrAlias string

                        if alias, ok := joinKeyToAliasMap[joinKey]; ok </span><span class="cov8" title="1">{
                                groupKeyBuilder = append(groupKeyBuilder, fmt.Sprintf("%s[%s]", joinKey, alias))
                                joinKeyOrAlias = alias
                        }</span> else<span class="cov8" title="1"> {
                                groupKeyBuilder = append(groupKeyBuilder, joinKey)
                                joinKeyOrAlias = joinKey
                        }</span>

                        <span class="cov8" title="1">if _, ok := joinKeyValues[joinKeyOrAlias]; !ok </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("key %s is missing in provided entity rows", joinKey)
                        }</span>
                        <span class="cov8" title="1">joinKeysValuesProjection[joinKey] = joinKeyValues[joinKeyOrAlias]</span>
                }

                <span class="cov8" title="1">sort.Strings(groupKeyBuilder)
                groupKey := strings.Join(groupKeyBuilder, ",")

                aliasedFeatureNames := make([]string, 0)
                featureViewNames := make([]string, 0)
                var viewNameToUse string
                if fv.Base.Projection != nil </span><span class="cov8" title="1">{
                        viewNameToUse = fv.Base.Projection.NameToUse()
                }</span> else<span class="cov8" title="1"> {
                        viewNameToUse = fv.Base.Name
                }</span>

                <span class="cov8" title="1">for _, featureName := range featureNames </span><span class="cov8" title="1">{
                        aliasedFeatureNames = append(aliasedFeatureNames,
                                getQualifiedFeatureName(viewNameToUse, featureName, fullFeatureNames))
                        featureViewNames = append(featureViewNames, fv.Base.Name)
                }</span>

                <span class="cov8" title="1">if _, ok := groups[groupKey]; !ok </span><span class="cov8" title="1">{
                        joinKeysProto := entityKeysToProtos(joinKeysValuesProjection)
                        uniqueEntityRows, mappingIndices, err := getUniqueEntityRows(joinKeysProto)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov8" title="1">groups[groupKey] = &amp;GroupedFeaturesPerEntitySet{
                                FeatureNames:        featureNames,
                                FeatureViewNames:    featureViewNames,
                                AliasedFeatureNames: aliasedFeatureNames,
                                Indices:             mappingIndices,
                                EntityKeys:          uniqueEntityRows,
                        }</span>

                } else<span class="cov8" title="1"> {
                        groups[groupKey].FeatureNames = append(groups[groupKey].FeatureNames, featureNames...)
                        groups[groupKey].AliasedFeatureNames = append(groups[groupKey].AliasedFeatureNames, aliasedFeatureNames...)
                        groups[groupKey].FeatureViewNames = append(groups[groupKey].FeatureViewNames, featureViewNames...)
                }</span>
        }
        <span class="cov8" title="1">return groups, nil</span>
}

func getUniqueEntityRows(joinKeysProto []*prototypes.EntityKey) ([]*prototypes.EntityKey, [][]int, error) <span class="cov8" title="1">{
        uniqueValues := make(map[[sha256.Size]byte]*prototypes.EntityKey, 0)
        positions := make(map[[sha256.Size]byte][]int, 0)

        for index, entityKey := range joinKeysProto </span><span class="cov8" title="1">{
                serializedRow, err := proto.Marshal(entityKey)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>

                <span class="cov8" title="1">rowHash := sha256.Sum256(serializedRow)
                if _, ok := uniqueValues[rowHash]; !ok </span><span class="cov8" title="1">{
                        uniqueValues[rowHash] = entityKey
                        positions[rowHash] = []int{index}
                }</span> else<span class="cov8" title="1"> {
                        positions[rowHash] = append(positions[rowHash], index)
                }</span>
        }

        <span class="cov8" title="1">mappingIndices := make([][]int, len(uniqueValues))
        uniqueEntityRows := make([]*prototypes.EntityKey, 0)
        for rowHash, row := range uniqueValues </span><span class="cov8" title="1">{
                nextIdx := len(uniqueEntityRows)

                mappingIndices[nextIdx] = positions[rowHash]
                uniqueEntityRows = append(uniqueEntityRows, row)
        }</span>
        <span class="cov8" title="1">return uniqueEntityRows, mappingIndices, nil</span>
}

func checkOutsideTtl(featureTimestamp *timestamppb.Timestamp, currentTimestamp *timestamppb.Timestamp, ttl *durationpb.Duration) bool <span class="cov0" title="0">{
        if ttl.Seconds == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return currentTimestamp.GetSeconds()-featureTimestamp.GetSeconds() &gt; ttl.Seconds</span>
}

func getQualifiedFeatureName(viewName string, featureName string, fullFeatureNames bool) string <span class="cov8" title="1">{
        if fullFeatureNames </span><span class="cov8" title="1">{
                return fmt.Sprintf("%s__%s", viewName, featureName)
        }</span> else<span class="cov0" title="0"> {
                return featureName
        }</span>
}

type featureNameCollisionError struct {
        featureRefCollisions []string
        fullFeatureNames     bool
}

func (e featureNameCollisionError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("featureNameCollisionError: %s; %t", strings.Join(e.featureRefCollisions, ", "), e.fullFeatureNames)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package onlinestore

import (
        "context"
        "crypto/md5"
        "encoding/hex"
        "errors"
        "fmt"
        "math"
        "math/big"
        "os"
        "strings"
        "sync"
        "time"

        "github.com/feast-dev/feast/go/internal/feast/registry"
        "github.com/feast-dev/feast/go/internal/feast/utils"
        "github.com/feast-dev/feast/go/protos/feast/serving"
        "github.com/feast-dev/feast/go/protos/feast/types"
        "github.com/gocql/gocql"
        "github.com/rs/zerolog/log"
        "google.golang.org/protobuf/proto"

        "google.golang.org/protobuf/types/known/timestamppb"
        gocqltrace "gopkg.in/DataDog/dd-trace-go.v1/contrib/gocql/gocql"
)

type CassandraOnlineStore struct {
        project string

        // Cluster configurations for Cassandra/ScyllaDB
        clusterConfigs *gocql.ClusterConfig

        // Session object that holds information about the connection to the cluster
        session *gocql.Session

        config *registry.RepoConfig

        // The number of keys to include in a single CQL query for retrieval from the database
        keyBatchSize int

        // The version of the table name format
        tableNameFormatVersion int

        // Caches table names instead of generating the table name every time
        tableNameCache sync.Map
}

type CassandraConfig struct {
        hosts                   []string
        username                string
        password                string
        keyspace                string
        protocolVersion         int
        loadBalancingPolicy     gocql.HostSelectionPolicy
        connectionTimeoutMillis int64
        requestTimeoutMillis    int64
        keyBatchSize            int
}

const (
        V2_TABLE_NAME_FORMAT_MAX_LENGTH = 48
        BASE62_CHAR_SET                 = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
)

// toBase62 converts a big integer to a base62 string.
func toBase62(num *big.Int) string <span class="cov8" title="1">{
        if num.Sign() == 0 </span><span class="cov0" title="0">{
                return "0"
        }</span>

        <span class="cov8" title="1">base := big.NewInt(62)
        result := []string{}
        zero := big.NewInt(0)
        remainder := new(big.Int)

        for num.Cmp(zero) &gt; 0 </span><span class="cov8" title="1">{
                num.DivMod(num, base, remainder)
                result = append([]string{string(BASE62_CHAR_SET[remainder.Int64()])}, result...)
        }</span>

        <span class="cov8" title="1">return strings.Join(result, "")</span>
}

// base62Encode converts a byte slice to a Base62 string.
func base62Encode(data []byte) string <span class="cov8" title="1">{
        num := new(big.Int).SetBytes(data)
        return toBase62(num)
}</span>

func parseStringField(config map[string]any, fieldName string, defaultValue string) (string, error) <span class="cov8" title="1">{
        rawValue, ok := config[fieldName]
        if !ok </span><span class="cov8" title="1">{
                return defaultValue, nil
        }</span>
        <span class="cov8" title="1">stringValue, ok := rawValue.(string)
        if !ok </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to convert field %s to string: %v", fieldName, rawValue)
        }</span>
        <span class="cov8" title="1">return stringValue, nil</span>
}

func extractCassandraConfig(onlineStoreConfig map[string]any) (*CassandraConfig, error) <span class="cov8" title="1">{
        cassandraConfig := CassandraConfig{}

        // parse hosts
        cassandraHosts, ok := onlineStoreConfig["hosts"]
        if !ok </span><span class="cov8" title="1">{
                cassandraConfig.hosts = []string{"127.0.0.1"}
                log.Warn().Msg("host not provided: Using 127.0.0.1 instead")
        }</span> else<span class="cov8" title="1"> {
                var rawCassandraHosts []any
                if rawCassandraHosts, ok = cassandraHosts.([]any); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("didn't pass a list of hosts in the 'hosts' field")
                }</span>
                <span class="cov8" title="1">var cassandraHostsStr = make([]string, len(rawCassandraHosts))
                for i, rawHost := range rawCassandraHosts </span><span class="cov8" title="1">{
                        hostStr, ok := rawHost.(string)
                        if !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to convert a host to a string: %+v", rawHost)
                        }</span>
                        <span class="cov8" title="1">cassandraHostsStr[i] = hostStr</span>
                }
                <span class="cov8" title="1">cassandraConfig.hosts = cassandraHostsStr</span>
        }

        // parse username
        <span class="cov8" title="1">username, err := parseStringField(onlineStoreConfig, "username", "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">cassandraConfig.username = username

        // parse password
        password, err := parseStringField(onlineStoreConfig, "password", "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">cassandraConfig.password = password

        // parse keyspace
        keyspace, err := parseStringField(onlineStoreConfig, "keyspace", "feast_keyspace")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">cassandraConfig.keyspace = keyspace

        // parse protocolVersion
        protocolVersion, ok := onlineStoreConfig["protocol_version"]
        if !ok </span><span class="cov8" title="1">{
                protocolVersion = 4.0
                log.Warn().Msg("protocol_version not specified: Using 4 instead")
        }</span>
        <span class="cov8" title="1">cassandraConfig.protocolVersion = int(protocolVersion.(float64))

        // parse loadBalancing
        loadBalancingDict, ok := onlineStoreConfig["load_balancing"]
        if !ok </span><span class="cov8" title="1">{
                cassandraConfig.loadBalancingPolicy = gocql.RoundRobinHostPolicy()
                log.Warn().Msg("no load balancing policy selected, defaulted to RoundRobinHostPolicy")
        }</span> else<span class="cov8" title="1"> {
                loadBalancingProps := loadBalancingDict.(map[string]any)
                policy := loadBalancingProps["load_balancing_policy"].(string)
                switch policy </span>{
                case "TokenAwarePolicy(DCAwareRoundRobinPolicy)":<span class="cov0" title="0">
                        rawLocalDC, ok := loadBalancingProps["local_dc"]
                        if !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("a local_dc is needed for policy DCAwareRoundRobinPolicy")
                        }</span>
                        <span class="cov0" title="0">localDc := rawLocalDC.(string)
                        cassandraConfig.loadBalancingPolicy = gocql.TokenAwareHostPolicy(gocql.DCAwareRoundRobinPolicy(localDc))</span>
                case "DCAwareRoundRobinPolicy":<span class="cov8" title="1">
                        rawLocalDC, ok := loadBalancingProps["local_dc"]
                        if !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("a local_dc is needed for policy DCAwareRoundRobinPolicy")
                        }</span>
                        <span class="cov8" title="1">localDc := rawLocalDC.(string)
                        cassandraConfig.loadBalancingPolicy = gocql.DCAwareRoundRobinPolicy(localDc)</span>
                default:<span class="cov0" title="0">
                        log.Warn().Msg("defaulted to using RoundRobinHostPolicy")
                        cassandraConfig.loadBalancingPolicy = gocql.RoundRobinHostPolicy()</span>
                }
        }

        // parse connectionTimeoutMillis
        <span class="cov8" title="1">connectionTimeoutMillis, ok := onlineStoreConfig["connection_timeout_millis"]
        if !ok </span><span class="cov8" title="1">{
                connectionTimeoutMillis = 0.0
                log.Warn().Msg("connection_timeout_millis not specified, using gocql default")
        }</span>
        <span class="cov8" title="1">cassandraConfig.connectionTimeoutMillis = int64(connectionTimeoutMillis.(float64))

        // parse requestTimeoutMillis
        requestTimeoutMillis, ok := onlineStoreConfig["request_timeout_millis"]
        if !ok </span><span class="cov8" title="1">{
                requestTimeoutMillis = 0.0
                log.Warn().Msg("request_timeout_millis not specified, using gocql default")
        }</span>
        <span class="cov8" title="1">cassandraConfig.requestTimeoutMillis = int64(requestTimeoutMillis.(float64))

        keyBatchSize, ok := onlineStoreConfig["key_batch_size"]
        if !ok </span><span class="cov8" title="1">{
                keyBatchSize = 10.0
                log.Warn().Msg("key_batch_size not specified, defaulting to batches of size 10")
        }</span>
        <span class="cov8" title="1">cassandraConfig.keyBatchSize = int(keyBatchSize.(float64))

        return &amp;cassandraConfig, nil</span>
}

func NewCassandraOnlineStore(project string, config *registry.RepoConfig, onlineStoreConfig map[string]any) (*CassandraOnlineStore, error) <span class="cov0" title="0">{
        store := CassandraOnlineStore{
                project: project,
                config:  config,
        }

        cassandraConfig, configError := extractCassandraConfig(onlineStoreConfig)
        if configError != nil </span><span class="cov0" title="0">{
                return nil, configError
        }</span>

        <span class="cov0" title="0">store.clusterConfigs = gocql.NewCluster(cassandraConfig.hosts...)
        store.clusterConfigs.ProtoVersion = cassandraConfig.protocolVersion
        store.clusterConfigs.Keyspace = cassandraConfig.keyspace

        store.clusterConfigs.PoolConfig.HostSelectionPolicy = cassandraConfig.loadBalancingPolicy

        if cassandraConfig.username == "" || cassandraConfig.password == "" </span><span class="cov0" title="0">{
                log.Warn().Msg("username and/or password not defined, will not be using authentication")
        }</span> else<span class="cov0" title="0"> {
                store.clusterConfigs.Authenticator = gocql.PasswordAuthenticator{
                        Username: cassandraConfig.username,
                        Password: cassandraConfig.password,
                }
        }</span>

        <span class="cov0" title="0">if cassandraConfig.connectionTimeoutMillis != 0 </span><span class="cov0" title="0">{
                store.clusterConfigs.ConnectTimeout = time.Millisecond * time.Duration(cassandraConfig.connectionTimeoutMillis)
        }</span>
        <span class="cov0" title="0">if cassandraConfig.requestTimeoutMillis != 0 </span><span class="cov0" title="0">{
                store.clusterConfigs.Timeout = time.Millisecond * time.Duration(cassandraConfig.requestTimeoutMillis)
        }</span>

        <span class="cov0" title="0">store.clusterConfigs.RetryPolicy = &amp;gocql.SimpleRetryPolicy{NumRetries: 3}
        store.clusterConfigs.Consistency = gocql.LocalOne

        cassandraTraceServiceName := os.Getenv("DD_SERVICE") + "-cassandra"
        if cassandraTraceServiceName == "" </span><span class="cov0" title="0">{
                cassandraTraceServiceName = "cassandra.client" // default service name if DD_SERVICE is not set
        }</span>
        <span class="cov0" title="0">createdSession, err := gocqltrace.CreateTracedSession(store.clusterConfigs, gocqltrace.WithServiceName(cassandraTraceServiceName))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("unable to connect to the ScyllaDB database")
        }</span>
        <span class="cov0" title="0">store.session = createdSession

        if cassandraConfig.keyBatchSize &lt;= 0 || cassandraConfig.keyBatchSize &gt; 100 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("key_batch_size must be greater than zero and less than 100")
        }</span> else<span class="cov0" title="0"> if cassandraConfig.keyBatchSize == 1 </span><span class="cov0" title="0">{
                log.Info().Msg("key batching is disabled")
        }</span> else<span class="cov0" title="0"> {
                log.Info().Msgf("key batching is enabled with a batch size of %d", cassandraConfig.keyBatchSize)
        }</span>
        <span class="cov0" title="0">store.keyBatchSize = cassandraConfig.keyBatchSize

        // parse tableNameFormatVersion
        tableNameFormatVersion, ok := onlineStoreConfig["table_name_format_version"]
        if !ok </span><span class="cov0" title="0">{
                tableNameFormatVersion = 1
                log.Warn().Msg("table_name_format_version not specified: Using 1 instead")
        }</span>
        <span class="cov0" title="0">store.tableNameFormatVersion = int(tableNameFormatVersion.(float64))

        return &amp;store, nil</span>
}

// fqTableNameV2 generates a fully qualified table name with Base62 hashing.
func getFqTableNameV2(keyspace string, project string, featureViewName string) string <span class="cov8" title="1">{
        dbTableName := fmt.Sprintf("%s_%s", project, featureViewName)

        if len(dbTableName) &lt;= V2_TABLE_NAME_FORMAT_MAX_LENGTH </span><span class="cov8" title="1">{
                return dbTableName
        }</span>

        // Truncate project &amp; feature view name
        <span class="cov8" title="1">prjPrefixMaxLen := 5
        fvPrefixMaxLen := 5
        truncatedProject := project[:min(len(project), prjPrefixMaxLen)]
        truncatedFv := featureViewName[:min(len(featureViewName), fvPrefixMaxLen)]

        projectToHash := project[len(truncatedProject):]
        fvToHash := featureViewName[len(truncatedFv):]

        projectHashBytes := md5.Sum([]byte(projectToHash))
        fvHashBytes := md5.Sum([]byte(fvToHash))

        // Compute MD5 hash and encode to Base62
        projectHash := base62Encode(projectHashBytes[:])
        fvHash := base62Encode(fvHashBytes[:])

        // Format final table name (48 - 3 underscores - 5 prj prefix - 5 fv prefix) / 2 = ~17 each
        dbTableName = fmt.Sprintf("%s_%s_%s_%s",
                truncatedProject, projectHash[:17], truncatedFv, fvHash[:18])

        return dbTableName</span>
}

func (c *CassandraOnlineStore) getFqTableName(keySpace string, project string, featureViewName string, tableNameVersion int) (string, error) <span class="cov8" title="1">{
        var dbTableName string

        tableName := fmt.Sprintf("%s_%s", project, featureViewName)

        if cacheValue, found := c.tableNameCache.Load(tableName); found </span><span class="cov8" title="1">{
                return fmt.Sprintf(`"%s"."%s"`, keySpace, cacheValue.(string)), nil
        }</span>

        <span class="cov8" title="1">if tableNameVersion == 1 </span><span class="cov8" title="1">{
                dbTableName = tableName
        }</span> else<span class="cov8" title="1"> if tableNameVersion == 2 </span><span class="cov8" title="1">{
                dbTableName = getFqTableNameV2(keySpace, project, featureViewName)
        }</span> else<span class="cov8" title="1"> {
                return "", fmt.Errorf("unknown table name format version: %d", tableNameVersion)
        }</span>

        <span class="cov8" title="1">c.tableNameCache.Store(tableName, dbTableName)

        return fmt.Sprintf(`"%s"."%s"`, keySpace, dbTableName), nil</span>
}

func (c *CassandraOnlineStore) getSingleKeyCQLStatement(tableName string, featureNames []string) string <span class="cov8" title="1">{
        // this prevents fetching unnecessary features
        quotedFeatureNames := make([]string, len(featureNames))
        for i, featureName := range featureNames </span><span class="cov8" title="1">{
                quotedFeatureNames[i] = fmt.Sprintf(`'%s'`, featureName)
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf(
                `SELECT "entity_key", "feature_name", "event_ts", "value" FROM %s WHERE "entity_key" = ? AND "feature_name" IN (%s)`,
                tableName,
                strings.Join(quotedFeatureNames, ","),
        )</span>
}

func (c *CassandraOnlineStore) getMultiKeyCQLStatement(tableName string, featureNames []string, nkeys int) string <span class="cov8" title="1">{
        // this prevents fetching unnecessary features
        quotedFeatureNames := make([]string, len(featureNames))
        for i, featureName := range featureNames </span><span class="cov8" title="1">{
                quotedFeatureNames[i] = fmt.Sprintf(`'%s'`, featureName)
        }</span>

        <span class="cov8" title="1">keyPlaceholders := make([]string, nkeys)
        for i := 0; i &lt; nkeys; i++ </span><span class="cov8" title="1">{
                keyPlaceholders[i] = "?"
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf(
                `SELECT "entity_key", "feature_name", "event_ts", "value" FROM %s WHERE "entity_key" IN (%s) AND "feature_name" IN (%s)`,
                tableName,
                strings.Join(keyPlaceholders, ","),
                strings.Join(quotedFeatureNames, ","),
        )</span>
}

func (c *CassandraOnlineStore) buildCassandraEntityKeys(entityKeys []*types.EntityKey) ([]any, map[string]int, error) <span class="cov0" title="0">{
        cassandraKeys := make([]any, len(entityKeys))
        cassandraKeyToEntityIndex := make(map[string]int)
        for i := 0; i &lt; len(entityKeys); i++ </span><span class="cov0" title="0">{
                var key, err = utils.SerializeEntityKey(entityKeys[i], c.config.EntityKeySerializationVersion)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
                <span class="cov0" title="0">encodedKey := hex.EncodeToString(*key)
                cassandraKeys[i] = encodedKey
                cassandraKeyToEntityIndex[encodedKey] = i</span>
        }
        <span class="cov0" title="0">return cassandraKeys, cassandraKeyToEntityIndex, nil</span>
}

func (c *CassandraOnlineStore) UnbatchedKeysOnlineRead(ctx context.Context, entityKeys []*types.EntityKey, featureViewNames []string, featureNames []string) ([][]FeatureData, error) <span class="cov0" title="0">{
        uniqueNames := make(map[string]int32)
        for _, fvName := range featureViewNames </span><span class="cov0" title="0">{
                uniqueNames[fvName] = 0
        }</span>
        <span class="cov0" title="0">if len(uniqueNames) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("rejecting OnlineRead as more than 1 feature view was tried to be read at once")
        }</span>

        <span class="cov0" title="0">serializedEntityKeys, serializedEntityKeyToIndex, err := c.buildCassandraEntityKeys(entityKeys)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error when serializing entity keys for Cassandra")
        }</span>
        <span class="cov0" title="0">results := make([][]FeatureData, len(entityKeys))
        for i := range results </span><span class="cov0" title="0">{
                results[i] = make([]FeatureData, len(featureNames))
        }</span>

        <span class="cov0" title="0">featureNamesToIdx := make(map[string]int)
        for idx, name := range featureNames </span><span class="cov0" title="0">{
                featureNamesToIdx[name] = idx
        }</span>

        <span class="cov0" title="0">featureViewName := featureViewNames[0]

        // Prepare the query
        tableName, err := c.getFqTableName(c.clusterConfigs.Keyspace, c.project, featureViewName, c.tableNameFormatVersion)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">cqlStatement := c.getSingleKeyCQLStatement(tableName, featureNames)

        var waitGroup sync.WaitGroup
        waitGroup.Add(len(serializedEntityKeys))

        errorsChannel := make(chan error, len(serializedEntityKeys))
        for _, serializedEntityKey := range serializedEntityKeys </span><span class="cov0" title="0">{
                go func(serEntityKey any) </span><span class="cov0" title="0">{
                        defer waitGroup.Done()

                        iter := c.session.Query(cqlStatement, serEntityKey).WithContext(ctx).Iter()

                        rowIdx := serializedEntityKeyToIndex[serializedEntityKey.(string)]

                        // fill the row with nulls if not found
                        if iter.NumRows() == 0 </span><span class="cov0" title="0">{
                                for _, featName := range featureNames </span><span class="cov0" title="0">{
                                        results[rowIdx][featureNamesToIdx[featName]] = FeatureData{
                                                Reference: serving.FeatureReferenceV2{
                                                        FeatureViewName: featureViewName,
                                                        FeatureName:     featName,
                                                },
                                                Value: types.Value{
                                                        Val: &amp;types.Value_NullVal{
                                                                NullVal: types.Null_NULL,
                                                        },
                                                },
                                        }
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }

                        <span class="cov0" title="0">scanner := iter.Scanner()
                        var entityKey string
                        var featureName string
                        var eventTs time.Time
                        var valueStr []byte
                        var deserializedValue types.Value
                        rowFeatures := make(map[string]*FeatureData)
                        for scanner.Next() </span><span class="cov0" title="0">{
                                err := scanner.Scan(&amp;entityKey, &amp;featureName, &amp;eventTs, &amp;valueStr)
                                if err != nil </span><span class="cov0" title="0">{
                                        errorsChannel &lt;- errors.New("could not read row in query for (entity key, feature name, value, event ts)")
                                        return
                                }</span>
                                <span class="cov0" title="0">if err := proto.Unmarshal(valueStr, &amp;deserializedValue); err != nil </span><span class="cov0" title="0">{
                                        errorsChannel &lt;- errors.New("error converting parsed Cassandra Value to types.Value")
                                        return
                                }</span>

                                <span class="cov0" title="0">if deserializedValue.Val != nil </span><span class="cov0" title="0">{
                                        // Convert the value to a FeatureData struct
                                        rowFeatures[featureName] = &amp;FeatureData{
                                                Reference: serving.FeatureReferenceV2{
                                                        FeatureViewName: featureViewName,
                                                        FeatureName:     featureName,
                                                },
                                                Timestamp: timestamppb.Timestamp{Seconds: eventTs.Unix(), Nanos: int32(eventTs.Nanosecond())},
                                                Value: types.Value{
                                                        Val: deserializedValue.Val,
                                                },
                                        }
                                }</span>
                        }

                        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                                errorsChannel &lt;- errors.New("failed to scan features: " + err.Error())
                                return
                        }</span>

                        <span class="cov0" title="0">for _, featName := range featureNames </span><span class="cov0" title="0">{

                                if featureData, exists := rowFeatures[featName]; exists </span><span class="cov0" title="0">{
                                        results[rowIdx][featureNamesToIdx[featName]] = FeatureData{
                                                Reference: serving.FeatureReferenceV2{
                                                        FeatureViewName: featureData.Reference.FeatureViewName,
                                                        FeatureName:     featureData.Reference.FeatureName,
                                                },
                                                Timestamp: timestamppb.Timestamp{Seconds: featureData.Timestamp.Seconds, Nanos: featureData.Timestamp.Nanos},
                                                Value: types.Value{
                                                        Val: featureData.Value.Val,
                                                },
                                        }
                                }</span> else<span class="cov0" title="0"> {
                                        results[rowIdx][featureNamesToIdx[featName]] = FeatureData{
                                                Reference: serving.FeatureReferenceV2{
                                                        FeatureViewName: featureViewName,
                                                        FeatureName:     featName,
                                                },
                                                Value: types.Value{
                                                        Val: &amp;types.Value_NullVal{
                                                                NullVal: types.Null_NULL,
                                                        },
                                                },
                                        }
                                }</span>

                        }
                }(serializedEntityKey)
        }

        // wait until all concurrent single-key queries are done
        <span class="cov0" title="0">waitGroup.Wait()
        close(errorsChannel)

        var collectedErrors []error
        for err := range errorsChannel </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        collectedErrors = append(collectedErrors, err)
                }</span>
        }
        <span class="cov0" title="0">if len(collectedErrors) &gt; 0 </span><span class="cov0" title="0">{
                return nil, errors.Join(collectedErrors...)
        }</span>

        <span class="cov0" title="0">return results, nil</span>
}

func (c *CassandraOnlineStore) BatchedKeysOnlineRead(ctx context.Context, entityKeys []*types.EntityKey, featureViewNames []string, featureNames []string) ([][]FeatureData, error) <span class="cov8" title="1">{
        uniqueNames := make(map[string]int32)
        for _, fvName := range featureViewNames </span><span class="cov8" title="1">{
                uniqueNames[fvName] = 0
        }</span>
        <span class="cov8" title="1">if len(uniqueNames) != 1 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("rejecting OnlineRead as more than 1 feature view was tried to be read at once")
        }</span>
        <span class="cov0" title="0">serializedEntityKeys, serializedEntityKeyToIndex, err := c.buildCassandraEntityKeys(entityKeys)

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error when serializing entity keys for Cassandra")
        }</span>
        <span class="cov0" title="0">results := make([][]FeatureData, len(entityKeys))
        for i := range results </span><span class="cov0" title="0">{
                results[i] = make([]FeatureData, len(featureNames))
        }</span>

        <span class="cov0" title="0">featureNamesToIdx := make(map[string]int)
        for idx, name := range featureNames </span><span class="cov0" title="0">{
                featureNamesToIdx[name] = idx
        }</span>

        <span class="cov0" title="0">featureViewName := featureViewNames[0]

        // Prepare the query
        tableName, err := c.getFqTableName(c.clusterConfigs.Keyspace, c.project, featureViewName, c.tableNameFormatVersion)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Key batching
        <span class="cov0" title="0">nKeys := len(serializedEntityKeys)
        batchSize := c.keyBatchSize
        nBatches := int(math.Ceil(float64(nKeys) / float64(batchSize)))
        batches := make([][]any, nBatches)
        nAssigned := 0
        for i := 0; i &lt; nBatches; i++ </span><span class="cov0" title="0">{
                thisBatchSize := int(math.Min(float64(batchSize), float64(nKeys-nAssigned)))
                nAssigned += thisBatchSize
                batches[i] = make([]any, thisBatchSize)
                for j := 0; j &lt; thisBatchSize; j++ </span><span class="cov0" title="0">{
                        batches[i][j] = serializedEntityKeys[i*batchSize+j]
                }</span>
        }

        <span class="cov0" title="0">var waitGroup sync.WaitGroup
        waitGroup.Add(nBatches)

        errorsChannel := make(chan error, nBatches)
        var currentBatchLength int
        var prevBatchLength int
        var cqlStatement string
        for _, batch := range batches </span><span class="cov0" title="0">{
                currentBatchLength = len(batch)
                if currentBatchLength != prevBatchLength </span><span class="cov0" title="0">{
                        cqlStatement = c.getMultiKeyCQLStatement(tableName, featureNames, currentBatchLength)
                        prevBatchLength = currentBatchLength
                }</span>
                <span class="cov0" title="0">go func(keyBatch []any, statement string) </span><span class="cov0" title="0">{
                        defer waitGroup.Done()
                        iter := c.session.Query(statement, keyBatch...).WithContext(ctx).Iter()

                        scanner := iter.Scanner()
                        var entityKey string
                        var featureName string
                        var eventTs time.Time
                        var valueStr []byte
                        var deserializedValue types.Value
                        // key 1: entityKey - key 2: featureName
                        batchFeatures := make(map[string]map[string]*FeatureData)
                        for scanner.Next() </span><span class="cov0" title="0">{
                                err := scanner.Scan(&amp;entityKey, &amp;featureName, &amp;eventTs, &amp;valueStr)
                                if err != nil </span><span class="cov0" title="0">{
                                        errorsChannel &lt;- errors.New("could not read row in query for (entity key, feature name, value, event ts)")
                                        return
                                }</span>
                                <span class="cov0" title="0">if err := proto.Unmarshal(valueStr, &amp;deserializedValue); err != nil </span><span class="cov0" title="0">{
                                        errorsChannel &lt;- errors.New("error converting parsed Cassandra Value to types.Value")
                                        return
                                }</span>

                                <span class="cov0" title="0">if deserializedValue.Val != nil </span><span class="cov0" title="0">{
                                        if batchFeatures[entityKey] == nil </span><span class="cov0" title="0">{
                                                batchFeatures[entityKey] = make(map[string]*FeatureData)
                                        }</span>
                                        <span class="cov0" title="0">batchFeatures[entityKey][featureName] = &amp;FeatureData{
                                                Reference: serving.FeatureReferenceV2{
                                                        FeatureViewName: featureViewName,
                                                        FeatureName:     featureName,
                                                },
                                                Timestamp: timestamppb.Timestamp{Seconds: eventTs.Unix(), Nanos: int32(eventTs.Nanosecond())},
                                                Value: types.Value{
                                                        Val: deserializedValue.Val,
                                                },
                                        }</span>
                                }
                        }

                        <span class="cov0" title="0">if err := scanner.Err(); err != nil </span><span class="cov0" title="0">{
                                errorsChannel &lt;- errors.New("failed to scan features: " + err.Error())
                                return
                        }</span>

                        <span class="cov0" title="0">for _, serializedEntityKey := range keyBatch </span><span class="cov0" title="0">{
                                for _, featName := range featureNames </span><span class="cov0" title="0">{
                                        keyString := serializedEntityKey.(string)

                                        if featureData, exists := batchFeatures[keyString][featName]; exists </span><span class="cov0" title="0">{
                                                results[serializedEntityKeyToIndex[keyString]][featureNamesToIdx[featName]] = FeatureData{
                                                        Reference: serving.FeatureReferenceV2{
                                                                FeatureViewName: featureData.Reference.FeatureViewName,
                                                                FeatureName:     featureData.Reference.FeatureName,
                                                        },
                                                        Timestamp: timestamppb.Timestamp{Seconds: featureData.Timestamp.Seconds, Nanos: featureData.Timestamp.Nanos},
                                                        Value: types.Value{
                                                                Val: featureData.Value.Val,
                                                        },
                                                }
                                        }</span> else<span class="cov0" title="0"> {
                                                results[serializedEntityKeyToIndex[keyString]][featureNamesToIdx[featName]] = FeatureData{
                                                        Reference: serving.FeatureReferenceV2{
                                                                FeatureViewName: featureViewName,
                                                                FeatureName:     featName,
                                                        },
                                                        Value: types.Value{
                                                                Val: &amp;types.Value_NullVal{
                                                                        NullVal: types.Null_NULL,
                                                                },
                                                        },
                                                }
                                        }</span>
                                }
                        }
                }(batch, cqlStatement)
        }
        // wait until all concurrent single-key queries are done
        <span class="cov0" title="0">waitGroup.Wait()
        close(errorsChannel)

        var collectedErrors []error
        for err := range errorsChannel </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        collectedErrors = append(collectedErrors, err)
                }</span>
        }
        <span class="cov0" title="0">if len(collectedErrors) &gt; 0 </span><span class="cov0" title="0">{
                return nil, errors.Join(collectedErrors...)
        }</span>

        <span class="cov0" title="0">return results, nil</span>
}

func (c *CassandraOnlineStore) OnlineRead(ctx context.Context, entityKeys []*types.EntityKey, featureViewNames []string, featureNames []string) ([][]FeatureData, error) <span class="cov8" title="1">{
        if c.keyBatchSize == 1 </span><span class="cov0" title="0">{
                return c.UnbatchedKeysOnlineRead(ctx, entityKeys, featureViewNames, featureNames)
        }</span> else<span class="cov8" title="1"> {
                return c.BatchedKeysOnlineRead(ctx, entityKeys, featureViewNames, featureNames)
        }</span>
}

func (c *CassandraOnlineStore) Destruct() <span class="cov0" title="0">{
        c.session.Close()
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package onlinestore

import (
        "context"
        "fmt"

        "github.com/feast-dev/feast/go/internal/feast/registry"
        "github.com/feast-dev/feast/go/protos/feast/serving"
        "github.com/feast-dev/feast/go/protos/feast/types"
        "github.com/golang/protobuf/ptypes/timestamp"
)

type FeatureData struct {
        Reference serving.FeatureReferenceV2
        Timestamp timestamp.Timestamp
        Value     types.Value
}

type OnlineStore interface {
        // OnlineRead reads multiple features (specified in featureReferences) for multiple
        // entity keys (specified in entityKeys) and returns an array of array of features,
        // where each feature contains 3 fields:
        //   1. feature Reference
        //   2. feature event timestamp
        //   3. feature value
        // The inner array will have the same size as featureReferences,
        // while the outer array will have the same size as entityKeys.

        // TODO: Can we return [][]FeatureData, []timstamps, error
        // instead and remove timestamp from FeatureData struct to mimic Python's code
        // and reduces repeated memory storage for the same timstamp (which is stored as value and not as a pointer).
        // Should each attribute in FeatureData be stored as a pointer instead since the current
        // design forces value copied in OnlineRead + GetOnlineFeatures
        // (array is destructed so we cannot use the same fields in each
        // Feature object as pointers in GetOnlineFeaturesResponse)
        // =&gt; allocate memory for each field once in OnlineRead
        // and reuse them in GetOnlineFeaturesResponse?
        OnlineRead(ctx context.Context, entityKeys []*types.EntityKey, featureViewNames []string, featureNames []string) ([][]FeatureData, error)
        // Destruct must be call once user is done using OnlineStore
        // This is to comply with the Connector since we have to close the plugin
        Destruct()
}

func getOnlineStoreType(onlineStoreConfig map[string]interface{}) (string, bool) <span class="cov0" title="0">{
        if onlineStoreType, ok := onlineStoreConfig["type"]; !ok </span><span class="cov0" title="0">{
                // If online store type isn't specified, default to sqlite
                return "sqlite", true
        }</span> else<span class="cov0" title="0"> {
                result, ok := onlineStoreType.(string)
                return result, ok
        }</span>
}

func NewOnlineStore(config *registry.RepoConfig) (OnlineStore, error) <span class="cov0" title="0">{
        onlineStoreType, ok := getOnlineStoreType(config.OnlineStore)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not get online store type from online store config: %+v", config.OnlineStore)
        }</span> else<span class="cov0" title="0"> if onlineStoreType == "sqlite" </span><span class="cov0" title="0">{
                onlineStore, err := NewSqliteOnlineStore(config.Project, config, config.OnlineStore)
                return onlineStore, err
        }</span> else<span class="cov0" title="0"> if onlineStoreType == "redis" </span><span class="cov0" title="0">{
                onlineStore, err := NewRedisOnlineStore(config.Project, config, config.OnlineStore)
                return onlineStore, err
        }</span> else<span class="cov0" title="0"> if onlineStoreType == "cassandra" || onlineStoreType == "scylladb" </span><span class="cov0" title="0">{
                onlineStore, err := NewCassandraOnlineStore(config.Project, config, config.OnlineStore)
                return onlineStore, err
        }</span> else<span class="cov0" title="0"> {
                return nil, fmt.Errorf("%s online store type is currently not supported; only redis, scylladb, cassandra and sqlite are supported", onlineStoreType)
        }</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package onlinestore

import (
        "context"
        "crypto/tls"
        "encoding/binary"
        "errors"
        "fmt"
        "github.com/feast-dev/feast/go/internal/feast/utils"
        "os"
        "strconv"
        "strings"

        "github.com/feast-dev/feast/go/internal/feast/registry"
        "gopkg.in/DataDog/dd-trace-go.v1/ddtrace/tracer"

        redisprometheus "github.com/redis/go-redis/extra/redisprometheus/v9"
        redis "github.com/redis/go-redis/v9"
        "github.com/spaolacci/murmur3"
        "google.golang.org/protobuf/proto"
        "google.golang.org/protobuf/types/known/timestamppb"

        "github.com/feast-dev/feast/go/protos/feast/serving"
        "github.com/feast-dev/feast/go/protos/feast/types"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/rs/zerolog/log"
        redistrace "gopkg.in/DataDog/dd-trace-go.v1/contrib/redis/go-redis.v9"
)

type redisType int

const (
        redisNode    redisType = 0
        redisCluster redisType = 1
)

type RedisOnlineStore struct {

        // Feast project name
        // TODO (woop): Should we remove project as state that is tracked at the store level?
        project string

        // Redis database type, either a single node server (RedisType.Redis) or a cluster (RedisType.RedisCluster)
        t redisType

        // Redis client connector
        client *redis.Client

        // Redis cluster client connector
        clusterClient *redis.ClusterClient

        config *registry.RepoConfig
}

func NewRedisOnlineStore(project string, config *registry.RepoConfig, onlineStoreConfig map[string]interface{}) (*RedisOnlineStore, error) <span class="cov8" title="1">{
        store := RedisOnlineStore{
                project: project,
                config:  config,
        }

        var address []string
        var password string
        var tlsConfig *tls.Config
        var db int // Default to 0

        // Parse redis_type and write it into conf.redisStoreType
        redisStoreType, err := getRedisType(onlineStoreConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">store.t = redisStoreType

        // Parse connection_string and write it into conf.address, conf.password, and conf.ssl
        redisConnJson, ok := onlineStoreConfig["connection_string"]
        if !ok </span><span class="cov0" title="0">{
                // Default to "localhost:6379"
                redisConnJson = "localhost:6379"
        }</span>
        <span class="cov8" title="1">if redisConnStr, ok := redisConnJson.(string); !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to convert connection_string to string: %+v", redisConnJson)
        }</span> else<span class="cov8" title="1"> {
                parts := strings.Split(redisConnStr, ",")
                for _, part := range parts </span><span class="cov8" title="1">{
                        if strings.Contains(part, ":") </span><span class="cov8" title="1">{
                                address = append(address, part)
                        }</span> else<span class="cov8" title="1"> if strings.Contains(part, "=") </span><span class="cov8" title="1">{
                                kv := strings.SplitN(part, "=", 2)
                                if kv[0] == "password" </span><span class="cov8" title="1">{
                                        password = kv[1]
                                }</span> else<span class="cov8" title="1"> if kv[0] == "ssl" </span><span class="cov8" title="1">{
                                        result, err := strconv.ParseBool(kv[1])
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, err
                                        }</span> else<span class="cov8" title="1"> if result </span><span class="cov8" title="1">{
                                                tlsConfig = &amp;tls.Config{}
                                        }</span>
                                } else<span class="cov8" title="1"> if kv[0] == "db" </span><span class="cov8" title="1">{
                                        db, err = strconv.Atoi(kv[1])
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, err
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        return nil, fmt.Errorf("unrecognized option in connection_string: %s. Must be one of 'password', 'ssl'", kv[0])
                                }</span>
                        } else<span class="cov0" title="0"> {
                                return nil, fmt.Errorf("unable to parse a part of connection_string: %s. Must contain either ':' (addresses) or '=' (options", part)
                        }</span>
                }
        }

        // Metrics are not showing up when the service name is set to DD_SERVICE
        <span class="cov8" title="1">redisTraceServiceName := os.Getenv("DD_SERVICE") + "-redis"
        if redisTraceServiceName == "" </span><span class="cov0" title="0">{
                redisTraceServiceName = "redis.client" // default service name if DD_SERVICE is not set
        }</span>

        <span class="cov8" title="1">if redisStoreType == redisNode </span><span class="cov8" title="1">{
                log.Info().Msgf("Using Redis: %s", address[0])
                store.client = redis.NewClient(&amp;redis.Options{
                        Addr:      address[0],
                        Password:  password,
                        DB:        db,
                        TLSConfig: tlsConfig,
                })
                if strings.ToLower(os.Getenv("ENABLE_DATADOG_REDIS_TRACING")) == "true" </span><span class="cov0" title="0">{
                        redistrace.WrapClient(store.client, redistrace.WithServiceName(redisTraceServiceName))
                        collector := redisprometheus.NewCollector("mlpfs", "redis", store.client)
                        prometheus.MustRegister(collector)
                }</span>
        } else<span class="cov0" title="0"> if redisStoreType == redisCluster </span><span class="cov0" title="0">{
                log.Info().Msgf("Using Redis Cluster: %s", address)
                store.clusterClient = redis.NewClusterClient(&amp;redis.ClusterOptions{
                        Addrs:     address,
                        Password:  password,
                        TLSConfig: tlsConfig,
                        ReadOnly:  true,
                })
                if strings.ToLower(os.Getenv("ENABLE_DATADOG_REDIS_TRACING")) == "true" </span><span class="cov0" title="0">{
                        redistrace.WrapClient(store.clusterClient, redistrace.WithServiceName(redisTraceServiceName))
                        collector := redisprometheus.NewCollector("mlpfs", "redis", store.clusterClient)
                        prometheus.MustRegister(collector)
                }</span>
        }

        <span class="cov8" title="1">return &amp;store, nil</span>
}

func getRedisType(onlineStoreConfig map[string]interface{}) (redisType, error) <span class="cov8" title="1">{
        var t redisType

        redisTypeJson, ok := onlineStoreConfig["redis_type"]
        if !ok </span><span class="cov8" title="1">{
                // Default to "redis"
                redisTypeJson = "redis"
        }</span> else<span class="cov0" title="0"> if redisTypeStr, ok := redisTypeJson.(string); !ok </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("failed to convert redis_type to string: %+v", redisTypeJson)
        }</span> else<span class="cov0" title="0"> {
                if redisTypeStr == "redis" </span><span class="cov0" title="0">{
                        t = redisNode
                }</span> else<span class="cov0" title="0"> if redisTypeStr == "redis_cluster" </span><span class="cov0" title="0">{
                        t = redisCluster
                }</span> else<span class="cov0" title="0"> {
                        return -1, fmt.Errorf("failed to convert redis_type to enum: %s. Must be one of 'redis', 'redis_cluster'", redisTypeStr)
                }</span>
        }
        <span class="cov8" title="1">return t, nil</span>
}

func (r *RedisOnlineStore) buildFeatureViewIndices(featureViewNames []string, featureNames []string) (map[string]int, map[int]string, int) <span class="cov8" title="1">{
        featureViewIndices := make(map[string]int)
        indicesFeatureView := make(map[int]string)
        index := len(featureNames)
        for _, featureViewName := range featureViewNames </span><span class="cov8" title="1">{
                if _, ok := featureViewIndices[featureViewName]; !ok </span><span class="cov8" title="1">{
                        featureViewIndices[featureViewName] = index
                        indicesFeatureView[index] = featureViewName
                        index += 1
                }</span>
        }
        <span class="cov8" title="1">return featureViewIndices, indicesFeatureView, index</span>
}

func (r *RedisOnlineStore) buildHsetKeys(featureViewNames []string, featureNames []string, indicesFeatureView map[int]string, index int) ([]string, []string) <span class="cov8" title="1">{
        featureCount := len(featureNames)
        var hsetKeys = make([]string, index)
        h := murmur3.New32()
        intBuffer := h.Sum32()
        byteBuffer := make([]byte, 4)

        for i := 0; i &lt; featureCount; i++ </span><span class="cov8" title="1">{
                h.Write([]byte(fmt.Sprintf("%s:%s", featureViewNames[i], featureNames[i])))
                intBuffer = h.Sum32()
                binary.LittleEndian.PutUint32(byteBuffer, intBuffer)
                hsetKeys[i] = string(byteBuffer)
                h.Reset()
        }</span>
        <span class="cov8" title="1">for i := featureCount; i &lt; index; i++ </span><span class="cov8" title="1">{
                view := indicesFeatureView[i]
                tsKey := fmt.Sprintf("_ts:%s", view)
                hsetKeys[i] = tsKey
                featureNames = append(featureNames, tsKey)
        }</span>
        <span class="cov8" title="1">return hsetKeys, featureNames</span>
}

func (r *RedisOnlineStore) buildRedisKeys(entityKeys []*types.EntityKey) ([]*[]byte, map[string]int, error) <span class="cov8" title="1">{
        redisKeys := make([]*[]byte, len(entityKeys))
        redisKeyToEntityIndex := make(map[string]int)
        for i := 0; i &lt; len(entityKeys); i++ </span><span class="cov8" title="1">{
                var key, err = buildRedisKey(r.project, entityKeys[i], r.config.EntityKeySerializationVersion)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, nil, err
                }</span>
                <span class="cov8" title="1">redisKeys[i] = key
                redisKeyToEntityIndex[string(*key)] = i</span>
        }
        <span class="cov8" title="1">return redisKeys, redisKeyToEntityIndex, nil</span>
}

func (r *RedisOnlineStore) OnlineRead(ctx context.Context, entityKeys []*types.EntityKey, featureViewNames []string, featureNames []string) ([][]FeatureData, error) <span class="cov0" title="0">{
        span, _ := tracer.StartSpanFromContext(ctx, "redis.OnlineRead")
        defer span.Finish()

        featureCount := len(featureNames)
        featureViewIndices, indicesFeatureView, index := r.buildFeatureViewIndices(featureViewNames, featureNames)
        hsetKeys, featureNamesWithTimeStamps := r.buildHsetKeys(featureViewNames, featureNames, indicesFeatureView, index)
        redisKeys, redisKeyToEntityIndex, err := r.buildRedisKeys(entityKeys)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">results := make([][]FeatureData, len(entityKeys))
        commands := map[string]*redis.SliceCmd{}

        if r.t == redisNode </span><span class="cov0" title="0">{
                pipe := r.client.Pipeline()
                for _, redisKey := range redisKeys </span><span class="cov0" title="0">{
                        keyString := string(*redisKey)
                        commands[keyString] = pipe.HMGet(ctx, keyString, hsetKeys...)
                }</span>
                <span class="cov0" title="0">_, err = pipe.Exec(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        } else<span class="cov0" title="0"> if r.t == redisCluster </span><span class="cov0" title="0">{
                pipe := r.clusterClient.Pipeline()
                for _, redisKey := range redisKeys </span><span class="cov0" title="0">{
                        keyString := string(*redisKey)
                        commands[keyString] = pipe.HMGet(ctx, keyString, hsetKeys...)
                }</span>
                <span class="cov0" title="0">_, err = pipe.Exec(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">var entityIndex int
        var resContainsNonNil bool
        for redisKey, values := range commands </span><span class="cov0" title="0">{

                entityIndex = redisKeyToEntityIndex[redisKey]
                resContainsNonNil = false

                results[entityIndex] = make([]FeatureData, featureCount)
                res, err := values.Result()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">var timeStamp timestamppb.Timestamp

                for featureIndex, resString := range res </span><span class="cov0" title="0">{
                        if featureIndex == featureCount </span><span class="cov0" title="0">{
                                break</span>
                        }

                        <span class="cov0" title="0">if resString == nil </span><span class="cov0" title="0">{
                                // TODO (Ly): Can there be nil result within each feature or they will all be returned as string proto of types.Value_NullVal proto?
                                featureName := featureNamesWithTimeStamps[featureIndex]
                                featureViewName := featureViewNames[featureIndex]
                                timeStampIndex := featureViewIndices[featureViewName]
                                timeStampInterface := res[timeStampIndex]
                                if timeStampInterface != nil </span><span class="cov0" title="0">{
                                        if timeStampString, ok := timeStampInterface.(string); !ok </span><span class="cov0" title="0">{
                                                return nil, errors.New("error parsing value from redis")
                                        }</span> else<span class="cov0" title="0"> {
                                                if err := proto.Unmarshal([]byte(timeStampString), &amp;timeStamp); err != nil </span><span class="cov0" title="0">{
                                                        return nil, errors.New("error converting parsed redis value to timestamppb.Timestamp")
                                                }</span>
                                        }
                                }

                                <span class="cov0" title="0">results[entityIndex][featureIndex] = FeatureData{Reference: serving.FeatureReferenceV2{FeatureViewName: featureViewName, FeatureName: featureName},
                                        Timestamp: timestamppb.Timestamp{Seconds: timeStamp.Seconds, Nanos: timeStamp.Nanos},
                                        Value:     types.Value{Val: &amp;types.Value_NullVal{NullVal: types.Null_NULL}},
                                }</span>

                        } else<span class="cov0" title="0"> if valueString, ok := resString.(string); !ok </span><span class="cov0" title="0">{
                                return nil, errors.New("error parsing Value from redis")
                        }</span> else<span class="cov0" title="0"> {
                                resContainsNonNil = true
                                var value types.Value
                                if err := proto.Unmarshal([]byte(valueString), &amp;value); err != nil </span><span class="cov0" title="0">{
                                        return nil, errors.New("error converting parsed redis Value to types.Value")
                                }</span> else<span class="cov0" title="0"> {
                                        featureName := featureNamesWithTimeStamps[featureIndex]
                                        featureViewName := featureViewNames[featureIndex]
                                        timeStampIndex := featureViewIndices[featureViewName]
                                        timeStampInterface := res[timeStampIndex]
                                        if timeStampInterface != nil </span><span class="cov0" title="0">{
                                                if timeStampString, ok := timeStampInterface.(string); !ok </span><span class="cov0" title="0">{
                                                        return nil, errors.New("error parsing Value from redis")
                                                }</span> else<span class="cov0" title="0"> {
                                                        if err := proto.Unmarshal([]byte(timeStampString), &amp;timeStamp); err != nil </span><span class="cov0" title="0">{
                                                                return nil, errors.New("error converting parsed redis Value to timestamppb.Timestamp")
                                                        }</span>
                                                }
                                        }
                                        <span class="cov0" title="0">results[entityIndex][featureIndex] = FeatureData{Reference: serving.FeatureReferenceV2{FeatureViewName: featureViewName, FeatureName: featureName},
                                                Timestamp: timestamppb.Timestamp{Seconds: timeStamp.Seconds, Nanos: timeStamp.Nanos},
                                                Value:     types.Value{Val: value.Val},
                                        }</span>
                                }
                        }
                }

                <span class="cov0" title="0">if !resContainsNonNil </span><span class="cov0" title="0">{
                        results[entityIndex] = nil
                }</span>

        }

        <span class="cov0" title="0">return results, nil</span>
}

// Dummy destruct function to conform with plugin OnlineStore interface
func (r *RedisOnlineStore) Destruct() {<span class="cov0" title="0">

}</span>

func buildRedisKey(project string, entityKey *types.EntityKey, entityKeySerializationVersion int64) (*[]byte, error) <span class="cov8" title="1">{
        serKey, err := utils.SerializeEntityKey(entityKey, entityKeySerializationVersion)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">fullKey := append(*serKey, []byte(project)...)
        return &amp;fullKey, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package onlinestore

import (
        "database/sql"
        "errors"
        "github.com/feast-dev/feast/go/internal/feast/utils"
        "strings"
        "sync"
        "time"

        "github.com/feast-dev/feast/go/internal/feast/registry"

        "context"
        "fmt"

        _ "github.com/mattn/go-sqlite3"
        "google.golang.org/protobuf/proto"
        "google.golang.org/protobuf/types/known/timestamppb"

        "github.com/feast-dev/feast/go/protos/feast/serving"
        "github.com/feast-dev/feast/go/protos/feast/types"
)

type SqliteOnlineStore struct {
        // Feast project name
        project    string
        path       string
        db         *sql.DB
        db_mu      sync.Mutex
        repoConfig *registry.RepoConfig
}

// Creates a new sqlite online store object. onlineStoreConfig should have relative path of database file with respect to repoConfig.repoPath.
func NewSqliteOnlineStore(project string, repoConfig *registry.RepoConfig, onlineStoreConfig map[string]interface{}) (*SqliteOnlineStore, error) <span class="cov8" title="1">{
        store := SqliteOnlineStore{project: project, repoConfig: repoConfig}
        if db_path, ok := onlineStoreConfig["path"]; !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot find sqlite path %s", db_path)
        }</span> else<span class="cov8" title="1"> {
                if dbPathStr, ok := db_path.(string); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("cannot find convert sqlite path to string %s", db_path)
                }</span> else<span class="cov8" title="1"> {
                        store.path = fmt.Sprintf("%s/%s", repoConfig.RepoPath, dbPathStr)

                        db, err := initializeConnection(store.path)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">store.db = db</span>
                }
        }

        <span class="cov8" title="1">return &amp;store, nil</span>
}

func (s *SqliteOnlineStore) Destruct() <span class="cov8" title="1">{
        s.db.Close()
}</span>

// Returns FeatureData 2D array. Each row corresponds to one entity Value and each column corresponds to a single feature where the number of columns should be
// same length as the length of featureNames. Reads from every table in featureViewNames with the entity keys described.
func (s *SqliteOnlineStore) OnlineRead(ctx context.Context, entityKeys []*types.EntityKey, featureViewNames []string, featureNames []string) ([][]FeatureData, error) <span class="cov8" title="1">{
        featureCount := len(featureNames)
        _, err := s.getConnection()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">project := s.project
        results := make([][]FeatureData, len(entityKeys))
        entityNameToEntityIndex := make(map[string]int)
        in_query := make([]string, len(entityKeys))
        serialized_entities := make([]interface{}, len(entityKeys))
        for i := 0; i &lt; len(entityKeys); i++ </span><span class="cov8" title="1">{
                serKey, err := utils.SerializeEntityKey(entityKeys[i], s.repoConfig.EntityKeySerializationVersion)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                // TODO: fix this, string conversion is not safe
                <span class="cov8" title="1">entityNameToEntityIndex[utils.HashSerializedEntityKey(serKey)] = i
                // for IN clause in read query
                in_query[i] = "?"
                serialized_entities[i] = *serKey</span>
        }
        <span class="cov8" title="1">featureNamesToIdx := make(map[string]int)
        for idx, name := range featureNames </span><span class="cov8" title="1">{
                featureNamesToIdx[name] = idx
        }</span>

        <span class="cov8" title="1">for _, featureViewName := range featureViewNames </span><span class="cov8" title="1">{
                query_string := fmt.Sprintf(`SELECT entity_key, feature_name, Value, event_ts
                                                                        FROM %s
                                                                        WHERE entity_key IN (%s)
                                                                        ORDER BY entity_key`, tableId(project, featureViewName), strings.Join(in_query, ","))
                rows, err := s.db.Query(query_string, serialized_entities...)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">defer rows.Close()
                for rows.Next() </span><span class="cov8" title="1">{
                        var entity_key []byte
                        var feature_name string
                        var valueString []byte
                        var event_ts time.Time
                        var value types.Value
                        err = rows.Scan(&amp;entity_key, &amp;feature_name, &amp;valueString, &amp;event_ts)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errors.New("error could not resolve row in query (entity key, feature name, value, event ts)")
                        }</span>
                        <span class="cov8" title="1">if err := proto.Unmarshal(valueString, &amp;value); err != nil </span><span class="cov0" title="0">{
                                return nil, errors.New("error converting parsed value to types.Value")
                        }</span>
                        <span class="cov8" title="1">rowIdx := entityNameToEntityIndex[utils.HashSerializedEntityKey(&amp;entity_key)]
                        if results[rowIdx] == nil </span><span class="cov8" title="1">{
                                results[rowIdx] = make([]FeatureData, featureCount)
                        }</span>
                        <span class="cov8" title="1">results[rowIdx][featureNamesToIdx[feature_name]] = FeatureData{Reference: serving.FeatureReferenceV2{FeatureViewName: featureViewName, FeatureName: feature_name},
                                Timestamp: *timestamppb.New(event_ts),
                                Value:     types.Value{Val: value.Val},
                        }</span>
                }
        }
        <span class="cov8" title="1">return results, nil</span>
}

// Gets a sqlite connection and sets it to the online store and also returns a pointer to the connection.
func (s *SqliteOnlineStore) getConnection() (*sql.DB, error) <span class="cov8" title="1">{
        s.db_mu.Lock()
        defer s.db_mu.Unlock()
        if s.db == nil </span><span class="cov0" title="0">{
                if s.path == "" </span><span class="cov0" title="0">{
                        return nil, errors.New("no database path available")
                }</span>
                <span class="cov0" title="0">db, err := initializeConnection(s.path)
                s.db = db
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">return s.db, nil</span>
}

// Constructs the table id from the project and table(featureViewName) string.
func tableId(project string, featureViewName string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s_%s", project, featureViewName)
}</span>

// Creates a connection to the sqlite database and returns the connection.
func initializeConnection(db_path string) (*sql.DB, error) <span class="cov8" title="1">{
        db, err := sql.Open("sqlite3", db_path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return db, nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package registry

import (
        "crypto/tls"
        "fmt"
        "io"
        "net/http"
        "time"

        "github.com/feast-dev/feast/go/protos/feast/core"
        "github.com/rs/zerolog/log"
        "google.golang.org/protobuf/proto"
)

type HttpRegistryStore struct {
        project  string
        endpoint string
        clientId string
        client   http.Client
}

// NotImplementedError represents an error for a function that is not yet implemented.
type NotImplementedError struct {
        FunctionName string
}

// Error implements the error interface for NotImplementedError.
func (e *NotImplementedError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Function '%s' not implemented", e.FunctionName)
}</span>

func NewHttpRegistryStore(config *RegistryConfig, project string) (*HttpRegistryStore, error) <span class="cov0" title="0">{
        tr := &amp;http.Transport{
                TLSClientConfig: &amp;tls.Config{InsecureSkipVerify: true},
                IdleConnTimeout: 60 * time.Second,
        }
        log.Info().Msgf("Using Feature Registry: %s", config.Path)

        hrs := &amp;HttpRegistryStore{
                project:  project,
                endpoint: config.Path,
                clientId: config.ClientId,
                client: http.Client{
                        Transport: tr,
                        Timeout:   5 * time.Second,
                },
        }

        if err := hrs.TestConnectivity(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return hrs, nil</span>
}

func (hrs *HttpRegistryStore) TestConnectivity() error <span class="cov0" title="0">{
        resp, err := hrs.client.Get(hrs.endpoint)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf("HTTP Registry connectivity check failed with status code: %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *HttpRegistryStore) makeHttpRequest(url string) (*http.Response, error) <span class="cov8" title="1">{
        req, err := http.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">req.Header.Add("Accept", "application/x-protobuf")
        req.Header.Add("Client-Id", r.clientId)

        resp, err := r.client.Do(req)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("HTTP Error: %s", resp.Status)
        }</span>

        <span class="cov8" title="1">return resp, nil</span>
}

func (r *HttpRegistryStore) loadProtobufMessages(url string, messageProcessor func([]byte) error) error <span class="cov8" title="1">{
        resp, err := r.makeHttpRequest(url)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        buffer, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if err := messageProcessor(buffer); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *HttpRegistryStore) loadEntities(registry *core.Registry) error <span class="cov8" title="1">{
        url := fmt.Sprintf("%s/projects/%s/entities?allow_cache=true", r.endpoint, r.project)
        return r.loadProtobufMessages(url, func(data []byte) error </span><span class="cov8" title="1">{
                entity_list := &amp;core.EntityList{}
                if err := proto.Unmarshal(data, entity_list); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if len(entity_list.GetEntities()) == 0 </span><span class="cov0" title="0">{
                        log.Warn().Msg(fmt.Sprintf("Feature Registry has no associated Entities for project %s.", r.project))
                }</span>
                <span class="cov8" title="1">registry.Entities = append(registry.Entities, entity_list.GetEntities()...)
                return nil</span>
        })
}

func (r *HttpRegistryStore) loadDatasources(registry *core.Registry) error <span class="cov8" title="1">{
        url := fmt.Sprintf("%s/projects/%s/data_sources?allow_cache=true", r.endpoint, r.project)
        return r.loadProtobufMessages(url, func(data []byte) error </span><span class="cov8" title="1">{
                data_source_list := &amp;core.DataSourceList{}
                if err := proto.Unmarshal(data, data_source_list); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if len(data_source_list.GetDatasources()) == 0 </span><span class="cov0" title="0">{
                        log.Warn().Msg(fmt.Sprintf("Feature Registry has no associated Datasources for project %s.", r.project))
                }</span>
                <span class="cov8" title="1">registry.DataSources = append(registry.DataSources, data_source_list.GetDatasources()...)
                return nil</span>
        })
}

func (r *HttpRegistryStore) loadFeatureViews(registry *core.Registry) error <span class="cov8" title="1">{
        url := fmt.Sprintf("%s/projects/%s/feature_views?allow_cache=true", r.endpoint, r.project)
        return r.loadProtobufMessages(url, func(data []byte) error </span><span class="cov8" title="1">{
                feature_view_list := &amp;core.FeatureViewList{}
                if err := proto.Unmarshal(data, feature_view_list); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if len(feature_view_list.GetFeatureviews()) == 0 </span><span class="cov0" title="0">{
                        log.Warn().Msg(fmt.Sprintf("Feature Registry has no associated FeatureViews for project %s.", r.project))
                }</span>
                <span class="cov8" title="1">registry.FeatureViews = append(registry.FeatureViews, feature_view_list.GetFeatureviews()...)
                return nil</span>
        })
}

func (r *HttpRegistryStore) loadOnDemandFeatureViews(registry *core.Registry) error <span class="cov8" title="1">{
        url := fmt.Sprintf("%s/projects/%s/on_demand_feature_views?allow_cache=true", r.endpoint, r.project)
        return r.loadProtobufMessages(url, func(data []byte) error </span><span class="cov8" title="1">{
                od_feature_view_list := &amp;core.OnDemandFeatureViewList{}
                if err := proto.Unmarshal(data, od_feature_view_list); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">registry.OnDemandFeatureViews = append(registry.OnDemandFeatureViews, od_feature_view_list.GetOndemandfeatureviews()...)
                return nil</span>
        })
}

func (r *HttpRegistryStore) loadFeatureServices(registry *core.Registry) error <span class="cov8" title="1">{
        url := fmt.Sprintf("%s/projects/%s/feature_services?allow_cache=true", r.endpoint, r.project)
        return r.loadProtobufMessages(url, func(data []byte) error </span><span class="cov8" title="1">{
                feature_service_list := &amp;core.FeatureServiceList{}
                if err := proto.Unmarshal(data, feature_service_list); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">registry.FeatureServices = append(registry.FeatureServices, feature_service_list.GetFeatureservices()...)
                return nil</span>
        })
}

func (r *HttpRegistryStore) GetRegistryProto() (*core.Registry, error) <span class="cov8" title="1">{

        registry := core.Registry{}

        if err := r.loadEntities(&amp;registry); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := r.loadDatasources(&amp;registry); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := r.loadFeatureViews(&amp;registry); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := r.loadOnDemandFeatureViews(&amp;registry); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := r.loadFeatureServices(&amp;registry); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;registry, nil</span>
}

func (r *HttpRegistryStore) UpdateRegistryProto(rp *core.Registry) error <span class="cov8" title="1">{
        return &amp;NotImplementedError{FunctionName: "UpdateRegistryProto"}
}</span>

func (r *HttpRegistryStore) Teardown() error <span class="cov8" title="1">{
        return &amp;NotImplementedError{FunctionName: "Teardown"}
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package registry

import (
        "io/ioutil"
        "os"
        "path/filepath"

        "github.com/google/uuid"
        "google.golang.org/protobuf/proto"
        "google.golang.org/protobuf/types/known/timestamppb"

        "github.com/feast-dev/feast/go/protos/feast/core"
)

// A FileRegistryStore is a file-based implementation of the RegistryStore interface.
type FileRegistryStore struct {
        filePath string
}

// NewFileRegistryStore creates a FileRegistryStore with the given configuration and infers
// the file path from the repo path and registry path.
func NewFileRegistryStore(config *RegistryConfig, repoPath string) *FileRegistryStore <span class="cov0" title="0">{
        lr := FileRegistryStore{}
        registryPath := config.Path
        if filepath.IsAbs(registryPath) </span><span class="cov0" title="0">{
                lr.filePath = registryPath
        }</span> else<span class="cov0" title="0"> {
                lr.filePath = filepath.Join(repoPath, registryPath)
        }</span>
        <span class="cov0" title="0">return &amp;lr</span>
}

// GetRegistryProto reads and parses the registry proto from the file path.
func (r *FileRegistryStore) GetRegistryProto() (*core.Registry, error) <span class="cov0" title="0">{
        registry := &amp;core.Registry{}
        in, err := ioutil.ReadFile(r.filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := proto.Unmarshal(in, registry); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return registry, nil</span>
}

func (r *FileRegistryStore) UpdateRegistryProto(rp *core.Registry) error <span class="cov0" title="0">{
        return r.writeRegistry(rp)
}</span>

func (r *FileRegistryStore) Teardown() error <span class="cov0" title="0">{
        return os.Remove(r.filePath)
}</span>

func (r *FileRegistryStore) writeRegistry(rp *core.Registry) error <span class="cov0" title="0">{
        rp.VersionId = uuid.New().String()
        rp.LastUpdated = timestamppb.Now()
        bytes, err := proto.Marshal(rp)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = ioutil.WriteFile(r.filePath, bytes, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package registry

import (
        "errors"
        "fmt"
        "net/url"
        "sync"
        "time"

        "github.com/feast-dev/feast/go/internal/feast/model"
        "github.com/rs/zerolog/log"

        "github.com/feast-dev/feast/go/protos/feast/core"
)

var REGISTRY_SCHEMA_VERSION string = "1"
var REGISTRY_STORE_CLASS_FOR_SCHEME map[string]string = map[string]string{
        "gs":    "GCSRegistryStore",
        "s3":    "S3RegistryStore",
        "file":  "FileRegistryStore",
        "http":  "HttpRegistryStore",
        "https": "HttpRegistryStore",
        "":      "FileRegistryStore",
}

/*
        Store protos of FeatureView, FeatureService, Entity, OnDemandFeatureView
        but return to user copies of non-proto versions of these objects
*/

type Registry struct {
        project                        string
        registryStore                  RegistryStore
        cachedFeatureServices          map[string]map[string]*core.FeatureService
        cachedEntities                 map[string]map[string]*core.Entity
        cachedFeatureViews             map[string]map[string]*core.FeatureView
        cachedStreamFeatureViews       map[string]map[string]*core.StreamFeatureView
        cachedOnDemandFeatureViews     map[string]map[string]*core.OnDemandFeatureView
        cachedRegistry                 *core.Registry
        cachedRegistryProtoLastUpdated time.Time
        cachedRegistryProtoTtl         time.Duration
        mu                             sync.RWMutex
}

func NewRegistry(registryConfig *RegistryConfig, repoPath string, project string) (*Registry, error) <span class="cov0" title="0">{
        registryStoreType := registryConfig.RegistryStoreType
        registryPath := registryConfig.Path
        r := &amp;Registry{
                project:                project,
                cachedRegistryProtoTtl: time.Duration(registryConfig.CacheTtlSeconds) * time.Second,
        }

        if len(registryStoreType) == 0 </span><span class="cov0" title="0">{
                registryStore, err := getRegistryStoreFromScheme(registryPath, registryConfig, repoPath, project)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">r.registryStore = registryStore</span>
        } else<span class="cov0" title="0"> {
                registryStore, err := getRegistryStoreFromType(registryStoreType, registryConfig, repoPath, project)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">r.registryStore = registryStore</span>
        }

        <span class="cov0" title="0">return r, nil</span>
}

func (r *Registry) InitializeRegistry() error <span class="cov0" title="0">{
        _, err := r.getRegistryProto()
        if err != nil </span><span class="cov0" title="0">{
                if _, ok := r.registryStore.(*HttpRegistryStore); ok </span><span class="cov0" title="0">{
                        log.Error().Err(err).Msg("Registry Initialization Failed")
                        return err
                }</span>
                <span class="cov0" title="0">registryProto := &amp;core.Registry{RegistrySchemaVersion: REGISTRY_SCHEMA_VERSION}
                r.registryStore.UpdateRegistryProto(registryProto)</span>
        }
        <span class="cov0" title="0">go r.RefreshRegistryOnInterval()
        return nil</span>
}

func (r *Registry) RefreshRegistryOnInterval() <span class="cov0" title="0">{
        ticker := time.NewTicker(r.cachedRegistryProtoTtl)
        for ; true; &lt;-ticker.C </span><span class="cov0" title="0">{
                err := r.refresh()
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Stack().Err(err).Msg("Registry refresh Failed")
                }</span>
        }
}

func (r *Registry) refresh() error <span class="cov0" title="0">{
        _, err := r.getRegistryProto()
        return err
}</span>

func (r *Registry) getRegistryProto() (*core.Registry, error) <span class="cov0" title="0">{
        expired := r.cachedRegistry == nil || (r.cachedRegistryProtoTtl &gt; 0 &amp;&amp; time.Now().After(r.cachedRegistryProtoLastUpdated.Add(r.cachedRegistryProtoTtl)))
        if !expired </span><span class="cov0" title="0">{
                return r.cachedRegistry, nil
        }</span>
        <span class="cov0" title="0">registryProto, err := r.registryStore.GetRegistryProto()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">r.load(registryProto)
        return registryProto, nil</span>
}

func (r *Registry) load(registry *core.Registry) <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()
        r.cachedRegistry = registry
        r.cachedFeatureServices = make(map[string]map[string]*core.FeatureService)
        r.cachedEntities = make(map[string]map[string]*core.Entity)
        r.cachedFeatureViews = make(map[string]map[string]*core.FeatureView)
        r.cachedStreamFeatureViews = make(map[string]map[string]*core.StreamFeatureView)
        r.cachedOnDemandFeatureViews = make(map[string]map[string]*core.OnDemandFeatureView)
        r.loadEntities(registry)
        r.loadFeatureServices(registry)
        r.loadFeatureViews(registry)
        r.loadStreamFeatureViews(registry)
        r.loadOnDemandFeatureViews(registry)
        r.cachedRegistryProtoLastUpdated = time.Now()
}</span>

func (r *Registry) loadEntities(registry *core.Registry) <span class="cov0" title="0">{
        entities := registry.Entities
        for _, entity := range entities </span><span class="cov0" title="0">{
                if _, ok := r.cachedEntities[r.project]; !ok </span><span class="cov0" title="0">{
                        r.cachedEntities[r.project] = make(map[string]*core.Entity)
                }</span>
                <span class="cov0" title="0">r.cachedEntities[r.project][entity.Spec.Name] = entity</span>
        }
}

func (r *Registry) loadFeatureServices(registry *core.Registry) <span class="cov0" title="0">{
        featureServices := registry.FeatureServices
        for _, featureService := range featureServices </span><span class="cov0" title="0">{
                if _, ok := r.cachedFeatureServices[r.project]; !ok </span><span class="cov0" title="0">{
                        r.cachedFeatureServices[r.project] = make(map[string]*core.FeatureService)
                }</span>
                <span class="cov0" title="0">r.cachedFeatureServices[r.project][featureService.Spec.Name] = featureService</span>
        }
}

func (r *Registry) loadFeatureViews(registry *core.Registry) <span class="cov0" title="0">{
        featureViews := registry.FeatureViews
        for _, featureView := range featureViews </span><span class="cov0" title="0">{
                if _, ok := r.cachedFeatureViews[r.project]; !ok </span><span class="cov0" title="0">{
                        r.cachedFeatureViews[r.project] = make(map[string]*core.FeatureView)
                }</span>
                <span class="cov0" title="0">r.cachedFeatureViews[r.project][featureView.Spec.Name] = featureView</span>
        }
}

func (r *Registry) loadStreamFeatureViews(registry *core.Registry) <span class="cov0" title="0">{
        streamFeatureViews := registry.StreamFeatureViews
        for _, streamFeatureView := range streamFeatureViews </span><span class="cov0" title="0">{
                if _, ok := r.cachedStreamFeatureViews[r.project]; !ok </span><span class="cov0" title="0">{
                        r.cachedStreamFeatureViews[r.project] = make(map[string]*core.StreamFeatureView)
                }</span>
                <span class="cov0" title="0">r.cachedStreamFeatureViews[r.project][streamFeatureView.Spec.Name] = streamFeatureView</span>
        }
}

func (r *Registry) loadOnDemandFeatureViews(registry *core.Registry) <span class="cov0" title="0">{
        onDemandFeatureViews := registry.OnDemandFeatureViews
        for _, onDemandFeatureView := range onDemandFeatureViews </span><span class="cov0" title="0">{
                if _, ok := r.cachedOnDemandFeatureViews[r.project]; !ok </span><span class="cov0" title="0">{
                        r.cachedOnDemandFeatureViews[r.project] = make(map[string]*core.OnDemandFeatureView)
                }</span>
                <span class="cov0" title="0">r.cachedOnDemandFeatureViews[r.project][onDemandFeatureView.Spec.Name] = onDemandFeatureView</span>
        }
}

/*
        Look up Entities inside project
        Returns empty list if project not found
*/

func (r *Registry) ListEntities(project string) ([]*model.Entity, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        if cachedEntities, ok := r.cachedEntities[project]; !ok </span><span class="cov0" title="0">{
                return []*model.Entity{}, nil
        }</span> else<span class="cov0" title="0"> {
                entities := make([]*model.Entity, len(cachedEntities))
                index := 0
                for _, entityProto := range cachedEntities </span><span class="cov0" title="0">{
                        entities[index] = model.NewEntityFromProto(entityProto)
                        index += 1
                }</span>
                <span class="cov0" title="0">return entities, nil</span>
        }
}

/*
        Look up Feature Views inside project
        Returns empty list if project not found
*/

func (r *Registry) ListFeatureViews(project string) ([]*model.FeatureView, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        if cachedFeatureViews, ok := r.cachedFeatureViews[project]; !ok </span><span class="cov0" title="0">{
                return []*model.FeatureView{}, nil
        }</span> else<span class="cov0" title="0"> {
                featureViews := make([]*model.FeatureView, len(cachedFeatureViews))
                index := 0
                for _, featureViewProto := range cachedFeatureViews </span><span class="cov0" title="0">{
                        featureViews[index] = model.NewFeatureViewFromProto(featureViewProto)
                        index += 1
                }</span>
                <span class="cov0" title="0">return featureViews, nil</span>
        }
}

/*
        Look up Stream Feature Views inside project
        Returns empty list if project not found
*/

func (r *Registry) ListStreamFeatureViews(project string) ([]*model.FeatureView, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        if cachedStreamFeatureViews, ok := r.cachedStreamFeatureViews[project]; !ok </span><span class="cov0" title="0">{
                return []*model.FeatureView{}, nil
        }</span> else<span class="cov0" title="0"> {
                streamFeatureViews := make([]*model.FeatureView, len(cachedStreamFeatureViews))
                index := 0
                for _, streamFeatureViewProto := range cachedStreamFeatureViews </span><span class="cov0" title="0">{
                        streamFeatureViews[index] = model.NewFeatureViewFromStreamFeatureViewProto(streamFeatureViewProto)
                        index += 1
                }</span>
                <span class="cov0" title="0">return streamFeatureViews, nil</span>
        }
}

/*
        Look up Feature Services inside project
        Returns empty list if project not found
*/

func (r *Registry) ListFeatureServices(project string) ([]*model.FeatureService, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        if cachedFeatureServices, ok := r.cachedFeatureServices[project]; !ok </span><span class="cov0" title="0">{
                return []*model.FeatureService{}, nil
        }</span> else<span class="cov0" title="0"> {
                featureServices := make([]*model.FeatureService, len(cachedFeatureServices))
                index := 0
                for _, featureServiceProto := range cachedFeatureServices </span><span class="cov0" title="0">{
                        featureServices[index] = model.NewFeatureServiceFromProto(featureServiceProto)
                        index += 1
                }</span>
                <span class="cov0" title="0">return featureServices, nil</span>
        }
}

/*
        Look up On Demand Feature Views inside project
        Returns empty list if project not found
*/

func (r *Registry) ListOnDemandFeatureViews(project string) ([]*model.OnDemandFeatureView, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        if cachedOnDemandFeatureViews, ok := r.cachedOnDemandFeatureViews[project]; !ok </span><span class="cov0" title="0">{
                return []*model.OnDemandFeatureView{}, nil
        }</span> else<span class="cov0" title="0"> {
                onDemandFeatureViews := make([]*model.OnDemandFeatureView, len(cachedOnDemandFeatureViews))
                index := 0
                for _, onDemandFeatureViewProto := range cachedOnDemandFeatureViews </span><span class="cov0" title="0">{
                        onDemandFeatureViews[index] = model.NewOnDemandFeatureViewFromProto(onDemandFeatureViewProto)
                        index += 1
                }</span>
                <span class="cov0" title="0">return onDemandFeatureViews, nil</span>
        }
}

func (r *Registry) GetEntity(project, entityName string) (*model.Entity, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        if cachedEntities, ok := r.cachedEntities[project]; !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no cached entities found for project %s", project)
        }</span> else<span class="cov0" title="0"> {
                if entity, ok := cachedEntities[entityName]; !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("no cached entity %s found for project %s", entityName, project)
                }</span> else<span class="cov0" title="0"> {
                        return model.NewEntityFromProto(entity), nil
                }</span>
        }
}

func (r *Registry) GetFeatureView(project, featureViewName string) (*model.FeatureView, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        if cachedFeatureViews, ok := r.cachedFeatureViews[project]; !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no cached feature views found for project %s", project)
        }</span> else<span class="cov0" title="0"> {
                if featureViewProto, ok := cachedFeatureViews[featureViewName]; !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("no cached feature view %s found for project %s", featureViewName, project)
                }</span> else<span class="cov0" title="0"> {
                        return model.NewFeatureViewFromProto(featureViewProto), nil
                }</span>
        }
}

func (r *Registry) GetStreamFeatureView(project, streamFeatureViewName string) (*model.FeatureView, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        if cachedStreamFeatureViews, ok := r.cachedStreamFeatureViews[project]; !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no cached stream feature views found for project %s", project)
        }</span> else<span class="cov0" title="0"> {
                if streamFeatureViewProto, ok := cachedStreamFeatureViews[streamFeatureViewName]; !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("no cached stream feature view %s found for project %s", streamFeatureViewName, project)
                }</span> else<span class="cov0" title="0"> {
                        return model.NewFeatureViewFromStreamFeatureViewProto(streamFeatureViewProto), nil
                }</span>
        }
}

func (r *Registry) GetFeatureService(project, featureServiceName string) (*model.FeatureService, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        if cachedFeatureServices, ok := r.cachedFeatureServices[project]; !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no cached feature services found for project %s", project)
        }</span> else<span class="cov0" title="0"> {
                if featureServiceProto, ok := cachedFeatureServices[featureServiceName]; !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("no cached feature service %s found for project %s", featureServiceName, project)
                }</span> else<span class="cov0" title="0"> {
                        return model.NewFeatureServiceFromProto(featureServiceProto), nil
                }</span>
        }
}

func (r *Registry) GetOnDemandFeatureView(project, onDemandFeatureViewName string) (*model.OnDemandFeatureView, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        if cachedOnDemandFeatureViews, ok := r.cachedOnDemandFeatureViews[project]; !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no cached on demand feature views found for project %s", project)
        }</span> else<span class="cov0" title="0"> {
                if onDemandFeatureViewProto, ok := cachedOnDemandFeatureViews[onDemandFeatureViewName]; !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("no cached on demand feature view %s found for project %s", onDemandFeatureViewName, project)
                }</span> else<span class="cov0" title="0"> {
                        return model.NewOnDemandFeatureViewFromProto(onDemandFeatureViewProto), nil
                }</span>
        }
}

func getRegistryStoreFromScheme(registryPath string, registryConfig *RegistryConfig, repoPath string, project string) (RegistryStore, error) <span class="cov0" title="0">{
        uri, err := url.Parse(registryPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if registryStoreType, ok := REGISTRY_STORE_CLASS_FOR_SCHEME[uri.Scheme]; ok </span><span class="cov0" title="0">{
                return getRegistryStoreFromType(registryStoreType, registryConfig, repoPath, project)
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("registry path %s has unsupported scheme %s. Supported schemes are file, s3 and gs", registryPath, uri.Scheme)</span>
}

func getRegistryStoreFromType(registryStoreType string, registryConfig *RegistryConfig, repoPath string, project string) (RegistryStore, error) <span class="cov0" title="0">{
        switch registryStoreType </span>{
        case "FileRegistryStore":<span class="cov0" title="0">
                return NewFileRegistryStore(registryConfig, repoPath), nil</span>
        case "HttpRegistryStore":<span class="cov0" title="0">
                return NewHttpRegistryStore(registryConfig, project)</span>
        }
        <span class="cov0" title="0">return nil, errors.New("only FileRegistryStore or HttpRegistryStore as a RegistryStore is supported at this moment")</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package registry

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "time"

        "github.com/feast-dev/feast/go/internal/feast/server/logging"
        "github.com/ghodss/yaml"
)

const (
        defaultCacheTtlSeconds = int64(600)
        defaultClientID        = "Unknown"
)

type RepoConfig struct {
        // Feast project name
        Project string `json:"project"`
        // Feast provider name
        Provider string `json:"provider"`
        // Path to the registry. Custom registry loaders are not yet supported
        // Registry string `json:"registry"`
        Registry interface{} `json:"registry"`
        // Online store config
        OnlineStore map[string]interface{} `json:"online_store"`
        // Offline store config
        OfflineStore map[string]interface{} `json:"offline_store"`
        // Feature server config (currently unrelated to Go server)
        FeatureServer map[string]interface{} `json:"feature_server"`
        // Feature flags for experimental features
        Flags map[string]interface{} `json:"flags"`
        // RepoPath
        RepoPath string `json:"repo_path"`
        // EntityKeySerializationVersion
        EntityKeySerializationVersion int64 `json:"entity_key_serialization_version"`
}

type RegistryConfig struct {
        RegistryStoreType string `json:"registry_store_type"`
        Path              string `json:"path"`
        ClientId          string `json:"client_id" default:"Unknown"`
        CacheTtlSeconds   int64  `json:"cache_ttl_seconds" default:"600"`
}

// NewRepoConfigFromJSON converts a JSON string into a RepoConfig struct and also sets the repo path.
func NewRepoConfigFromJSON(repoPath, configJSON string) (*RepoConfig, error) <span class="cov8" title="1">{
        config := RepoConfig{}
        if err := json.Unmarshal([]byte(configJSON), &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">repoPath, err := filepath.Abs(repoPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">config.RepoPath = repoPath
        return &amp;config, nil</span>
}

// NewRepoConfigFromFile reads the `feature_store.yaml` file in the repo path and converts it
// into a RepoConfig struct.
func NewRepoConfigFromFile(repoPath string) (*RepoConfig, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(filepath.Join(repoPath, "feature_store.yaml"))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">repoPath, err = filepath.Abs(repoPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">repoConfigWithEnv := os.ExpandEnv(string(data))

        config := RepoConfig{}
        if err = yaml.Unmarshal([]byte(repoConfigWithEnv), &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">config.RepoPath = repoPath
        return &amp;config, nil</span>
}

func (r *RepoConfig) GetLoggingOptions() (*logging.LoggingOptions, error) <span class="cov8" title="1">{
        loggingOptions := logging.LoggingOptions{}
        if loggingOptionsMap, ok := r.FeatureServer["feature_logging"].(map[string]interface{}); ok </span><span class="cov8" title="1">{
                loggingOptions = logging.DefaultOptions
                for k, v := range loggingOptionsMap </span><span class="cov8" title="1">{
                        switch k </span>{
                        case "queue_capacity":<span class="cov8" title="1">
                                if value, ok := v.(int); ok </span><span class="cov8" title="1">{
                                        loggingOptions.ChannelCapacity = value
                                }</span>
                        case "emit_timeout_micro_secs":<span class="cov8" title="1">
                                if value, ok := v.(int); ok </span><span class="cov8" title="1">{
                                        loggingOptions.EmitTimeout = time.Duration(value) * time.Microsecond
                                }</span>
                        case "write_to_disk_interval_secs":<span class="cov8" title="1">
                                if value, ok := v.(int); ok </span><span class="cov8" title="1">{
                                        loggingOptions.WriteInterval = time.Duration(value) * time.Second
                                }</span>
                        case "flush_interval_secs":<span class="cov8" title="1">
                                if value, ok := v.(int); ok </span><span class="cov8" title="1">{
                                        loggingOptions.FlushInterval = time.Duration(value) * time.Second
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return &amp;loggingOptions, nil</span>
}

func (r *RepoConfig) GetRegistryConfig() (*RegistryConfig, error) <span class="cov8" title="1">{
        if registryConfigMap, ok := r.Registry.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                registryConfig := RegistryConfig{CacheTtlSeconds: defaultCacheTtlSeconds, ClientId: defaultClientID}
                for k, v := range registryConfigMap </span><span class="cov8" title="1">{
                        switch k </span>{
                        case "path":<span class="cov8" title="1">
                                if value, ok := v.(string); ok </span><span class="cov8" title="1">{
                                        registryConfig.Path = value
                                }</span>
                        case "registry_store_type":<span class="cov8" title="1">
                                if value, ok := v.(string); ok </span><span class="cov8" title="1">{
                                        registryConfig.RegistryStoreType = value
                                }</span>
                        case "client_id":<span class="cov8" title="1">
                                if value, ok := v.(string); ok </span><span class="cov8" title="1">{
                                        registryConfig.ClientId = value
                                }</span>
                        case "cache_ttl_seconds":<span class="cov8" title="1">
                                // cache_ttl_seconds defaulted to type float64. Ex: "cache_ttl_seconds": 60 in registryConfigMap
                                switch value := v.(type) </span>{
                                case float64:<span class="cov8" title="1">
                                        registryConfig.CacheTtlSeconds = int64(value)</span>
                                case int:<span class="cov8" title="1">
                                        registryConfig.CacheTtlSeconds = int64(value)</span>
                                case int32:<span class="cov8" title="1">
                                        registryConfig.CacheTtlSeconds = int64(value)</span>
                                case int64:<span class="cov8" title="1">
                                        registryConfig.CacheTtlSeconds = value</span>
                                default:<span class="cov0" title="0">
                                        return nil, fmt.Errorf("unexpected type %T for CacheTtlSeconds", v)</span>
                                }
                        }
                }
                <span class="cov8" title="1">return &amp;registryConfig, nil</span>
        } else<span class="cov8" title="1"> {
                return &amp;RegistryConfig{Path: r.Registry.(string), ClientId: defaultClientID, CacheTtlSeconds: defaultCacheTtlSeconds}, nil
        }</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package server

import (
        "context"
        "fmt"
        "github.com/feast-dev/feast/go/internal/feast"
        "github.com/feast-dev/feast/go/internal/feast/server/logging"
        "github.com/feast-dev/feast/go/protos/feast/serving"
        prototypes "github.com/feast-dev/feast/go/protos/feast/types"
        "github.com/feast-dev/feast/go/types"
        "github.com/google/uuid"
        "gopkg.in/DataDog/dd-trace-go.v1/ddtrace/tracer"
)

const feastServerVersion = "0.0.1"

type grpcServingServiceServer struct {
        fs             *feast.FeatureStore
        loggingService *logging.LoggingService
        serving.UnimplementedServingServiceServer
}

func NewGrpcServingServiceServer(fs *feast.FeatureStore, loggingService *logging.LoggingService) *grpcServingServiceServer <span class="cov8" title="1">{
        return &amp;grpcServingServiceServer{fs: fs, loggingService: loggingService}
}</span>

func (s *grpcServingServiceServer) GetFeastServingInfo(ctx context.Context, request *serving.GetFeastServingInfoRequest) (*serving.GetFeastServingInfoResponse, error) <span class="cov8" title="1">{
        return &amp;serving.GetFeastServingInfoResponse{
                Version: feastServerVersion,
        }, nil
}</span>

// GetOnlineFeatures Returns an object containing the response to GetOnlineFeatures.
// Metadata contains feature names that corresponds to the number of rows in response.Results.
// Results contains values including the value of the feature, the event timestamp, and feature status in a columnar format.
func (s *grpcServingServiceServer) GetOnlineFeatures(ctx context.Context, request *serving.GetOnlineFeaturesRequest) (*serving.GetOnlineFeaturesResponse, error) <span class="cov8" title="1">{

        span, ctx := tracer.StartSpanFromContext(ctx, "getOnlineFeatures", tracer.ResourceName("ServingService/GetOnlineFeatures"))
        defer span.Finish()

        logSpanContext := LogWithSpanContext(span)

        requestId := GenerateRequestId()
        featuresOrService, err := s.fs.ParseFeatures(request.GetKind())

        if err != nil </span><span class="cov0" title="0">{
                logSpanContext.Error().Err(err).Msg("Error parsing feature service or feature list from request")
                return nil, err
        }</span>

        <span class="cov8" title="1">featureVectors, err := s.fs.GetOnlineFeatures(
                ctx,
                featuresOrService.FeaturesRefs,
                featuresOrService.FeatureService,
                request.GetEntities(),
                request.GetRequestContext(),
                request.GetFullFeatureNames())

        if err != nil </span><span class="cov0" title="0">{
                logSpanContext.Error().Err(err).Msg("Error getting online features")
                return nil, err
        }</span>

        <span class="cov8" title="1">resp := &amp;serving.GetOnlineFeaturesResponse{
                Results: make([]*serving.GetOnlineFeaturesResponse_FeatureVector, 0),
                Metadata: &amp;serving.GetOnlineFeaturesResponseMetadata{
                        FeatureNames: &amp;serving.FeatureList{Val: make([]string, 0)},
                },
        }
        // JoinKeys are currently part of the features as a value and the order that we add it to the resp MetaData
        // Need to figure out a way to map the correct entities to the correct ordering
        entityValuesMap := make(map[string][]*prototypes.Value, 0)
        featureNames := make([]string, len(featureVectors))
        for idx, vector := range featureVectors </span><span class="cov8" title="1">{
                resp.Metadata.FeatureNames.Val = append(resp.Metadata.FeatureNames.Val, vector.Name)
                featureNames[idx] = vector.Name
                values, err := types.ArrowValuesToProtoValues(vector.Values)
                if err != nil </span><span class="cov0" title="0">{
                        logSpanContext.Error().Err(err).Msg("Error converting Arrow values to proto values")
                        return nil, err
                }</span>
                <span class="cov8" title="1">if _, ok := request.Entities[vector.Name]; ok </span><span class="cov8" title="1">{
                        entityValuesMap[vector.Name] = values
                }</span>

                <span class="cov8" title="1">resp.Results = append(resp.Results, &amp;serving.GetOnlineFeaturesResponse_FeatureVector{
                        Values:          values,
                        Statuses:        vector.Statuses,
                        EventTimestamps: vector.Timestamps,
                })</span>
        }

        <span class="cov8" title="1">featureService := featuresOrService.FeatureService
        if featureService != nil &amp;&amp; featureService.LoggingConfig != nil &amp;&amp; s.loggingService != nil </span><span class="cov8" title="1">{
                logger, err := s.loggingService.GetOrCreateLogger(featureService)
                if err != nil </span><span class="cov0" title="0">{
                        logSpanContext.Error().Err(err).Msg("Error to instantiating logger for feature service: " + featuresOrService.FeatureService.Name)
                        fmt.Printf("Couldn't instantiate logger for feature service %s: %+v", featuresOrService.FeatureService.Name, err)
                }</span>

                <span class="cov8" title="1">err = logger.Log(request.Entities, resp.Results[len(request.Entities):], resp.Metadata.FeatureNames.Val[len(request.Entities):], request.RequestContext, requestId)
                if err != nil </span><span class="cov0" title="0">{
                        logSpanContext.Error().Err(err).Msg("Error to logging to feature service: " + featuresOrService.FeatureService.Name)
                        fmt.Printf("LoggerImpl error[%s]: %+v", featuresOrService.FeatureService.Name, err)
                }</span>
        }
        <span class="cov8" title="1">return resp, nil</span>
}

func GenerateRequestId() string <span class="cov8" title="1">{
        id := uuid.New()
        return id.String()
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package server

import (
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "os"
        "runtime"
        "strconv"
        "strings"
        "time"

        "github.com/feast-dev/feast/go/internal/feast"
        "github.com/feast-dev/feast/go/internal/feast/model"
        "github.com/feast-dev/feast/go/internal/feast/onlineserving"
        "github.com/feast-dev/feast/go/internal/feast/server/logging"
        "github.com/feast-dev/feast/go/protos/feast/serving"
        prototypes "github.com/feast-dev/feast/go/protos/feast/types"
        "github.com/feast-dev/feast/go/types"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        "github.com/rs/zerolog/log"
        httptrace "gopkg.in/DataDog/dd-trace-go.v1/contrib/net/http"
        "gopkg.in/DataDog/dd-trace-go.v1/ddtrace/tracer"
)

type httpServer struct {
        fs             *feast.FeatureStore
        loggingService *logging.LoggingService
        server         *http.Server
}

// Some Feast types aren't supported during JSON conversion
type repeatedValue struct {
        stringVal     []string
        int64Val      []int64
        doubleVal     []float64
        boolVal       []bool
        stringListVal [][]string
        int64ListVal  [][]int64
        doubleListVal [][]float64
        boolListVal   [][]bool
}

func (u *repeatedValue) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        isString := false
        isDouble := false
        isInt64 := false
        isArray := false
        openBraketCounter := 0
        for _, b := range data </span><span class="cov8" title="1">{
                if b == '"' </span><span class="cov8" title="1">{
                        isString = true
                }</span>
                <span class="cov8" title="1">if b == '.' </span><span class="cov8" title="1">{
                        isDouble = true
                }</span>
                <span class="cov8" title="1">if b &gt;= '0' &amp;&amp; b &lt;= '9' </span><span class="cov8" title="1">{
                        isInt64 = true
                }</span>
                <span class="cov8" title="1">if b == '[' </span><span class="cov8" title="1">{
                        openBraketCounter++
                        if openBraketCounter &gt; 1 </span><span class="cov8" title="1">{
                                isArray = true
                        }</span>
                }
        }
        <span class="cov8" title="1">var err error
        if !isArray </span><span class="cov8" title="1">{
                if isString </span><span class="cov8" title="1">{
                        err = json.Unmarshal(data, &amp;u.stringVal)
                }</span> else<span class="cov8" title="1"> if isDouble </span><span class="cov8" title="1">{
                        err = json.Unmarshal(data, &amp;u.doubleVal)
                }</span> else<span class="cov8" title="1"> if isInt64 </span><span class="cov8" title="1">{
                        err = json.Unmarshal(data, &amp;u.int64Val)
                }</span> else<span class="cov8" title="1"> {
                        err = json.Unmarshal(data, &amp;u.boolVal)
                }</span>
        } else<span class="cov8" title="1"> {
                if isString </span><span class="cov8" title="1">{
                        err = json.Unmarshal(data, &amp;u.stringListVal)
                }</span> else<span class="cov8" title="1"> if isDouble </span><span class="cov8" title="1">{
                        err = json.Unmarshal(data, &amp;u.doubleListVal)
                }</span> else<span class="cov8" title="1"> if isInt64 </span><span class="cov8" title="1">{
                        err = json.Unmarshal(data, &amp;u.int64ListVal)
                }</span> else<span class="cov8" title="1"> {
                        err = json.Unmarshal(data, &amp;u.boolListVal)
                }</span>
        }
        <span class="cov8" title="1">return err</span>
}

func (u *repeatedValue) ToProto() *prototypes.RepeatedValue <span class="cov0" title="0">{
        proto := new(prototypes.RepeatedValue)
        if u.stringVal != nil </span><span class="cov0" title="0">{
                for _, val := range u.stringVal </span><span class="cov0" title="0">{
                        proto.Val = append(proto.Val, &amp;prototypes.Value{Val: &amp;prototypes.Value_StringVal{StringVal: val}})
                }</span>
        }
        <span class="cov0" title="0">if u.int64Val != nil </span><span class="cov0" title="0">{
                for _, val := range u.int64Val </span><span class="cov0" title="0">{
                        proto.Val = append(proto.Val, &amp;prototypes.Value{Val: &amp;prototypes.Value_Int64Val{Int64Val: val}})
                }</span>
        }
        <span class="cov0" title="0">if u.doubleVal != nil </span><span class="cov0" title="0">{
                for _, val := range u.doubleVal </span><span class="cov0" title="0">{
                        proto.Val = append(proto.Val, &amp;prototypes.Value{Val: &amp;prototypes.Value_DoubleVal{DoubleVal: val}})
                }</span>
        }
        <span class="cov0" title="0">if u.boolVal != nil </span><span class="cov0" title="0">{
                for _, val := range u.boolVal </span><span class="cov0" title="0">{
                        proto.Val = append(proto.Val, &amp;prototypes.Value{Val: &amp;prototypes.Value_BoolVal{BoolVal: val}})
                }</span>
        }
        <span class="cov0" title="0">if u.stringListVal != nil </span><span class="cov0" title="0">{
                for _, val := range u.stringListVal </span><span class="cov0" title="0">{
                        proto.Val = append(proto.Val, &amp;prototypes.Value{Val: &amp;prototypes.Value_StringListVal{StringListVal: &amp;prototypes.StringList{Val: val}}})
                }</span>
        }
        <span class="cov0" title="0">if u.int64ListVal != nil </span><span class="cov0" title="0">{
                for _, val := range u.int64ListVal </span><span class="cov0" title="0">{
                        proto.Val = append(proto.Val, &amp;prototypes.Value{Val: &amp;prototypes.Value_Int64ListVal{Int64ListVal: &amp;prototypes.Int64List{Val: val}}})
                }</span>
        }
        <span class="cov0" title="0">if u.doubleListVal != nil </span><span class="cov0" title="0">{
                for _, val := range u.doubleListVal </span><span class="cov0" title="0">{
                        proto.Val = append(proto.Val, &amp;prototypes.Value{Val: &amp;prototypes.Value_DoubleListVal{DoubleListVal: &amp;prototypes.DoubleList{Val: val}}})
                }</span>
        }
        <span class="cov0" title="0">if u.boolListVal != nil </span><span class="cov0" title="0">{
                for _, val := range u.boolListVal </span><span class="cov0" title="0">{
                        proto.Val = append(proto.Val, &amp;prototypes.Value{Val: &amp;prototypes.Value_BoolListVal{BoolListVal: &amp;prototypes.BoolList{Val: val}}})
                }</span>
        }
        <span class="cov0" title="0">return proto</span>
}

type getOnlineFeaturesRequest struct {
        FeatureService   *string                  `json:"feature_service"`
        Features         []string                 `json:"features"`
        Entities         map[string]repeatedValue `json:"entities"`
        FullFeatureNames bool                     `json:"full_feature_names"`
        RequestContext   map[string]repeatedValue `json:"request_context"`
}

func NewHttpServer(fs *feast.FeatureStore, loggingService *logging.LoggingService) *httpServer <span class="cov0" title="0">{
        return &amp;httpServer{fs: fs, loggingService: loggingService}
}</span>

func (s *httpServer) getOnlineFeatures(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var err error

        span, ctx := tracer.StartSpanFromContext(r.Context(), "getOnlineFeatures", tracer.ResourceName("/get-online-features"))
        defer span.Finish(tracer.WithError(err))

        logSpanContext := LogWithSpanContext(span)

        if r.Method != "POST" </span><span class="cov0" title="0">{
                http.NotFound(w, r)
                return
        }</span>

        <span class="cov0" title="0">statusQuery := r.URL.Query().Get("status")

        status := false
        if statusQuery != "" </span><span class="cov0" title="0">{
                status, err = strconv.ParseBool(statusQuery)
                if err != nil </span><span class="cov0" title="0">{
                        logSpanContext.Error().Err(err).Msg("Error parsing status query parameter")
                        writeJSONError(w, fmt.Errorf("Error parsing status query parameter: %+v", err), http.StatusBadRequest)
                        return
                }</span>
        }

        <span class="cov0" title="0">decoder := json.NewDecoder(r.Body)
        var request getOnlineFeaturesRequest
        err = decoder.Decode(&amp;request)
        if err != nil </span><span class="cov0" title="0">{
                logSpanContext.Error().Err(err).Msg("Error decoding JSON request data")
                writeJSONError(w, fmt.Errorf("Error decoding JSON request data: %+v", err), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">var featureService *model.FeatureService
        if request.FeatureService != nil </span><span class="cov0" title="0">{
                featureService, err = s.fs.GetFeatureService(*request.FeatureService)
                if err != nil </span><span class="cov0" title="0">{
                        logSpanContext.Error().Err(err).Msg("Error getting feature service from registry")
                        writeJSONError(w, fmt.Errorf("Error getting feature service from registry: %+v", err), http.StatusInternalServerError)
                        return
                }</span>
        }
        <span class="cov0" title="0">entitiesProto := make(map[string]*prototypes.RepeatedValue)
        for key, value := range request.Entities </span><span class="cov0" title="0">{
                entitiesProto[key] = value.ToProto()
        }</span>
        <span class="cov0" title="0">requestContextProto := make(map[string]*prototypes.RepeatedValue)
        for key, value := range request.RequestContext </span><span class="cov0" title="0">{
                requestContextProto[key] = value.ToProto()
        }</span>

        <span class="cov0" title="0">featureVectors, err := s.fs.GetOnlineFeatures(
                ctx,
                request.Features,
                featureService,
                entitiesProto,
                requestContextProto,
                request.FullFeatureNames)

        if err != nil </span><span class="cov0" title="0">{
                logSpanContext.Error().Err(err).Msg("Error getting feature vector")
                writeJSONError(w, fmt.Errorf("Error getting feature vector: %+v", err), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">var featureNames []string
        var results []map[string]interface{}
        for _, vector := range featureVectors </span><span class="cov0" title="0">{
                featureNames = append(featureNames, vector.Name)
                result := make(map[string]interface{})
                if status </span><span class="cov0" title="0">{
                        var statuses []string
                        for _, status := range vector.Statuses </span><span class="cov0" title="0">{
                                statuses = append(statuses, status.String())
                        }</span>
                        <span class="cov0" title="0">var timestamps []string
                        for _, timestamp := range vector.Timestamps </span><span class="cov0" title="0">{
                                timestamps = append(timestamps, timestamp.AsTime().Format(time.RFC3339))
                        }</span>

                        <span class="cov0" title="0">result["statuses"] = statuses
                        result["event_timestamps"] = timestamps</span>
                }
                // Note, that vector.Values is an Arrow Array, but this type implements JSON Marshaller.
                // So, it's not necessary to pre-process it in any way.
                <span class="cov0" title="0">result["values"] = vector.Values

                results = append(results, result)</span>
        }

        <span class="cov0" title="0">response := map[string]interface{}{
                "metadata": map[string]interface{}{
                        "feature_names": featureNames,
                },
                "results": results,
        }

        w.Header().Set("Content-Type", "application/json")

        err = json.NewEncoder(w).Encode(response)

        if err != nil </span><span class="cov0" title="0">{
                logSpanContext.Error().Err(err).Msg("Error encoding response")
                writeJSONError(w, fmt.Errorf("Error encoding response: %+v", err), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if featureService != nil &amp;&amp; featureService.LoggingConfig != nil &amp;&amp; s.loggingService != nil </span><span class="cov0" title="0">{
                logger, err := s.loggingService.GetOrCreateLogger(featureService)
                if err != nil </span><span class="cov0" title="0">{
                        logSpanContext.Error().Err(err).Msgf("Couldn't instantiate logger for feature service %s", featureService.Name)
                        writeJSONError(w, fmt.Errorf("Couldn't instantiate logger for feature service %s: %+v", featureService.Name, err), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">requestId := GenerateRequestId()

                // Note: we're converting arrow to proto for feature logging. In the future we should
                // base feature logging on arrow so that we don't have to do this extra conversion.
                var featureVectorProtos []*serving.GetOnlineFeaturesResponse_FeatureVector
                for _, vector := range featureVectors[len(request.Entities):] </span><span class="cov0" title="0">{
                        values, err := types.ArrowValuesToProtoValues(vector.Values)
                        if err != nil </span><span class="cov0" title="0">{
                                logSpanContext.Error().Err(err).Msg("Couldn't convert arrow values into protobuf")
                                writeJSONError(w, fmt.Errorf("Couldn't convert arrow values into protobuf: %+v", err), http.StatusInternalServerError)
                                return
                        }</span>
                        <span class="cov0" title="0">featureVectorProtos = append(featureVectorProtos, &amp;serving.GetOnlineFeaturesResponse_FeatureVector{
                                Values:          values,
                                Statuses:        vector.Statuses,
                                EventTimestamps: vector.Timestamps,
                        })</span>
                }

                <span class="cov0" title="0">err = logger.Log(entitiesProto, featureVectorProtos, featureNames[len(request.Entities):], requestContextProto, requestId)
                if err != nil </span><span class="cov0" title="0">{
                        writeJSONError(w, fmt.Errorf("LoggerImpl error[%s]: %+v", featureService.Name, err), http.StatusInternalServerError)
                        return
                }</span>
        }

        <span class="cov0" title="0">go releaseCGOMemory(featureVectors)</span>
}

func releaseCGOMemory(featureVectors []*onlineserving.FeatureVector) <span class="cov0" title="0">{
        for _, vector := range featureVectors </span><span class="cov0" title="0">{
                vector.Values.Release()
        }</span>
}

func logStackTrace() <span class="cov0" title="0">{
        // Start with a small buffer and grow it until the full stack trace fits.
        buf := make([]byte, 1024)
        for </span><span class="cov0" title="0">{
                stackSize := runtime.Stack(buf, false)
                if stackSize &lt; len(buf) </span><span class="cov0" title="0">{
                        // The stack trace fits in the buffer, so we can log it now.
                        log.Error().Str("stack_trace", string(buf[:stackSize])).Msg("")
                        return
                }</span>
                // The stack trace doesn't fit in the buffer, so we need to grow the buffer and try again.
                <span class="cov0" title="0">buf = make([]byte, 2*len(buf))</span>
        }
}

func writeJSONError(w http.ResponseWriter, err error, statusCode int) <span class="cov0" title="0">{
        errMap := map[string]interface{}{
                "error":       fmt.Sprintf("%+v", err),
                "status_code": statusCode,
        }
        errJSON, _ := json.Marshal(errMap)

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(statusCode)
        w.Write(errJSON)
}</span>

func recoverMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                log.Error().Err(fmt.Errorf("Panic recovered: %v", r)).Msg("A panic occurred in the server")
                                // Log the stack trace
                                logStackTrace()

                                writeJSONError(w, fmt.Errorf("Internal Server Error: %v", r), http.StatusInternalServerError)
                        }</span>
                }()
                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}

func (s *httpServer) Serve(host string, port int) error <span class="cov0" title="0">{
        if strings.ToLower(os.Getenv("ENABLE_DATADOG_TRACING")) == "true" </span><span class="cov0" title="0">{
                tracer.Start(tracer.WithRuntimeMetrics())
                defer tracer.Stop()
        }</span>
        <span class="cov0" title="0">mux := httptrace.NewServeMux()
        mux.Handle("/get-online-features", recoverMiddleware(http.HandlerFunc(s.getOnlineFeatures)))
        mux.Handle("/metrics", promhttp.Handler())
        mux.HandleFunc("/health", healthCheckHandler)
        s.server = &amp;http.Server{Addr: fmt.Sprintf("%s:%d", host, port), Handler: mux, ReadTimeout: 5 * time.Second, WriteTimeout: 10 * time.Second, IdleTimeout: 15 * time.Second}
        err := s.server.ListenAndServe()
        // Don't return the error if it's caused by graceful shutdown using Stop()
        if err == http.ErrServerClosed </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">log.Fatal().Stack().Err(err).Msg("Failed to start HTTP server")
        return err</span>
}

func healthCheckHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.WriteHeader(http.StatusOK)
        fmt.Fprintf(w, "Healthy")
}</span>
func (s *httpServer) Stop() error <span class="cov0" title="0">{
        if s.server != nil </span><span class="cov0" title="0">{
                return s.server.Shutdown(context.Background())
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package logging

import (
        "fmt"

        "github.com/feast-dev/feast/go/internal/feast/model"
        "github.com/feast-dev/feast/go/protos/feast/types"
)

type FeatureServiceSchema struct {
        JoinKeys    []string
        Features    []string
        RequestData []string

        JoinKeysTypes    map[string]types.ValueType_Enum
        FeaturesTypes    map[string]types.ValueType_Enum
        RequestDataTypes map[string]types.ValueType_Enum
}

func GenerateSchemaFromFeatureService(fs FeatureStore, featureServiceName string) (*FeatureServiceSchema, error) <span class="cov0" title="0">{
        entityMap, fvMap, odFvMap, err := fs.GetFcosMap()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">featureService, err := fs.GetFeatureService(featureServiceName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return generateSchema(featureService, entityMap, fvMap, odFvMap)</span>
}

func generateSchema(featureService *model.FeatureService, entityMap map[string]*model.Entity, fvMap map[string]*model.FeatureView, odFvMap map[string]*model.OnDemandFeatureView) (*FeatureServiceSchema, error) <span class="cov8" title="1">{
        joinKeys := make([]string, 0)
        features := make([]string, 0)
        requestData := make([]string, 0)

        joinKeysSet := make(map[string]interface{})

        entityJoinKeyToType := make(map[string]types.ValueType_Enum)
        allFeatureTypes := make(map[string]types.ValueType_Enum)
        requestDataTypes := make(map[string]types.ValueType_Enum)

        for _, featureProjection := range featureService.Projections </span><span class="cov8" title="1">{
                // Create copies of FeatureView that may contains the same *FeatureView but
                // each differentiated by a *FeatureViewProjection
                featureViewName := featureProjection.Name
                if fv, ok := fvMap[featureViewName]; ok </span><span class="cov8" title="1">{
                        for _, f := range featureProjection.Features </span><span class="cov8" title="1">{
                                fullFeatureName := getFullFeatureName(featureProjection.NameToUse(), f.Name)
                                features = append(features, fullFeatureName)
                                allFeatureTypes[fullFeatureName] = f.Dtype
                        }</span>
                        <span class="cov8" title="1">for _, entityColumn := range fv.EntityColumns </span><span class="cov8" title="1">{
                                var joinKey string
                                if joinKeyAlias, ok := featureProjection.JoinKeyMap[entityColumn.Name]; ok </span><span class="cov0" title="0">{
                                        joinKey = joinKeyAlias
                                }</span> else<span class="cov8" title="1"> {
                                        joinKey = entityColumn.Name
                                }</span>

                                <span class="cov8" title="1">if _, ok := joinKeysSet[joinKey]; !ok </span><span class="cov8" title="1">{
                                        joinKeys = append(joinKeys, joinKey)
                                }</span>

                                <span class="cov8" title="1">joinKeysSet[joinKey] = nil
                                entityJoinKeyToType[joinKey] = entityColumn.Dtype</span>
                        }
                } else<span class="cov8" title="1"> if odFv, ok := odFvMap[featureViewName]; ok </span><span class="cov8" title="1">{
                        for _, f := range featureProjection.Features </span><span class="cov8" title="1">{
                                fullFeatureName := getFullFeatureName(featureProjection.NameToUse(), f.Name)
                                features = append(features, fullFeatureName)
                                allFeatureTypes[fullFeatureName] = f.Dtype
                        }</span>
                        <span class="cov8" title="1">for paramName, paramType := range odFv.GetRequestDataSchema() </span><span class="cov8" title="1">{
                                requestData = append(requestData, paramName)
                                requestDataTypes[paramName] = paramType
                        }</span>
                } else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("no such feature view %s found (referenced from feature service %s)",
                                featureViewName, featureService.Name)
                }</span>
        }

        <span class="cov8" title="1">schema := &amp;FeatureServiceSchema{
                JoinKeys:    joinKeys,
                Features:    features,
                RequestData: requestData,

                JoinKeysTypes:    entityJoinKeyToType,
                FeaturesTypes:    allFeatureTypes,
                RequestDataTypes: requestDataTypes,
        }
        return schema, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package logging

import (
        "fmt"
        "io"
        "os"
        "path/filepath"

        "github.com/pkg/errors"

        "github.com/apache/arrow/go/v17/arrow"
        "github.com/google/uuid"

        "github.com/apache/arrow/go/v17/arrow/array"
        "github.com/apache/arrow/go/v17/parquet"
        "github.com/apache/arrow/go/v17/parquet/pqarrow"
)

type FileLogSink struct {
        path string
}

// FileLogSink is currently only used for testing. It will be instantiated during go unit tests to log to file
// and the parquet files will be cleaned up after the test is run.
func NewFileLogSink(path string) (*FileLogSink, error) <span class="cov8" title="1">{
        if path == "" </span><span class="cov0" title="0">{
                return nil, errors.New("need path for file log sink")
        }</span>

        <span class="cov8" title="1">absPath, err := filepath.Abs(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;FileLogSink{path: absPath}, nil</span>
}

func (s *FileLogSink) Write(records []arrow.Record) error <span class="cov8" title="1">{
        fileName, _ := uuid.NewUUID()

        var writer io.Writer
        writer, err := os.Create(filepath.Join(s.path, fmt.Sprintf("%s.parquet", fileName.String())))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">table := array.NewTableFromRecords(records[0].Schema(), records)

        props := parquet.NewWriterProperties(parquet.WithDictionaryDefault(false))
        arrProps := pqarrow.DefaultWriterProps()
        return pqarrow.WriteTable(table, writer, 100, props, arrProps)</span>
}

func (s *FileLogSink) Flush(featureServiceName string) error <span class="cov0" title="0">{
        // files are already flushed during Write
        return nil
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package logging

import (
        "fmt"
        "log"
        "math/rand"
        "strings"
        "sync"
        "time"

        "github.com/apache/arrow/go/v17/arrow"
        "github.com/pkg/errors"
        "google.golang.org/protobuf/types/known/timestamppb"

        "github.com/feast-dev/feast/go/protos/feast/serving"
        "github.com/feast-dev/feast/go/protos/feast/types"
)

type Log struct {
        // Example: val{int64_val: 5017}, val{int64_val: 1003}
        EntityValue []*types.Value
        RequestData []*types.Value

        FeatureValues   []*types.Value
        FeatureStatuses []serving.FieldStatus
        EventTimestamps []*timestamppb.Timestamp

        RequestId    string
        LogTimestamp time.Time
}

type LogSink interface {
        // Write is used to unload logs from memory buffer.
        // Logs are not guaranteed to be flushed to sink on this point.
        // The data can just be written to local disk (depending on implementation).
        Write(data []arrow.Record) error

        // Flush actually send data to a sink.
        // We want to control amount to interaction with sink, since it could be a costly operation.
        // Also, some sinks like BigQuery might have quotes and physically limit amount of write requests per day.
        Flush(featureServiceName string) error
}

type Logger interface {
        Log(joinKeyToEntityValues map[string]*types.RepeatedValue, featureVectors []*serving.GetOnlineFeaturesResponse_FeatureVector, featureNames []string, requestData map[string]*types.RepeatedValue, requestId string) error
}

type LoggerImpl struct {
        featureServiceName string

        buffer *MemoryBuffer
        schema *FeatureServiceSchema

        logCh    chan *Log
        signalCh chan interface{}

        sink   LogSink
        config LoggerConfig

        isStopped bool
        cond      *sync.Cond
}

type LoggerConfig struct {
        LoggingOptions

        SampleRate float32
}

func NewLoggerConfig(sampleRate float32, opts LoggingOptions) LoggerConfig <span class="cov0" title="0">{
        return LoggerConfig{
                LoggingOptions: opts,
                SampleRate:     sampleRate,
        }
}</span>

func NewLogger(schema *FeatureServiceSchema, featureServiceName string, sink LogSink, config LoggerConfig) (*LoggerImpl, error) <span class="cov8" title="1">{
        buffer, err := NewMemoryBuffer(schema)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">logger := &amp;LoggerImpl{
                featureServiceName: featureServiceName,

                logCh:    make(chan *Log, config.ChannelCapacity),
                signalCh: make(chan interface{}, 2),
                sink:     sink,

                buffer: buffer,
                schema: schema,
                config: config,

                isStopped: false,
                cond:      sync.NewCond(&amp;sync.Mutex{}),
        }

        logger.startLoggerLoop()
        return logger, nil</span>
}

func (l *LoggerImpl) EmitLog(log *Log) error <span class="cov8" title="1">{
        select </span>{
        case l.logCh &lt;- log:<span class="cov8" title="1">
                return nil</span>
        case &lt;-time.After(l.config.EmitTimeout):<span class="cov8" title="1">
                return fmt.Errorf("could not add to log channel with capacity %d. Operation timed out. Current log channel length is %d", cap(l.logCh), len(l.logCh))</span>
        }
}

func (l *LoggerImpl) startLoggerLoop() <span class="cov8" title="1">{
        go func() </span><span class="cov8" title="1">{
                for </span><span class="cov8" title="1">{
                        if err := l.loggerLoop(); err != nil </span><span class="cov0" title="0">{
                                log.Printf("LoggerImpl[%s] recovered from panic: %+v", l.featureServiceName, err)

                                // Sleep for a couple of milliseconds to avoid CPU load from a potential infinite panic-recovery loop
                                time.Sleep(5 * time.Millisecond)
                                continue</span> // try again
                        }

                        // graceful stop
                        <span class="cov8" title="1">return</span>
                }
        }()
}

// Select that either ingests new logs that are added to the logging channel, one at a time to add
// to the in-memory buffer or flushes all of them synchronously to the OfflineStorage on a time interval.
func (l *LoggerImpl) loggerLoop() (lErr error) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                // Recover from panic in the logger loop, so that it doesn't bring down the entire feature server
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        rErr, ok := r.(error)
                        if !ok </span><span class="cov0" title="0">{
                                rErr = fmt.Errorf("%v", r)
                        }</span>
                        <span class="cov0" title="0">lErr = errors.WithStack(rErr)</span>
                }
        }()

        <span class="cov8" title="1">writeTicker := time.NewTicker(l.config.WriteInterval)
        flushTicker := time.NewTicker(l.config.FlushInterval)

        for </span><span class="cov8" title="1">{
                shouldStop := false

                select </span>{
                case &lt;-l.signalCh:<span class="cov8" title="1">
                        err := l.buffer.writeBatch(l.sink)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Log write failed: %+v", err)
                        }</span>
                        <span class="cov8" title="1">err = l.sink.Flush(l.featureServiceName)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Log flush failed: %+v", err)
                        }</span>
                        <span class="cov8" title="1">shouldStop = true</span>
                case &lt;-writeTicker.C:<span class="cov8" title="1">
                        err := l.buffer.writeBatch(l.sink)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Log write failed: %+v", err)
                        }</span>
                case &lt;-flushTicker.C:<span class="cov0" title="0">
                        err := l.sink.Flush(l.featureServiceName)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Log flush failed: %+v", err)
                        }</span>
                case logItem := &lt;-l.logCh:<span class="cov8" title="1">
                        err := l.buffer.Append(logItem)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Append log failed: %+v", err)
                        }</span>
                }

                <span class="cov8" title="1">if shouldStop </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">writeTicker.Stop()
        flushTicker.Stop()

        // Notify all waiters for graceful stop
        l.cond.L.Lock()
        l.isStopped = true
        l.cond.Broadcast()
        l.cond.L.Unlock()
        return nil</span>
}

// Stop the loop goroutine gracefully
func (l *LoggerImpl) Stop() <span class="cov8" title="1">{
        select </span>{
        case l.signalCh &lt;- nil:<span class="cov8" title="1"></span>
        default:<span class="cov0" title="0"></span>
        }
}

func (l *LoggerImpl) WaitUntilStopped() <span class="cov8" title="1">{
        l.cond.L.Lock()
        defer l.cond.L.Unlock()
        for !l.isStopped </span><span class="cov8" title="1">{
                l.cond.Wait()
        }</span>
}

func getFullFeatureName(featureViewName string, featureName string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s__%s", featureViewName, featureName)
}</span>

func (l *LoggerImpl) Log(joinKeyToEntityValues map[string]*types.RepeatedValue, featureVectors []*serving.GetOnlineFeaturesResponse_FeatureVector, featureNames []string, requestData map[string]*types.RepeatedValue, requestId string) error <span class="cov8" title="1">{
        if len(featureVectors) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">if rand.Float32() &gt; l.config.SampleRate </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">numFeatures := len(l.schema.Features)
        // Should be equivalent to how many entities there are(each feature row has (entity) number of features)
        numRows := len(featureVectors[0].Values)

        featureNameToVectorIdx := make(map[string]int)
        for idx, name := range featureNames </span><span class="cov8" title="1">{
                featureNameToVectorIdx[name] = idx
        }</span>

        <span class="cov8" title="1">for rowIdx := 0; rowIdx &lt; numRows; rowIdx++ </span><span class="cov8" title="1">{
                featureValues := make([]*types.Value, numFeatures)
                featureStatuses := make([]serving.FieldStatus, numFeatures)
                eventTimestamps := make([]*timestamppb.Timestamp, numFeatures)

                for idx, featureName := range l.schema.Features </span><span class="cov8" title="1">{
                        featureIdx, ok := featureNameToVectorIdx[featureName]
                        if !ok </span><span class="cov0" title="0">{
                                featureNameParts := strings.Split(featureName, "__")
                                featureIdx, ok = featureNameToVectorIdx[featureNameParts[1]]
                                if !ok </span><span class="cov0" title="0">{
                                        return errors.Errorf("Missing feature %s in log data", featureName)
                                }</span>
                        }
                        <span class="cov8" title="1">featureValues[idx] = featureVectors[featureIdx].Values[rowIdx]
                        featureStatuses[idx] = featureVectors[featureIdx].Statuses[rowIdx]
                        eventTimestamps[idx] = featureVectors[featureIdx].EventTimestamps[rowIdx]</span>
                }

                <span class="cov8" title="1">entityValues := make([]*types.Value, len(l.schema.JoinKeys))
                for idx, joinKey := range l.schema.JoinKeys </span><span class="cov8" title="1">{
                        rows, ok := joinKeyToEntityValues[joinKey]
                        if !ok </span><span class="cov0" title="0">{
                                return errors.Errorf("Missing join key %s in log data", joinKey)
                        }</span>
                        <span class="cov8" title="1">entityValues[idx] = rows.Val[rowIdx]</span>
                }

                <span class="cov8" title="1">requestDataValues := make([]*types.Value, len(l.schema.RequestData))
                for idx, requestParam := range l.schema.RequestData </span><span class="cov0" title="0">{
                        rows, ok := requestData[requestParam]
                        if !ok </span><span class="cov0" title="0">{
                                return errors.Errorf("Missing request parameter %s in log data", requestParam)
                        }</span>
                        <span class="cov0" title="0">requestDataValues[idx] = rows.Val[rowIdx]</span>
                }

                <span class="cov8" title="1">newLog := Log{
                        EntityValue: entityValues,
                        RequestData: requestDataValues,

                        FeatureValues:   featureValues,
                        FeatureStatuses: featureStatuses,
                        EventTimestamps: eventTimestamps,

                        RequestId:    requestId,
                        LogTimestamp: time.Now().UTC(),
                }
                err := l.EmitLog(&amp;newLog)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

type DummyLoggerImpl struct{}

func (l *DummyLoggerImpl) Log(joinKeyToEntityValues map[string]*types.RepeatedValue, featureVectors []*serving.GetOnlineFeaturesResponse_FeatureVector, featureNames []string, requestData map[string]*types.RepeatedValue, requestId string) error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package logging

import (
        "fmt"

        "github.com/apache/arrow/go/v17/arrow"
        "github.com/apache/arrow/go/v17/arrow/array"
        "github.com/apache/arrow/go/v17/arrow/memory"

        "github.com/feast-dev/feast/go/protos/feast/types"
        gotypes "github.com/feast-dev/feast/go/types"
)

type MemoryBuffer struct {
        logs   []*Log
        schema *FeatureServiceSchema

        arrowSchema *arrow.Schema
        records     []arrow.Record
}

const (
        LOG_TIMESTAMP_FIELD  = "__log_timestamp"
        LOG_DATE_FIELD       = "__log_date"
        LOG_REQUEST_ID_FIELD = "__request_id"
        RECORD_SIZE          = 1000
)

func NewMemoryBuffer(schema *FeatureServiceSchema) (*MemoryBuffer, error) <span class="cov8" title="1">{
        arrowSchema, err := getArrowSchema(schema)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;MemoryBuffer{
                logs:        make([]*Log, 0),
                records:     make([]arrow.Record, 0),
                schema:      schema,
                arrowSchema: arrowSchema,
        }, nil</span>
}

// Acquires the logging schema from the feature service, converts the memory buffer array of rows of logs and flushes
// them to the offline storage.
func (b *MemoryBuffer) writeBatch(sink LogSink) error <span class="cov8" title="1">{
        if len(b.logs) &gt; 0 </span><span class="cov8" title="1">{
                err := b.Compact()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">if len(b.records) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">err := sink.Write(b.records)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">b.records = b.records[:0]
        return nil</span>
}

func (b *MemoryBuffer) Append(log *Log) error <span class="cov8" title="1">{
        b.logs = append(b.logs, log)

        if len(b.logs) == RECORD_SIZE </span><span class="cov0" title="0">{
                return b.Compact()
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (b *MemoryBuffer) Compact() error <span class="cov8" title="1">{
        rec, err := b.convertToArrowRecord()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">b.records = append(b.records, rec)
        b.logs = b.logs[:0]
        return nil</span>
}

func getArrowSchema(schema *FeatureServiceSchema) (*arrow.Schema, error) <span class="cov8" title="1">{
        fields := make([]arrow.Field, 0)

        for _, joinKey := range schema.JoinKeys </span><span class="cov8" title="1">{
                arrowType, err := gotypes.ValueTypeEnumToArrowType(schema.JoinKeysTypes[joinKey])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">fields = append(fields, arrow.Field{Name: joinKey, Type: arrowType})</span>
        }

        <span class="cov8" title="1">for _, requestParam := range schema.RequestData </span><span class="cov0" title="0">{
                arrowType, err := gotypes.ValueTypeEnumToArrowType(schema.RequestDataTypes[requestParam])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">fields = append(fields, arrow.Field{Name: requestParam, Type: arrowType})</span>
        }

        <span class="cov8" title="1">for _, featureName := range schema.Features </span><span class="cov8" title="1">{
                arrowType, err := gotypes.ValueTypeEnumToArrowType(schema.FeaturesTypes[featureName])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">fields = append(fields, arrow.Field{Name: featureName, Type: arrowType})
                fields = append(fields, arrow.Field{
                        Name: fmt.Sprintf("%s__timestamp", featureName),
                        Type: arrow.FixedWidthTypes.Timestamp_s})
                fields = append(fields, arrow.Field{
                        Name: fmt.Sprintf("%s__status", featureName),
                        Type: arrow.PrimitiveTypes.Int32})</span>
        }

        <span class="cov8" title="1">fields = append(fields, arrow.Field{Name: LOG_TIMESTAMP_FIELD, Type: arrow.FixedWidthTypes.Timestamp_us})
        fields = append(fields, arrow.Field{Name: LOG_DATE_FIELD, Type: arrow.FixedWidthTypes.Date32})
        fields = append(fields, arrow.Field{Name: LOG_REQUEST_ID_FIELD, Type: arrow.BinaryTypes.String})

        return arrow.NewSchema(fields, nil), nil</span>
}

// convertToArrowRecord Takes memory buffer of logs in array row and converts them to columnar with generated fcoschema generated by GetFcoSchema
// and writes them to arrow table.
// Returns arrow table that contains all of the logs in columnar format.
func (b *MemoryBuffer) convertToArrowRecord() (arrow.Record, error) <span class="cov8" title="1">{
        arrowMemory := memory.NewGoAllocator()
        numRows := len(b.logs)

        columns := make(map[string][]*types.Value)
        fieldNameToIdx := make(map[string]int)
        for idx, field := range b.arrowSchema.Fields() </span><span class="cov8" title="1">{
                fieldNameToIdx[field.Name] = idx
        }</span>

        <span class="cov8" title="1">builder := array.NewRecordBuilder(arrowMemory, b.arrowSchema)
        defer builder.Release()

        builder.Reserve(numRows)

        for rowIdx, logRow := range b.logs </span><span class="cov8" title="1">{
                for colIdx, joinKey := range b.schema.JoinKeys </span><span class="cov8" title="1">{
                        if _, ok := columns[joinKey]; !ok </span><span class="cov8" title="1">{
                                columns[joinKey] = make([]*types.Value, numRows)
                        }</span>
                        <span class="cov8" title="1">columns[joinKey][rowIdx] = logRow.EntityValue[colIdx]</span>
                }
                <span class="cov8" title="1">for colIdx, requestParam := range b.schema.RequestData </span><span class="cov0" title="0">{
                        if _, ok := columns[requestParam]; !ok </span><span class="cov0" title="0">{
                                columns[requestParam] = make([]*types.Value, numRows)
                        }</span>
                        <span class="cov0" title="0">columns[requestParam][rowIdx] = logRow.RequestData[colIdx]</span>
                }
                <span class="cov8" title="1">for colIdx, featureName := range b.schema.Features </span><span class="cov8" title="1">{
                        if _, ok := columns[featureName]; !ok </span><span class="cov8" title="1">{
                                columns[featureName] = make([]*types.Value, numRows)
                        }</span>
                        <span class="cov8" title="1">columns[featureName][rowIdx] = logRow.FeatureValues[colIdx]

                        timestamp := arrow.Timestamp(logRow.EventTimestamps[colIdx].GetSeconds())
                        timestampFieldIdx := fieldNameToIdx[fmt.Sprintf("%s__timestamp", featureName)]
                        statusFieldIdx := fieldNameToIdx[fmt.Sprintf("%s__status", featureName)]

                        builder.Field(timestampFieldIdx).(*array.TimestampBuilder).UnsafeAppend(timestamp)
                        builder.Field(statusFieldIdx).(*array.Int32Builder).UnsafeAppend(int32(logRow.FeatureStatuses[colIdx]))</span>
                }

                <span class="cov8" title="1">logTimestamp := arrow.Timestamp(logRow.LogTimestamp.UnixMicro())
                logDate := arrow.Date32FromTime(logRow.LogTimestamp)

                builder.Field(fieldNameToIdx[LOG_TIMESTAMP_FIELD]).(*array.TimestampBuilder).UnsafeAppend(logTimestamp)
                builder.Field(fieldNameToIdx[LOG_DATE_FIELD]).(*array.Date32Builder).UnsafeAppend(logDate)
                builder.Field(fieldNameToIdx[LOG_REQUEST_ID_FIELD]).(*array.StringBuilder).Append(logRow.RequestId)</span>
        }

        <span class="cov8" title="1">for columnName, protoArray := range columns </span><span class="cov8" title="1">{
                fieldIdx := fieldNameToIdx[columnName]
                err := gotypes.CopyProtoValuesToArrowArray(builder.Field(fieldIdx), protoArray)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">return builder.NewRecord(), nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package logging

import (
        "fmt"
        "io"
        "io/ioutil"
        "log"
        "os"
        "path/filepath"

        "github.com/apache/arrow/go/v17/arrow"
        "github.com/apache/arrow/go/v17/arrow/array"
        "github.com/apache/arrow/go/v17/parquet"
        "github.com/apache/arrow/go/v17/parquet/pqarrow"
        "github.com/google/uuid"
)

type OfflineStoreWriteCallback func(featureServiceName, datasetDir string) string

type OfflineStoreSink struct {
        datasetDir    string
        writeCallback OfflineStoreWriteCallback
}

func NewOfflineStoreSink(writeCallback OfflineStoreWriteCallback) (*OfflineStoreSink, error) <span class="cov0" title="0">{
        return &amp;OfflineStoreSink{
                datasetDir:    "",
                writeCallback: writeCallback,
        }, nil
}</span>

func (s *OfflineStoreSink) getOrCreateDatasetDir() (string, error) <span class="cov0" title="0">{
        if s.datasetDir != "" </span><span class="cov0" title="0">{
                return s.datasetDir, nil
        }</span>
        <span class="cov0" title="0">dir, err := ioutil.TempDir("", "*")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">s.datasetDir = dir
        return s.datasetDir, nil</span>
}

func (s *OfflineStoreSink) Write(records []arrow.Record) error <span class="cov0" title="0">{
        fileName, _ := uuid.NewUUID()
        datasetDir, err := s.getOrCreateDatasetDir()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var writer io.Writer
        writer, err = os.Create(filepath.Join(datasetDir, fmt.Sprintf("%s.parquet", fileName.String())))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">table := array.NewTableFromRecords(records[0].Schema(), records)

        props := parquet.NewWriterProperties(parquet.WithDictionaryDefault(false))
        arrProps := pqarrow.DefaultWriterProps()
        return pqarrow.WriteTable(table, writer, 1000, props, arrProps)</span>
}

func (s *OfflineStoreSink) Flush(featureServiceName string) error <span class="cov0" title="0">{
        if s.datasetDir == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">datasetDir := s.datasetDir
        s.datasetDir = ""

        go func() </span><span class="cov0" title="0">{
                errMsg := s.writeCallback(featureServiceName, datasetDir)
                if errMsg != "" </span><span class="cov0" title="0">{
                        log.Println(errMsg)
                }</span>
                <span class="cov0" title="0">os.RemoveAll(datasetDir)</span>
        }()

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package logging

import (
        "sync"
        "time"

        "github.com/pkg/errors"

        "github.com/feast-dev/feast/go/internal/feast/model"
)

type FeatureStore interface {
        GetFcosMap() (map[string]*model.Entity, map[string]*model.FeatureView, map[string]*model.OnDemandFeatureView, error)
        GetFeatureService(name string) (*model.FeatureService, error)
}

type LoggingOptions struct {
        // How many log items can be buffered in channel
        ChannelCapacity int

        // Waiting time when inserting new log into the channel
        EmitTimeout time.Duration

        // Interval on which logs buffered in memory will be written to sink
        WriteInterval time.Duration

        // Interval on which sink will be flushed
        // (see LogSink interface for better explanation on differences with Write)
        FlushInterval time.Duration
}

type LoggingService struct {
        // feature service name -&gt; LoggerImpl
        loggers map[string]*LoggerImpl

        fs   FeatureStore
        sink LogSink
        opts LoggingOptions

        creationLock *sync.Mutex
}

var (
        DefaultOptions = LoggingOptions{
                ChannelCapacity: 100000,
                FlushInterval:   10 * time.Minute,
                WriteInterval:   10 * time.Second,
                EmitTimeout:     10 * time.Millisecond,
        }
)

func NewLoggingService(fs FeatureStore, sink LogSink, opts ...LoggingOptions) (*LoggingService, error) <span class="cov0" title="0">{
        if len(opts) == 0 </span><span class="cov0" title="0">{
                opts = append(opts, DefaultOptions)
        }</span>

        <span class="cov0" title="0">return &amp;LoggingService{
                fs:           fs,
                loggers:      make(map[string]*LoggerImpl),
                sink:         sink,
                opts:         opts[0],
                creationLock: &amp;sync.Mutex{},
        }, nil</span>
}

func (s *LoggingService) GetOrCreateLogger(featureService *model.FeatureService) (Logger, error) <span class="cov0" title="0">{
        if logger, ok := s.loggers[featureService.Name]; ok </span><span class="cov0" title="0">{
                return logger, nil
        }</span>

        <span class="cov0" title="0">if featureService.LoggingConfig == nil </span><span class="cov0" title="0">{
                return nil, errors.New("Only feature services with configured logging can be used")
        }</span>

        <span class="cov0" title="0">s.creationLock.Lock()
        defer s.creationLock.Unlock()

        // could be created by another go-routine on this point
        if logger, ok := s.loggers[featureService.Name]; ok </span><span class="cov0" title="0">{
                return logger, nil
        }</span>

        <span class="cov0" title="0">if s.sink == nil </span><span class="cov0" title="0">{
                return &amp;DummyLoggerImpl{}, nil
        }</span>

        <span class="cov0" title="0">config := NewLoggerConfig(featureService.LoggingConfig.SampleRate, s.opts)
        schema, err := GenerateSchemaFromFeatureService(s.fs, featureService.Name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">logger, err := NewLogger(schema, featureService.Name, s.sink, config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">s.loggers[featureService.Name] = logger

        return logger, nil</span>
}

func (s *LoggingService) Stop() <span class="cov0" title="0">{
        for _, logger := range s.loggers </span><span class="cov0" title="0">{
                logger.Stop()
                logger.WaitUntilStopped()
        }</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package server

import (
        "github.com/rs/zerolog"
        "gopkg.in/DataDog/dd-trace-go.v1/ddtrace/tracer"
        "os"
)

func LogWithSpanContext(span tracer.Span) zerolog.Logger <span class="cov8" title="1">{
        spanContext := span.Context()

        var logger = zerolog.New(os.Stderr).With().
                Int64("trace_id", int64(spanContext.TraceID())).
                Int64("span_id", int64(spanContext.SpanID())).
                Timestamp().
                Logger()

        return logger
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package transformation

import (
        "context"
        "fmt"
        "runtime"
        "strings"

        "github.com/apache/arrow/go/v17/arrow"
        "github.com/apache/arrow/go/v17/arrow/memory"
        "github.com/rs/zerolog/log"
        "gopkg.in/DataDog/dd-trace-go.v1/ddtrace/tracer"

        "github.com/feast-dev/feast/go/internal/feast/model"
        "github.com/feast-dev/feast/go/internal/feast/onlineserving"
        prototypes "github.com/feast-dev/feast/go/protos/feast/types"
        "github.com/feast-dev/feast/go/types"
)

/*
TransformationCallback is a Python callback function's expected signature.
The function should accept name of the on demand feature view and pointers to input &amp; output record batches.
Each record batch is being passed as two pointers: pointer to array (data) and pointer to schema.
Python function is expected to return number of rows added to the output record batch.
*/
type TransformationCallback func(ODFVName string, inputArrPtr, inputSchemaPtr, outArrPtr, outSchemaPtr uintptr, fullFeatureNames bool) int

func AugmentResponseWithOnDemandTransforms(
        ctx context.Context,
        onDemandFeatureViews []*model.OnDemandFeatureView,
        requestData map[string]*prototypes.RepeatedValue,
        entityRows map[string]*prototypes.RepeatedValue,
        features []*onlineserving.FeatureVector,
        transformationCallback TransformationCallback,
        transformationService *GrpcTransformationService,
        arrowMemory memory.Allocator,
        numRows int,
        fullFeatureNames bool,

) ([]*onlineserving.FeatureVector, error) <span class="cov8" title="1">{
        span, _ := tracer.StartSpanFromContext(ctx, "transformation.AugmentResponseWithOnDemandTransforms")
        defer span.Finish()

        result := make([]*onlineserving.FeatureVector, 0)
        var err error

        for _, odfv := range onDemandFeatureViews </span><span class="cov0" title="0">{
                requestContextArrow := make(map[string]arrow.Array)
                for name, values := range requestData </span><span class="cov0" title="0">{
                        requestContextArrow[name], err = types.ProtoValuesToArrowArray(values.Val, arrowMemory, numRows)
                        if err != nil </span><span class="cov0" title="0">{
                                ReleaseArrowContext(requestContextArrow)
                                return nil, err
                        }</span>
                }

                <span class="cov0" title="0">for name, values := range entityRows </span><span class="cov0" title="0">{
                        requestContextArrow[name], err = types.ProtoValuesToArrowArray(values.Val, arrowMemory, numRows)
                        if err != nil </span><span class="cov0" title="0">{
                                ReleaseArrowContext(requestContextArrow)
                                return nil, err
                        }</span>
                }

                <span class="cov0" title="0">retrievedFeatures := make(map[string]arrow.Array)
                for _, vector := range features </span><span class="cov0" title="0">{
                        retrievedFeatures[vector.Name] = vector.Values
                }</span>

                <span class="cov0" title="0">var onDemandFeatures []*onlineserving.FeatureVector
                if transformationService != nil </span><span class="cov0" title="0">{
                        onDemandFeatures, err = transformationService.GetTransformation(
                                ctx,
                                odfv,
                                retrievedFeatures,
                                requestContextArrow,
                                numRows,
                                fullFeatureNames,
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                ReleaseArrowContext(requestContextArrow)
                                return nil, err
                        }</span>
                }
                <span class="cov0" title="0">result = append(result, onDemandFeatures...)

                ReleaseArrowContext(requestContextArrow)</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

func ReleaseArrowContext(requestContextArrow map[string]arrow.Array) <span class="cov0" title="0">{
        // Release memory used by requestContextArrow
        for _, arrowArray := range requestContextArrow </span><span class="cov0" title="0">{
                arrowArray.Release()
        }</span>
}

func EnsureRequestedDataExist(requestedOnDemandFeatureViews []*model.OnDemandFeatureView,
        requestDataFeatures map[string]*prototypes.RepeatedValue) error <span class="cov8" title="1">{

        neededRequestData, err := getNeededRequestData(requestedOnDemandFeatureViews)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">missingFeatures := make([]string, 0)
        for feature := range neededRequestData </span><span class="cov0" title="0">{
                if _, ok := requestDataFeatures[feature]; !ok </span><span class="cov0" title="0">{
                        missingFeatures = append(missingFeatures, feature)
                }</span>
        }

        <span class="cov8" title="1">if len(missingFeatures) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("requestDataNotFoundInEntityRowsException: %s", strings.Join(missingFeatures, ", "))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func getNeededRequestData(requestedOnDemandFeatureViews []*model.OnDemandFeatureView) (map[string]struct{}, error) <span class="cov8" title="1">{
        neededRequestData := make(map[string]struct{})

        for _, onDemandFeatureView := range requestedOnDemandFeatureViews </span><span class="cov0" title="0">{
                requestSchema := onDemandFeatureView.GetRequestDataSchema()
                for fieldName := range requestSchema </span><span class="cov0" title="0">{
                        neededRequestData[fieldName] = struct{}{}
                }</span>
        }

        <span class="cov8" title="1">return neededRequestData, nil</span>
}

func logStackTrace() <span class="cov0" title="0">{
        // Create a buffer for storing the stack trace
        const size = 4096
        buf := make([]byte, size)

        // Retrieve the stack trace and write it to the buffer
        stackSize := runtime.Stack(buf, false)

        // Log the stack trace using zerolog
        log.Error().Str("stack_trace", string(buf[:stackSize])).Msg("")
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package transformation

import (
        "bytes"
        "context"
        "fmt"
        "strings"

        "io"

        "github.com/feast-dev/feast/go/internal/feast/registry"
        "google.golang.org/protobuf/types/known/timestamppb"

        "github.com/apache/arrow/go/v17/arrow"
        "github.com/apache/arrow/go/v17/arrow/array"
        "github.com/apache/arrow/go/v17/arrow/ipc"
        "github.com/apache/arrow/go/v17/arrow/memory"
        "github.com/feast-dev/feast/go/internal/feast/model"
        "github.com/feast-dev/feast/go/internal/feast/onlineserving"
        "github.com/feast-dev/feast/go/protos/feast/serving"
        "google.golang.org/grpc"
        "google.golang.org/grpc/credentials/insecure"
)

type GrpcTransformationService struct {
        project string
        conn    *grpc.ClientConn
        client  *serving.TransformationServiceClient
}

func NewGrpcTransformationService(config *registry.RepoConfig, endpoint string) (*GrpcTransformationService, error) <span class="cov8" title="1">{
        opts := make([]grpc.DialOption, 0)
        opts = append(opts, grpc.WithDefaultCallOptions(), grpc.WithTransportCredentials(insecure.NewCredentials()))

        conn, err := grpc.Dial(endpoint, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">client := serving.NewTransformationServiceClient(conn)
        return &amp;GrpcTransformationService{config.Project, conn, &amp;client}, nil</span>
}

func (s *GrpcTransformationService) Close() error <span class="cov0" title="0">{
        return s.conn.Close()
}</span>

func (s *GrpcTransformationService) GetTransformation(
        ctx context.Context,
        featureView *model.OnDemandFeatureView,
        retrievedFeatures map[string]arrow.Array,
        requestContext map[string]arrow.Array,
        numRows int,
        fullFeatureNames bool,
) ([]*onlineserving.FeatureVector, error) <span class="cov0" title="0">{
        var err error

        inputFields := make([]arrow.Field, 0)
        inputColumns := make([]arrow.Array, 0)
        for name, arr := range retrievedFeatures </span><span class="cov0" title="0">{
                inputFields = append(inputFields, arrow.Field{Name: name, Type: arr.DataType()})
                inputColumns = append(inputColumns, arr)
        }</span>
        <span class="cov0" title="0">for name, arr := range requestContext </span><span class="cov0" title="0">{
                inputFields = append(inputFields, arrow.Field{Name: name, Type: arr.DataType()})
                inputColumns = append(inputColumns, arr)
        }</span>

        <span class="cov0" title="0">inputSchema := arrow.NewSchema(inputFields, nil)
        inputRecord := array.NewRecord(inputSchema, inputColumns, int64(numRows))
        defer inputRecord.Release()

        recordValueWriter := new(ByteSliceWriter)
        arrowWriter, err := ipc.NewFileWriter(recordValueWriter, ipc.WithSchema(inputSchema))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">err = arrowWriter.Write(inputRecord)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">err = arrowWriter.Close()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">arrowInput := serving.ValueType_ArrowValue{ArrowValue: recordValueWriter.buf}
        transformationInput := serving.ValueType{Value: &amp;arrowInput}

        req := serving.TransformFeaturesRequest{
                OnDemandFeatureViewName: featureView.Base.Name,
                Project:                 s.project,
                TransformationInput:     &amp;transformationInput,
        }

        res, err := (*s.client).TransformFeatures(ctx, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">arrowBytes := res.TransformationOutput.GetArrowValue()
        return ExtractTransformationResponse(featureView, arrowBytes, numRows, false)</span>
}

func ExtractTransformationResponse(
        featureView *model.OnDemandFeatureView,
        arrowBytes []byte,
        numRows int,
        fullFeatureNames bool,
) ([]*onlineserving.FeatureVector, error) <span class="cov0" title="0">{
        arrowMemory := memory.NewGoAllocator()
        arrowReader, err := ipc.NewFileReader(bytes.NewReader(arrowBytes), ipc.WithAllocator(arrowMemory))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">outRecord, err := arrowReader.Read()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">result := make([]*onlineserving.FeatureVector, 0)
        for idx, field := range outRecord.Schema().Fields() </span><span class="cov0" title="0">{
                dropFeature := true

                featureName := strings.Split(field.Name, "__")[1]
                if featureView.Base.Projection != nil </span><span class="cov0" title="0">{

                        for _, feature := range featureView.Base.Projection.Features </span><span class="cov0" title="0">{
                                if featureName == feature.Name </span><span class="cov0" title="0">{
                                        dropFeature = false
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        dropFeature = false
                }</span>

                <span class="cov0" title="0">if dropFeature </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">statuses := make([]serving.FieldStatus, numRows)
                timestamps := make([]*timestamppb.Timestamp, numRows)

                for idx := 0; idx &lt; numRows; idx++ </span><span class="cov0" title="0">{
                        statuses[idx] = serving.FieldStatus_PRESENT
                        timestamps[idx] = timestamppb.Now()
                }</span>

                <span class="cov0" title="0">result = append(result, &amp;onlineserving.FeatureVector{
                        Name:       featureName,
                        Values:     outRecord.Column(idx),
                        Statuses:   statuses,
                        Timestamps: timestamps,
                })</span>
        }

        <span class="cov0" title="0">return result, nil</span>
}

type ByteSliceWriter struct {
        buf    []byte
        offset int64
}

func (w *ByteSliceWriter) Write(p []byte) (n int, err error) <span class="cov0" title="0">{
        minCap := int(w.offset) + len(p)
        if minCap &gt; cap(w.buf) </span><span class="cov0" title="0">{ // Make sure buf has enough capacity:
                buf2 := make([]byte, len(w.buf), minCap+len(p)) // add some extra
                copy(buf2, w.buf)
                w.buf = buf2
        }</span>
        <span class="cov0" title="0">if minCap &gt; len(w.buf) </span><span class="cov0" title="0">{
                w.buf = w.buf[:minCap]
        }</span>
        <span class="cov0" title="0">copy(w.buf[w.offset:], p)
        w.offset += int64(len(p))
        return len(p), nil</span>
}

func (w *ByteSliceWriter) Seek(offset int64, whence int) (int64, error) <span class="cov0" title="0">{
        switch whence </span>{
        case io.SeekStart:<span class="cov0" title="0">
                if w.offset != offset &amp;&amp; (offset &lt; 0 || offset &gt; int64(len(w.buf))) </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("invalid seek: new offset %d out of range [0 %d]", offset, len(w.buf))
                }</span>
                <span class="cov0" title="0">w.offset = offset
                return offset, nil</span>
        case io.SeekCurrent:<span class="cov0" title="0">
                newOffset := w.offset + offset
                if newOffset != offset &amp;&amp; (newOffset &lt; 0 || newOffset &gt; int64(len(w.buf))) </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("invalid seek: new offset %d out of range [0 %d]", offset, len(w.buf))
                }</span>
                <span class="cov0" title="0">w.offset += offset
                return w.offset, nil</span>
        case io.SeekEnd:<span class="cov0" title="0">
                newOffset := int64(len(w.buf)) + offset
                if newOffset != offset &amp;&amp; (newOffset &lt; 0 || newOffset &gt; int64(len(w.buf))) </span><span class="cov0" title="0">{
                        return 0, fmt.Errorf("invalid seek: new offset %d out of range [0 %d]", offset, len(w.buf))
                }</span>
                <span class="cov0" title="0">w.offset = offset
                return w.offset, nil</span>
        }
        <span class="cov0" title="0">return 0, fmt.Errorf("unsupported seek mode %d", whence)</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package utils

import (
        "crypto/sha1"
        "encoding/binary"
        "encoding/hex"
        "fmt"
        "github.com/feast-dev/feast/go/protos/feast/types"
        "sort"
)

func HashSerializedEntityKey(serializedEntityKey *[]byte) string <span class="cov8" title="1">{
        if serializedEntityKey == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">h := sha1.New()
        h.Write(*serializedEntityKey)
        return hex.EncodeToString(h.Sum(nil))</span>
}

// SerializeEntityKey Serialize entity key to a bytestring so that it can be used as a lookup key in a hash table.
func SerializeEntityKey(entityKey *types.EntityKey, entityKeySerializationVersion int64) (*[]byte, error) <span class="cov8" title="1">{
        // Ensure that we have the right amount of join keys and entity values
        if len(entityKey.JoinKeys) != len(entityKey.EntityValues) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("the amount of join key names and entity values don't match: %s vs %s", entityKey.JoinKeys, entityKey.EntityValues)
        }</span>

        // Make sure that join keys are sorted so that we have consistent key building
        <span class="cov8" title="1">m := make(map[string]*types.Value)

        for i := 0; i &lt; len(entityKey.JoinKeys); i++ </span><span class="cov8" title="1">{
                m[entityKey.JoinKeys[i]] = entityKey.EntityValues[i]
        }</span>

        <span class="cov8" title="1">keys := make([]string, 0, len(m))
        for k := range entityKey.JoinKeys </span><span class="cov8" title="1">{
                keys = append(keys, entityKey.JoinKeys[k])
        }</span>
        <span class="cov8" title="1">sort.Strings(keys)

        // Build the key
        length := 5 * len(keys)
        bufferList := make([][]byte, length)

        for i := 0; i &lt; len(keys); i++ </span><span class="cov8" title="1">{
                offset := i * 2
                byteBuffer := make([]byte, 4)
                binary.LittleEndian.PutUint32(byteBuffer, uint32(types.ValueType_Enum_value["STRING"]))
                bufferList[offset] = byteBuffer
                bufferList[offset+1] = []byte(keys[i])
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; len(keys); i++ </span><span class="cov8" title="1">{
                offset := (2 * len(keys)) + (i * 3)
                value := m[keys[i]].GetVal()

                valueBytes, valueTypeBytes, err := serializeValue(value, entityKeySerializationVersion)
                if err != nil </span><span class="cov0" title="0">{
                        return valueBytes, err
                }</span>

                <span class="cov8" title="1">typeBuffer := make([]byte, 4)
                binary.LittleEndian.PutUint32(typeBuffer, uint32(valueTypeBytes))

                lenBuffer := make([]byte, 4)
                binary.LittleEndian.PutUint32(lenBuffer, uint32(len(*valueBytes)))

                bufferList[offset+0] = typeBuffer
                bufferList[offset+1] = lenBuffer
                bufferList[offset+2] = *valueBytes</span>
        }

        // Convert from an array of byte arrays to a single byte array
        <span class="cov8" title="1">var entityKeyBuffer []byte
        for i := 0; i &lt; len(bufferList); i++ </span><span class="cov8" title="1">{
                entityKeyBuffer = append(entityKeyBuffer, bufferList[i]...)
        }</span>

        <span class="cov8" title="1">return &amp;entityKeyBuffer, nil</span>
}

func serializeValue(value interface{}, entityKeySerializationVersion int64) (*[]byte, types.ValueType_Enum, error) <span class="cov8" title="1">{
        // TODO: Implement support for other types (at least the major types like ints, strings, bytes)
        switch x := (value).(type) </span>{
        case *types.Value_StringVal:<span class="cov0" title="0">
                valueString := []byte(x.StringVal)
                return &amp;valueString, types.ValueType_STRING, nil</span>
        case *types.Value_BytesVal:<span class="cov0" title="0">
                return &amp;x.BytesVal, types.ValueType_BYTES, nil</span>
        case *types.Value_Int32Val:<span class="cov0" title="0">
                valueBuffer := make([]byte, 4)
                binary.LittleEndian.PutUint32(valueBuffer, uint32(x.Int32Val))
                return &amp;valueBuffer, types.ValueType_INT32, nil</span>
        case *types.Value_Int64Val:<span class="cov8" title="1">
                if entityKeySerializationVersion &lt;= 1 </span><span class="cov8" title="1">{
                        //  We unfortunately have to use 32 bit here for backward compatibility :(
                        valueBuffer := make([]byte, 4)
                        binary.LittleEndian.PutUint32(valueBuffer, uint32(x.Int64Val))
                        return &amp;valueBuffer, types.ValueType_INT64, nil
                }</span> else<span class="cov8" title="1"> {
                        valueBuffer := make([]byte, 8)
                        binary.LittleEndian.PutUint64(valueBuffer, uint64(x.Int64Val))
                        return &amp;valueBuffer, types.ValueType_INT64, nil
                }</span>
        case nil:<span class="cov0" title="0">
                return nil, types.ValueType_INVALID, fmt.Errorf("could not detect type for %v", x)</span>
        default:<span class="cov0" title="0">
                return nil, types.ValueType_INVALID, fmt.Errorf("could not detect type for %v", x)</span>
        }
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package test

import (
        "context"
        "fmt"
        "log"

        "github.com/apache/arrow/go/v17/arrow/memory"
        "google.golang.org/protobuf/types/known/durationpb"
        "google.golang.org/protobuf/types/known/timestamppb"

        "github.com/apache/arrow/go/v17/arrow"
        "github.com/apache/arrow/go/v17/parquet/file"
        "github.com/apache/arrow/go/v17/parquet/pqarrow"

        "os"
        "os/exec"
        "path/filepath"
        "time"

        "github.com/apache/arrow/go/v17/arrow/array"

        "github.com/feast-dev/feast/go/internal/feast/model"
        "github.com/feast-dev/feast/go/protos/feast/types"
        gotypes "github.com/feast-dev/feast/go/types"
)

type Row struct {
        EventTimestamp int64
        DriverId       int64
        ConvRate       float32
        AccRate        float32
        AvgDailyTrips  int32
        Created        int64
}

func ReadParquet(filePath string) ([]*Row, error) <span class="cov8" title="1">{
        allocator := memory.NewGoAllocator()
        pqfile, err := file.OpenParquetFile(filePath, false)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">reader, err := pqarrow.NewFileReader(pqfile, pqarrow.ArrowReadProperties{}, allocator)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">fmt.Println(reader)
        table, err := reader.ReadTable(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">columns := make(map[string]arrow.Array)
        fields := table.Schema().Fields()
        for idx, field := range fields </span><span class="cov8" title="1">{
                columns[field.Name] = table.Column(idx).Data().Chunk(0)
        }</span>

        <span class="cov8" title="1">rows := make([]*Row, 0)
        for rowIdx := 0; rowIdx &lt; int(table.NumRows()); rowIdx++ </span><span class="cov8" title="1">{
                rows = append(rows, &amp;Row{
                        EventTimestamp: columns["event_timestamp"].(*array.Timestamp).Value(rowIdx).ToTime(arrow.Second).Unix(),
                        DriverId:       columns["driver_id"].(*array.Int64).Value(rowIdx),
                        ConvRate:       columns["conv_rate"].(*array.Float32).Value(rowIdx),
                        AccRate:        columns["acc_rate"].(*array.Float32).Value(rowIdx),
                        AvgDailyTrips:  columns["avg_daily_trips"].(*array.Int32).Value(rowIdx),
                        Created:        columns["created"].(*array.Timestamp).Value(rowIdx).ToTime(arrow.Second).Unix(),
                })
        }</span>

        <span class="cov8" title="1">return rows, nil</span>
}

func GetLatestFeatures(Rows []*Row, entities map[int64]bool) map[int64]*Row <span class="cov8" title="1">{
        correctFeatureRows := make(map[int64]*Row)
        for _, Row := range Rows </span><span class="cov8" title="1">{
                if _, ok := entities[Row.DriverId]; ok </span><span class="cov8" title="1">{
                        if _, ok := correctFeatureRows[Row.DriverId]; ok </span><span class="cov8" title="1">{
                                if Row.EventTimestamp &gt; correctFeatureRows[Row.DriverId].EventTimestamp </span><span class="cov8" title="1">{
                                        correctFeatureRows[Row.DriverId] = Row
                                }</span>
                        } else<span class="cov8" title="1"> {
                                correctFeatureRows[Row.DriverId] = Row
                        }</span>
                }
        }
        <span class="cov8" title="1">return correctFeatureRows</span>
}

func SetupCleanFeatureRepo(basePath string) error <span class="cov8" title="1">{
        cmd := exec.Command("feast", "init", "my_project")
        path, err := filepath.Abs(basePath)
        cmd.Env = os.Environ()

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">cmd.Dir = path
        err = cmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">applyCommand := exec.Command("feast", "apply")
        applyCommand.Env = os.Environ()
        featureRepoPath, err := filepath.Abs(filepath.Join(path, "my_project", "feature_repo"))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">applyCommand.Dir = featureRepoPath
        err = applyCommand.Run()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">t := time.Now()

        formattedTime := fmt.Sprintf("%d-%02d-%02dT%02d:%02d:%02d",
                t.Year(), t.Month(), t.Day(),
                t.Hour(), t.Minute(), t.Second())
        materializeCommand := exec.Command("feast", "materialize-incremental", formattedTime)
        materializeCommand.Env = os.Environ()
        materializeCommand.Dir = featureRepoPath
        err = materializeCommand.Run()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func SetupInitializedRepo(basePath string) error <span class="cov8" title="1">{
        path, err := filepath.Abs(basePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">applyCommand := exec.Command("feast", "apply")
        applyCommand.Env = os.Environ()
        featureRepoPath, err := filepath.Abs(filepath.Join(path, "feature_repo"))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // var stderr bytes.Buffer
        // var stdout bytes.Buffer
        <span class="cov8" title="1">applyCommand.Dir = featureRepoPath
        out, err := applyCommand.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                log.Println(string(out))
                return err
        }</span>
        <span class="cov8" title="1">t := time.Now()

        formattedTime := fmt.Sprintf("%d-%02d-%02dT%02d:%02d:%02d",
                t.Year(), t.Month(), t.Day(),
                t.Hour(), t.Minute(), t.Second())

        materializeCommand := exec.Command("feast", "materialize-incremental", formattedTime)
        materializeCommand.Env = os.Environ()
        materializeCommand.Dir = featureRepoPath
        out, err = materializeCommand.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                log.Println(string(out))
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func CleanUpInitializedRepo(basePath string) <span class="cov8" title="1">{
        featureRepoPath, err := filepath.Abs(filepath.Join(basePath, "feature_repo"))
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov8" title="1">err = os.Remove(filepath.Join(featureRepoPath, "data", "registry.db"))
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov8" title="1">err = os.Remove(filepath.Join(featureRepoPath, "data", "online_store.db"))
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
}

func GetProtoFromRecord(rec arrow.Record) (map[string]*types.RepeatedValue, error) <span class="cov8" title="1">{
        r := make(map[string]*types.RepeatedValue)
        schema := rec.Schema()
        for idx, column := range rec.Columns() </span><span class="cov8" title="1">{
                field := schema.Field(idx)
                if field.Type.ID() == arrow.FixedWidthTypes.Timestamp_ms.ID() || field.Type.ID() == arrow.FixedWidthTypes.Date32.ID() </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">values, err := gotypes.ArrowValuesToProtoValues(column)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">r[field.Name] = &amp;types.RepeatedValue{Val: values}</span>
        }
        <span class="cov8" title="1">return r, nil</span>
}

func CreateBaseFeatureView(name string, features []*model.Field, projection *model.FeatureViewProjection) *model.BaseFeatureView <span class="cov8" title="1">{
        return &amp;model.BaseFeatureView{
                Name:       name,
                Features:   features,
                Projection: projection,
        }
}</span>

func CreateNewEntity(name string, joinKey string) *model.Entity <span class="cov8" title="1">{
        return &amp;model.Entity{
                Name:    name,
                JoinKey: joinKey,
        }
}</span>

func CreateNewField(name string, dtype types.ValueType_Enum) *model.Field <span class="cov8" title="1">{
        return &amp;model.Field{Name: name,
                Dtype: dtype,
        }
}</span>

func CreateNewFeatureService(name string, project string, createdTimestamp *timestamppb.Timestamp, lastUpdatedTimestamp *timestamppb.Timestamp, projections []*model.FeatureViewProjection) *model.FeatureService <span class="cov8" title="1">{
        return &amp;model.FeatureService{
                Name:                 name,
                Project:              project,
                CreatedTimestamp:     createdTimestamp,
                LastUpdatedTimestamp: lastUpdatedTimestamp,
                Projections:          projections,
        }
}</span>

func CreateNewFeatureViewProjection(name string, nameAlias string, features []*model.Field, joinKeyMap map[string]string) *model.FeatureViewProjection <span class="cov8" title="1">{
        return &amp;model.FeatureViewProjection{Name: name,
                NameAlias:  nameAlias,
                Features:   features,
                JoinKeyMap: joinKeyMap,
        }
}</span>

func CreateFeatureView(base *model.BaseFeatureView, ttl *durationpb.Duration, entities []string, entityColumns []*model.Field) *model.FeatureView <span class="cov8" title="1">{
        return &amp;model.FeatureView{
                Base:          base,
                Ttl:           ttl,
                EntityNames:   entities,
                EntityColumns: entityColumns,
        }
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package main

import (
        "flag"
        "fmt"
        "net"
        "net/http"
        "os"
        "os/signal"
        "strings"
        "syscall"

        "github.com/feast-dev/feast/go/internal/feast"
        "github.com/feast-dev/feast/go/internal/feast/registry"
        "github.com/feast-dev/feast/go/internal/feast/server"
        "github.com/feast-dev/feast/go/internal/feast/server/logging"
        "github.com/feast-dev/feast/go/protos/feast/serving"
        "github.com/prometheus/client_golang/prometheus"
        "github.com/rs/zerolog/log"
        "google.golang.org/grpc"
        "google.golang.org/grpc/health"
        "google.golang.org/grpc/health/grpc_health_v1"

        grpcPrometheus "github.com/grpc-ecosystem/go-grpc-middleware/providers/prometheus"
        "github.com/prometheus/client_golang/prometheus/promhttp"
        _ "go.uber.org/automaxprocs"
        grpcTrace "gopkg.in/DataDog/dd-trace-go.v1/contrib/google.golang.org/grpc"
        "gopkg.in/DataDog/dd-trace-go.v1/ddtrace/tracer"
)

type ServerStarter interface {
        StartHttpServer(fs *feast.FeatureStore, host string, port int, writeLoggedFeaturesCallback logging.OfflineStoreWriteCallback, loggingOpts *logging.LoggingOptions) error
        StartGrpcServer(fs *feast.FeatureStore, host string, port int, writeLoggedFeaturesCallback logging.OfflineStoreWriteCallback, loggingOpts *logging.LoggingOptions) error
}

type RealServerStarter struct{}

func (s *RealServerStarter) StartHttpServer(fs *feast.FeatureStore, host string, port int, writeLoggedFeaturesCallback logging.OfflineStoreWriteCallback, loggingOpts *logging.LoggingOptions) error <span class="cov0" title="0">{
        return StartHttpServer(fs, host, port, writeLoggedFeaturesCallback, loggingOpts)
}</span>

func (s *RealServerStarter) StartGrpcServer(fs *feast.FeatureStore, host string, port int, writeLoggedFeaturesCallback logging.OfflineStoreWriteCallback, loggingOpts *logging.LoggingOptions) error <span class="cov0" title="0">{
        return StartGrpcServer(fs, host, port, writeLoggedFeaturesCallback, loggingOpts)
}</span>

func main() <span class="cov0" title="0">{
        // Default values
        serverType := "http"
        host := ""
        port := 8080
        server := RealServerStarter{}
        // Current Directory
        repoPath, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Stack().Err(err).Msg("Failed to get current directory")
        }</span>

        <span class="cov0" title="0">flag.StringVar(&amp;serverType, "type", serverType, "Specify the server type (http or grpc)")
        flag.StringVar(&amp;repoPath, "chdir", repoPath, "Repository path where feature store yaml file is stored")

        flag.StringVar(&amp;host, "host", host, "Specify a host for the server")
        flag.IntVar(&amp;port, "port", port, "Specify a port for the server")
        flag.Parse()

        repoConfig, err := registry.NewRepoConfigFromFile(repoPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal().Stack().Err(err).Msg("Failed to convert to RepoConfig")
        }</span>

        <span class="cov0" title="0">fs, err := feast.NewFeatureStore(repoConfig, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal().Stack().Err(err).Msg("Failed to create NewFeatureStore")
        }</span>

        <span class="cov0" title="0">loggingOptions, err := repoConfig.GetLoggingOptions()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal().Stack().Err(err).Msg("Failed to get LoggingOptions")
        }</span>

        // TODO: writeLoggedFeaturesCallback is defaulted to nil. write_logged_features functionality needs to be
        // implemented in Golang specific to OfflineStoreSink. Python Feature Server doesn't support this.
        <span class="cov0" title="0">if serverType == "http" </span><span class="cov0" title="0">{
                err = server.StartHttpServer(fs, host, port, nil, loggingOptions)
        }</span> else<span class="cov0" title="0"> if serverType == "grpc" </span><span class="cov0" title="0">{
                err = server.StartGrpcServer(fs, host, port, nil, loggingOptions)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("Unknown server type. Please specify 'http' or 'grpc'.")
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Fatal().Stack().Err(err).Msg("Failed to start server")
        }</span>

}

func constructLoggingService(fs *feast.FeatureStore, writeLoggedFeaturesCallback logging.OfflineStoreWriteCallback, loggingOpts *logging.LoggingOptions) (*logging.LoggingService, error) <span class="cov8" title="1">{
        var loggingService *logging.LoggingService = nil
        if writeLoggedFeaturesCallback != nil </span><span class="cov0" title="0">{
                sink, err := logging.NewOfflineStoreSink(writeLoggedFeaturesCallback)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">loggingService, err = logging.NewLoggingService(fs, sink, logging.LoggingOptions{
                        ChannelCapacity: loggingOpts.ChannelCapacity,
                        EmitTimeout:     loggingOpts.EmitTimeout,
                        WriteInterval:   loggingOpts.WriteInterval,
                        FlushInterval:   loggingOpts.FlushInterval,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">return loggingService, nil</span>
}

// StartGprcServerWithLogging starts gRPC server with enabled feature logging
func StartGrpcServer(fs *feast.FeatureStore, host string, port int, writeLoggedFeaturesCallback logging.OfflineStoreWriteCallback, loggingOpts *logging.LoggingOptions) error <span class="cov0" title="0">{
        if strings.ToLower(os.Getenv("ENABLE_DATADOG_TRACING")) == "true" </span><span class="cov0" title="0">{
                tracer.Start(tracer.WithRuntimeMetrics())
                defer tracer.Stop()
        }</span>
        <span class="cov0" title="0">loggingService, err := constructLoggingService(fs, writeLoggedFeaturesCallback, loggingOpts)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">ser := server.NewGrpcServingServiceServer(fs, loggingService)
        log.Info().Msgf("Starting a gRPC server on host %s port %d", host, port)
        lis, err := net.Listen("tcp", fmt.Sprintf("%s:%d", host, port))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">grpcPromMetrics := grpcPrometheus.NewServerMetrics()
        prometheus.MustRegister(grpcPromMetrics)
        grpcServer := grpc.NewServer(
                grpc.ChainUnaryInterceptor(grpcTrace.UnaryServerInterceptor(), grpcPromMetrics.UnaryServerInterceptor()),
        )
        serving.RegisterServingServiceServer(grpcServer, ser)
        healthService := health.NewServer()
        grpc_health_v1.RegisterHealthServer(grpcServer, healthService)

        // Running Prometheus metrics endpoint on a separate goroutine
        go func() </span><span class="cov0" title="0">{
                http.Handle("/metrics", promhttp.Handler())
                log.Info().Msg("Starting metrics endpoint on port 8080")
                log.Fatal().Stack().Err(http.ListenAndServe(":8080", nil))
        }</span>()

        <span class="cov0" title="0">stop := make(chan os.Signal, 1)
        signal.Notify(stop, syscall.SIGINT, syscall.SIGTERM)

        go func() </span><span class="cov0" title="0">{
                // As soon as these signals are received from OS, try to gracefully stop the gRPC server
                &lt;-stop
                log.Info().Msg("Stopping the gRPC server...")
                grpcServer.GracefulStop()
                if loggingService != nil </span><span class="cov0" title="0">{
                        loggingService.Stop()
                }</span>
                <span class="cov0" title="0">log.Info().Msg("gRPC server terminated")</span>
        }()

        <span class="cov0" title="0">return grpcServer.Serve(lis)</span>
}

// StartHttpServerWithLogging starts HTTP server with enabled feature logging
// Go does not allow direct assignment to package-level functions as a way to
// mock them for tests
func StartHttpServer(fs *feast.FeatureStore, host string, port int, writeLoggedFeaturesCallback logging.OfflineStoreWriteCallback, loggingOpts *logging.LoggingOptions) error <span class="cov0" title="0">{
        loggingService, err := constructLoggingService(fs, writeLoggedFeaturesCallback, loggingOpts)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">ser := server.NewHttpServer(fs, loggingService)
        log.Info().Msgf("Starting a HTTP server on host %s, port %d", host, port)

        stop := make(chan os.Signal, 1)
        signal.Notify(stop, syscall.SIGINT, syscall.SIGTERM)

        go func() </span><span class="cov0" title="0">{
                // As soon as these signals are received from OS, try to gracefully stop the gRPC server
                &lt;-stop
                log.Info().Msg("Stopping the HTTP server...")
                err := ser.Stop()
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Err(err).Msg("Error when stopping the HTTP server")
                }</span>
                <span class="cov0" title="0">if loggingService != nil </span><span class="cov0" title="0">{
                        loggingService.Stop()
                }</span>
                <span class="cov0" title="0">log.Info().Msg("HTTP server terminated")</span>
        }()

        <span class="cov0" title="0">return ser.Serve(host, port)</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.31.0
//         protoc        v4.25.1
// source: feast/core/Aggregation.proto

package core

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        durationpb "google.golang.org/protobuf/types/known/durationpb"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Aggregation struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Column        string               `protobuf:"bytes,1,opt,name=column,proto3" json:"column,omitempty"`
        Function      string               `protobuf:"bytes,2,opt,name=function,proto3" json:"function,omitempty"`
        TimeWindow    *durationpb.Duration `protobuf:"bytes,3,opt,name=time_window,json=timeWindow,proto3" json:"time_window,omitempty"`
        SlideInterval *durationpb.Duration `protobuf:"bytes,4,opt,name=slide_interval,json=slideInterval,proto3" json:"slide_interval,omitempty"`
}

func (x *Aggregation) Reset() <span class="cov0" title="0">{
        *x = Aggregation{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_Aggregation_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Aggregation) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Aggregation) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Aggregation) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_Aggregation_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use Aggregation.ProtoReflect.Descriptor instead.
func (*Aggregation) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_Aggregation_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Aggregation) GetColumn() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Column
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Aggregation) GetFunction() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Function
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Aggregation) GetTimeWindow() *durationpb.Duration <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TimeWindow
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Aggregation) GetSlideInterval() *durationpb.Duration <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SlideInterval
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_feast_core_Aggregation_proto protoreflect.FileDescriptor

var file_feast_core_Aggregation_proto_rawDesc = []byte{
        0x0a, 0x1c, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x41, 0x67, 0x67,
        0x72, 0x65, 0x67, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0a,
        0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x1a, 0x1e, 0x67, 0x6f, 0x6f, 0x67,
        0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x64, 0x75, 0x72, 0x61,
        0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xbf, 0x01, 0x0a, 0x0b, 0x41,
        0x67, 0x67, 0x72, 0x65, 0x67, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x16, 0x0a, 0x06, 0x63, 0x6f,
        0x6c, 0x75, 0x6d, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x63, 0x6f, 0x6c, 0x75,
        0x6d, 0x6e, 0x12, 0x1a, 0x0a, 0x08, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x3a,
        0x0a, 0x0b, 0x74, 0x69, 0x6d, 0x65, 0x5f, 0x77, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x18, 0x03, 0x20,
        0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0a,
        0x74, 0x69, 0x6d, 0x65, 0x57, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x12, 0x40, 0x0a, 0x0e, 0x73, 0x6c,
        0x69, 0x64, 0x65, 0x5f, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x18, 0x04, 0x20, 0x01,
        0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x62, 0x75, 0x66, 0x2e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0d, 0x73,
        0x6c, 0x69, 0x64, 0x65, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x42, 0x55, 0x0a, 0x10,
        0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x63, 0x6f, 0x72, 0x65,
        0x42, 0x10, 0x41, 0x67, 0x67, 0x72, 0x65, 0x67, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x72, 0x6f,
        0x74, 0x6f, 0x5a, 0x2f, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x66,
        0x65, 0x61, 0x73, 0x74, 0x2d, 0x64, 0x65, 0x76, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x67,
        0x6f, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x73, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63,
        0x6f, 0x72, 0x65, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_feast_core_Aggregation_proto_rawDescOnce sync.Once
        file_feast_core_Aggregation_proto_rawDescData = file_feast_core_Aggregation_proto_rawDesc
)

func file_feast_core_Aggregation_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_feast_core_Aggregation_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_feast_core_Aggregation_proto_rawDescData = protoimpl.X.CompressGZIP(file_feast_core_Aggregation_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_feast_core_Aggregation_proto_rawDescData</span>
}

var file_feast_core_Aggregation_proto_msgTypes = make([]protoimpl.MessageInfo, 1)
var file_feast_core_Aggregation_proto_goTypes = []interface{}{
        (*Aggregation)(nil),         // 0: feast.core.Aggregation
        (*durationpb.Duration)(nil), // 1: google.protobuf.Duration
}
var file_feast_core_Aggregation_proto_depIdxs = []int32{
        1, // 0: feast.core.Aggregation.time_window:type_name -&gt; google.protobuf.Duration
        1, // 1: feast.core.Aggregation.slide_interval:type_name -&gt; google.protobuf.Duration
        2, // [2:2] is the sub-list for method output_type
        2, // [2:2] is the sub-list for method input_type
        2, // [2:2] is the sub-list for extension type_name
        2, // [2:2] is the sub-list for extension extendee
        0, // [0:2] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_feast_core_Aggregation_proto_init() }</span>
func file_feast_core_Aggregation_proto_init() <span class="cov8" title="1">{
        if File_feast_core_Aggregation_proto != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_feast_core_Aggregation_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Aggregation); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_feast_core_Aggregation_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   1,
                        NumExtensions: 0,
                        NumServices:   0,
                },
                GoTypes:           file_feast_core_Aggregation_proto_goTypes,
                DependencyIndexes: file_feast_core_Aggregation_proto_depIdxs,
                MessageInfos:      file_feast_core_Aggregation_proto_msgTypes,
        }.Build()
        File_feast_core_Aggregation_proto = out.File
        file_feast_core_Aggregation_proto_rawDesc = nil
        file_feast_core_Aggregation_proto_goTypes = nil
        file_feast_core_Aggregation_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">//
// Copyright 2020 The Feast Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.31.0
//         protoc        v4.25.1
// source: feast/core/DataFormat.proto

package core

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Defines the file format encoding the features/entity data in files
type FileFormat struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Types that are assignable to Format:
        //
        //        *FileFormat_ParquetFormat_
        //        *FileFormat_DeltaFormat_
        Format isFileFormat_Format `protobuf_oneof:"format"`
}

func (x *FileFormat) Reset() <span class="cov0" title="0">{
        *x = FileFormat{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_DataFormat_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *FileFormat) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FileFormat) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FileFormat) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_DataFormat_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use FileFormat.ProtoReflect.Descriptor instead.
func (*FileFormat) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_DataFormat_proto_rawDescGZIP(), []int{0}
}</span>

func (m *FileFormat) GetFormat() isFileFormat_Format <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Format
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FileFormat) GetParquetFormat() *FileFormat_ParquetFormat <span class="cov0" title="0">{
        if x, ok := x.GetFormat().(*FileFormat_ParquetFormat_); ok </span><span class="cov0" title="0">{
                return x.ParquetFormat
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FileFormat) GetDeltaFormat() *FileFormat_DeltaFormat <span class="cov0" title="0">{
        if x, ok := x.GetFormat().(*FileFormat_DeltaFormat_); ok </span><span class="cov0" title="0">{
                return x.DeltaFormat
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type isFileFormat_Format interface {
        isFileFormat_Format()
}

type FileFormat_ParquetFormat_ struct {
        ParquetFormat *FileFormat_ParquetFormat `protobuf:"bytes,1,opt,name=parquet_format,json=parquetFormat,proto3,oneof"`
}

type FileFormat_DeltaFormat_ struct {
        DeltaFormat *FileFormat_DeltaFormat `protobuf:"bytes,2,opt,name=delta_format,json=deltaFormat,proto3,oneof"`
}

func (*FileFormat_ParquetFormat_) isFileFormat_Format() {<span class="cov0" title="0">}</span>

func (*FileFormat_DeltaFormat_) isFileFormat_Format() {<span class="cov0" title="0">}</span>

// Defines the data format encoding features/entity data in data streams
type StreamFormat struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Specifies the data format and format specific options
        //
        // Types that are assignable to Format:
        //
        //        *StreamFormat_AvroFormat_
        //        *StreamFormat_ProtoFormat_
        //        *StreamFormat_JsonFormat_
        //        *StreamFormat_ConfluentAvroFormat_
        Format isStreamFormat_Format `protobuf_oneof:"format"`
}

func (x *StreamFormat) Reset() <span class="cov0" title="0">{
        *x = StreamFormat{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_DataFormat_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *StreamFormat) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StreamFormat) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StreamFormat) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_DataFormat_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use StreamFormat.ProtoReflect.Descriptor instead.
func (*StreamFormat) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_DataFormat_proto_rawDescGZIP(), []int{1}
}</span>

func (m *StreamFormat) GetFormat() isStreamFormat_Format <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Format
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *StreamFormat) GetAvroFormat() *StreamFormat_AvroFormat <span class="cov0" title="0">{
        if x, ok := x.GetFormat().(*StreamFormat_AvroFormat_); ok </span><span class="cov0" title="0">{
                return x.AvroFormat
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *StreamFormat) GetProtoFormat() *StreamFormat_ProtoFormat <span class="cov0" title="0">{
        if x, ok := x.GetFormat().(*StreamFormat_ProtoFormat_); ok </span><span class="cov0" title="0">{
                return x.ProtoFormat
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *StreamFormat) GetJsonFormat() *StreamFormat_JsonFormat <span class="cov0" title="0">{
        if x, ok := x.GetFormat().(*StreamFormat_JsonFormat_); ok </span><span class="cov0" title="0">{
                return x.JsonFormat
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *StreamFormat) GetConfluentAvroFormat() *StreamFormat_ConfluentAvroFormat <span class="cov0" title="0">{
        if x, ok := x.GetFormat().(*StreamFormat_ConfluentAvroFormat_); ok </span><span class="cov0" title="0">{
                return x.ConfluentAvroFormat
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type isStreamFormat_Format interface {
        isStreamFormat_Format()
}

type StreamFormat_AvroFormat_ struct {
        AvroFormat *StreamFormat_AvroFormat `protobuf:"bytes,1,opt,name=avro_format,json=avroFormat,proto3,oneof"`
}

type StreamFormat_ProtoFormat_ struct {
        ProtoFormat *StreamFormat_ProtoFormat `protobuf:"bytes,2,opt,name=proto_format,json=protoFormat,proto3,oneof"`
}

type StreamFormat_JsonFormat_ struct {
        JsonFormat *StreamFormat_JsonFormat `protobuf:"bytes,3,opt,name=json_format,json=jsonFormat,proto3,oneof"`
}

type StreamFormat_ConfluentAvroFormat_ struct {
        ConfluentAvroFormat *StreamFormat_ConfluentAvroFormat `protobuf:"bytes,4,opt,name=confluent_avro_format,json=confluentAvroFormat,proto3,oneof"`
}

func (*StreamFormat_AvroFormat_) isStreamFormat_Format() {<span class="cov0" title="0">}</span>

func (*StreamFormat_ProtoFormat_) isStreamFormat_Format() {<span class="cov0" title="0">}</span>

func (*StreamFormat_JsonFormat_) isStreamFormat_Format() {<span class="cov0" title="0">}</span>

func (*StreamFormat_ConfluentAvroFormat_) isStreamFormat_Format() {<span class="cov0" title="0">}</span>

// Defines options for the Parquet data format
type FileFormat_ParquetFormat struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *FileFormat_ParquetFormat) Reset() <span class="cov0" title="0">{
        *x = FileFormat_ParquetFormat{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_DataFormat_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *FileFormat_ParquetFormat) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FileFormat_ParquetFormat) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FileFormat_ParquetFormat) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_feast_core_DataFormat_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use FileFormat_ParquetFormat.ProtoReflect.Descriptor instead.
func (*FileFormat_ParquetFormat) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_DataFormat_proto_rawDescGZIP(), []int{0, 0}
}</span>

// Defines options for delta data format
type FileFormat_DeltaFormat struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *FileFormat_DeltaFormat) Reset() <span class="cov0" title="0">{
        *x = FileFormat_DeltaFormat{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_DataFormat_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *FileFormat_DeltaFormat) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FileFormat_DeltaFormat) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FileFormat_DeltaFormat) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_feast_core_DataFormat_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use FileFormat_DeltaFormat.ProtoReflect.Descriptor instead.
func (*FileFormat_DeltaFormat) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_DataFormat_proto_rawDescGZIP(), []int{0, 1}
}</span>

// Defines options for the protobuf data format
type StreamFormat_ProtoFormat struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Classpath to the generated Java Protobuf class that can be used to decode
        // Feature data from the obtained stream message
        ClassPath string `protobuf:"bytes,1,opt,name=class_path,json=classPath,proto3" json:"class_path,omitempty"`
}

func (x *StreamFormat_ProtoFormat) Reset() <span class="cov0" title="0">{
        *x = StreamFormat_ProtoFormat{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_DataFormat_proto_msgTypes[4]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *StreamFormat_ProtoFormat) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StreamFormat_ProtoFormat) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StreamFormat_ProtoFormat) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_feast_core_DataFormat_proto_msgTypes[4]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use StreamFormat_ProtoFormat.ProtoReflect.Descriptor instead.
func (*StreamFormat_ProtoFormat) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_DataFormat_proto_rawDescGZIP(), []int{1, 0}
}</span>

func (x *StreamFormat_ProtoFormat) GetClassPath() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ClassPath
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Defines options for the avro data format
type StreamFormat_AvroFormat struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Optional if used in a File DataSource as schema is embedded in avro file.
        // Specifies the schema of the Avro message as JSON string.
        SchemaJson string `protobuf:"bytes,1,opt,name=schema_json,json=schemaJson,proto3" json:"schema_json,omitempty"`
}

func (x *StreamFormat_AvroFormat) Reset() <span class="cov0" title="0">{
        *x = StreamFormat_AvroFormat{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_DataFormat_proto_msgTypes[5]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *StreamFormat_AvroFormat) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StreamFormat_AvroFormat) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StreamFormat_AvroFormat) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_feast_core_DataFormat_proto_msgTypes[5]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use StreamFormat_AvroFormat.ProtoReflect.Descriptor instead.
func (*StreamFormat_AvroFormat) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_DataFormat_proto_rawDescGZIP(), []int{1, 1}
}</span>

func (x *StreamFormat_AvroFormat) GetSchemaJson() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SchemaJson
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type StreamFormat_JsonFormat struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        SchemaJson string `protobuf:"bytes,1,opt,name=schema_json,json=schemaJson,proto3" json:"schema_json,omitempty"`
}

func (x *StreamFormat_JsonFormat) Reset() <span class="cov0" title="0">{
        *x = StreamFormat_JsonFormat{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_DataFormat_proto_msgTypes[6]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *StreamFormat_JsonFormat) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StreamFormat_JsonFormat) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StreamFormat_JsonFormat) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_feast_core_DataFormat_proto_msgTypes[6]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use StreamFormat_JsonFormat.ProtoReflect.Descriptor instead.
func (*StreamFormat_JsonFormat) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_DataFormat_proto_rawDescGZIP(), []int{1, 2}
}</span>

func (x *StreamFormat_JsonFormat) GetSchemaJson() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SchemaJson
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Confluent Avro fetches schema from a schema registry
type StreamFormat_ConfluentAvroFormat struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        RecordName      string `protobuf:"bytes,1,opt,name=record_name,json=recordName,proto3" json:"record_name,omitempty"`
        RecordNamespace string `protobuf:"bytes,2,opt,name=record_namespace,json=recordNamespace,proto3" json:"record_namespace,omitempty"`
}

func (x *StreamFormat_ConfluentAvroFormat) Reset() <span class="cov0" title="0">{
        *x = StreamFormat_ConfluentAvroFormat{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_DataFormat_proto_msgTypes[7]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *StreamFormat_ConfluentAvroFormat) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StreamFormat_ConfluentAvroFormat) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StreamFormat_ConfluentAvroFormat) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_feast_core_DataFormat_proto_msgTypes[7]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use StreamFormat_ConfluentAvroFormat.ProtoReflect.Descriptor instead.
func (*StreamFormat_ConfluentAvroFormat) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_DataFormat_proto_rawDescGZIP(), []int{1, 3}
}</span>

func (x *StreamFormat_ConfluentAvroFormat) GetRecordName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RecordName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *StreamFormat_ConfluentAvroFormat) GetRecordNamespace() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RecordNamespace
        }</span>
        <span class="cov0" title="0">return ""</span>
}

var File_feast_core_DataFormat_proto protoreflect.FileDescriptor

var file_feast_core_DataFormat_proto_rawDesc = []byte{
        0x0a, 0x1b, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x44, 0x61, 0x74,
        0x61, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0a, 0x66,
        0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x22, 0xce, 0x01, 0x0a, 0x0a, 0x46, 0x69,
        0x6c, 0x65, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x12, 0x4d, 0x0a, 0x0e, 0x70, 0x61, 0x72, 0x71,
        0x75, 0x65, 0x74, 0x5f, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b,
        0x32, 0x24, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x46, 0x69,
        0x6c, 0x65, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x2e, 0x50, 0x61, 0x72, 0x71, 0x75, 0x65, 0x74,
        0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x48, 0x00, 0x52, 0x0d, 0x70, 0x61, 0x72, 0x71, 0x75, 0x65,
        0x74, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x12, 0x47, 0x0a, 0x0c, 0x64, 0x65, 0x6c, 0x74, 0x61,
        0x5f, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x22, 0x2e,
        0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x46, 0x69, 0x6c, 0x65, 0x46,
        0x6f, 0x72, 0x6d, 0x61, 0x74, 0x2e, 0x44, 0x65, 0x6c, 0x74, 0x61, 0x46, 0x6f, 0x72, 0x6d, 0x61,
        0x74, 0x48, 0x00, 0x52, 0x0b, 0x64, 0x65, 0x6c, 0x74, 0x61, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74,
        0x1a, 0x0f, 0x0a, 0x0d, 0x50, 0x61, 0x72, 0x71, 0x75, 0x65, 0x74, 0x46, 0x6f, 0x72, 0x6d, 0x61,
        0x74, 0x1a, 0x0d, 0x0a, 0x0b, 0x44, 0x65, 0x6c, 0x74, 0x61, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74,
        0x42, 0x08, 0x0a, 0x06, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x22, 0xc6, 0x04, 0x0a, 0x0c, 0x53,
        0x74, 0x72, 0x65, 0x61, 0x6d, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x12, 0x46, 0x0a, 0x0b, 0x61,
        0x76, 0x72, 0x6f, 0x5f, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b,
        0x32, 0x23, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x53, 0x74,
        0x72, 0x65, 0x61, 0x6d, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x2e, 0x41, 0x76, 0x72, 0x6f, 0x46,
        0x6f, 0x72, 0x6d, 0x61, 0x74, 0x48, 0x00, 0x52, 0x0a, 0x61, 0x76, 0x72, 0x6f, 0x46, 0x6f, 0x72,
        0x6d, 0x61, 0x74, 0x12, 0x49, 0x0a, 0x0c, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x5f, 0x66, 0x6f, 0x72,
        0x6d, 0x61, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x66, 0x65, 0x61, 0x73,
        0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x46, 0x6f, 0x72,
        0x6d, 0x61, 0x74, 0x2e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x48,
        0x00, 0x52, 0x0b, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x12, 0x46,
        0x0a, 0x0b, 0x6a, 0x73, 0x6f, 0x6e, 0x5f, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x18, 0x03, 0x20,
        0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65,
        0x2e, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x2e, 0x4a, 0x73,
        0x6f, 0x6e, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x48, 0x00, 0x52, 0x0a, 0x6a, 0x73, 0x6f, 0x6e,
        0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x12, 0x62, 0x0a, 0x15, 0x63, 0x6f, 0x6e, 0x66, 0x6c, 0x75,
        0x65, 0x6e, 0x74, 0x5f, 0x61, 0x76, 0x72, 0x6f, 0x5f, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x18,
        0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2c, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f,
        0x72, 0x65, 0x2e, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x2e,
        0x43, 0x6f, 0x6e, 0x66, 0x6c, 0x75, 0x65, 0x6e, 0x74, 0x41, 0x76, 0x72, 0x6f, 0x46, 0x6f, 0x72,
        0x6d, 0x61, 0x74, 0x48, 0x00, 0x52, 0x13, 0x63, 0x6f, 0x6e, 0x66, 0x6c, 0x75, 0x65, 0x6e, 0x74,
        0x41, 0x76, 0x72, 0x6f, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x1a, 0x2c, 0x0a, 0x0b, 0x50, 0x72,
        0x6f, 0x74, 0x6f, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x12, 0x1d, 0x0a, 0x0a, 0x63, 0x6c, 0x61,
        0x73, 0x73, 0x5f, 0x70, 0x61, 0x74, 0x68, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x63,
        0x6c, 0x61, 0x73, 0x73, 0x50, 0x61, 0x74, 0x68, 0x1a, 0x2d, 0x0a, 0x0a, 0x41, 0x76, 0x72, 0x6f,
        0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x12, 0x1f, 0x0a, 0x0b, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61,
        0x5f, 0x6a, 0x73, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x73, 0x63, 0x68,
        0x65, 0x6d, 0x61, 0x4a, 0x73, 0x6f, 0x6e, 0x1a, 0x2d, 0x0a, 0x0a, 0x4a, 0x73, 0x6f, 0x6e, 0x46,
        0x6f, 0x72, 0x6d, 0x61, 0x74, 0x12, 0x1f, 0x0a, 0x0b, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x5f,
        0x6a, 0x73, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x73, 0x63, 0x68, 0x65,
        0x6d, 0x61, 0x4a, 0x73, 0x6f, 0x6e, 0x1a, 0x61, 0x0a, 0x13, 0x43, 0x6f, 0x6e, 0x66, 0x6c, 0x75,
        0x65, 0x6e, 0x74, 0x41, 0x76, 0x72, 0x6f, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x12, 0x1f, 0x0a,
        0x0b, 0x72, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x0a, 0x72, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x29,
        0x0a, 0x10, 0x72, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61,
        0x63, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0f, 0x72, 0x65, 0x63, 0x6f, 0x72, 0x64,
        0x4e, 0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x42, 0x08, 0x0a, 0x06, 0x66, 0x6f, 0x72,
        0x6d, 0x61, 0x74, 0x42, 0x54, 0x0a, 0x10, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x42, 0x0f, 0x44, 0x61, 0x74, 0x61, 0x46, 0x6f, 0x72,
        0x6d, 0x61, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x5a, 0x2f, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62,
        0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2d, 0x64, 0x65, 0x76, 0x2f, 0x66,
        0x65, 0x61, 0x73, 0x74, 0x2f, 0x67, 0x6f, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x73, 0x2f, 0x66,
        0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x33,
}

var (
        file_feast_core_DataFormat_proto_rawDescOnce sync.Once
        file_feast_core_DataFormat_proto_rawDescData = file_feast_core_DataFormat_proto_rawDesc
)

func file_feast_core_DataFormat_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_feast_core_DataFormat_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_feast_core_DataFormat_proto_rawDescData = protoimpl.X.CompressGZIP(file_feast_core_DataFormat_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_feast_core_DataFormat_proto_rawDescData</span>
}

var file_feast_core_DataFormat_proto_msgTypes = make([]protoimpl.MessageInfo, 8)
var file_feast_core_DataFormat_proto_goTypes = []interface{}{
        (*FileFormat)(nil),                       // 0: feast.core.FileFormat
        (*StreamFormat)(nil),                     // 1: feast.core.StreamFormat
        (*FileFormat_ParquetFormat)(nil),         // 2: feast.core.FileFormat.ParquetFormat
        (*FileFormat_DeltaFormat)(nil),           // 3: feast.core.FileFormat.DeltaFormat
        (*StreamFormat_ProtoFormat)(nil),         // 4: feast.core.StreamFormat.ProtoFormat
        (*StreamFormat_AvroFormat)(nil),          // 5: feast.core.StreamFormat.AvroFormat
        (*StreamFormat_JsonFormat)(nil),          // 6: feast.core.StreamFormat.JsonFormat
        (*StreamFormat_ConfluentAvroFormat)(nil), // 7: feast.core.StreamFormat.ConfluentAvroFormat
}
var file_feast_core_DataFormat_proto_depIdxs = []int32{
        2, // 0: feast.core.FileFormat.parquet_format:type_name -&gt; feast.core.FileFormat.ParquetFormat
        3, // 1: feast.core.FileFormat.delta_format:type_name -&gt; feast.core.FileFormat.DeltaFormat
        5, // 2: feast.core.StreamFormat.avro_format:type_name -&gt; feast.core.StreamFormat.AvroFormat
        4, // 3: feast.core.StreamFormat.proto_format:type_name -&gt; feast.core.StreamFormat.ProtoFormat
        6, // 4: feast.core.StreamFormat.json_format:type_name -&gt; feast.core.StreamFormat.JsonFormat
        7, // 5: feast.core.StreamFormat.confluent_avro_format:type_name -&gt; feast.core.StreamFormat.ConfluentAvroFormat
        6, // [6:6] is the sub-list for method output_type
        6, // [6:6] is the sub-list for method input_type
        6, // [6:6] is the sub-list for extension type_name
        6, // [6:6] is the sub-list for extension extendee
        0, // [0:6] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_feast_core_DataFormat_proto_init() }</span>
func file_feast_core_DataFormat_proto_init() <span class="cov8" title="1">{
        if File_feast_core_DataFormat_proto != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_feast_core_DataFormat_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*FileFormat); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_DataFormat_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*StreamFormat); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_DataFormat_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*FileFormat_ParquetFormat); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_DataFormat_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*FileFormat_DeltaFormat); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_DataFormat_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*StreamFormat_ProtoFormat); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_DataFormat_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*StreamFormat_AvroFormat); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_DataFormat_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*StreamFormat_JsonFormat); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_DataFormat_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*StreamFormat_ConfluentAvroFormat); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">file_feast_core_DataFormat_proto_msgTypes[0].OneofWrappers = []interface{}{
                (*FileFormat_ParquetFormat_)(nil),
                (*FileFormat_DeltaFormat_)(nil),
        }
        file_feast_core_DataFormat_proto_msgTypes[1].OneofWrappers = []interface{}{
                (*StreamFormat_AvroFormat_)(nil),
                (*StreamFormat_ProtoFormat_)(nil),
                (*StreamFormat_JsonFormat_)(nil),
                (*StreamFormat_ConfluentAvroFormat_)(nil),
        }
        type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_feast_core_DataFormat_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   8,
                        NumExtensions: 0,
                        NumServices:   0,
                },
                GoTypes:           file_feast_core_DataFormat_proto_goTypes,
                DependencyIndexes: file_feast_core_DataFormat_proto_depIdxs,
                MessageInfos:      file_feast_core_DataFormat_proto_msgTypes,
        }.Build()
        File_feast_core_DataFormat_proto = out.File
        file_feast_core_DataFormat_proto_rawDesc = nil
        file_feast_core_DataFormat_proto_goTypes = nil
        file_feast_core_DataFormat_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">//
// Copyright 2020 The Feast Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.31.0
//         protoc        v4.25.1
// source: feast/core/DataSource.proto

package core

import (
        types "github.com/feast-dev/feast/go/protos/feast/types"
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        durationpb "google.golang.org/protobuf/types/known/durationpb"
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Type of Data Source.
// Next available id: 12
type DataSource_SourceType int32

const (
        DataSource_INVALID         DataSource_SourceType = 0
        DataSource_BATCH_FILE      DataSource_SourceType = 1
        DataSource_BATCH_SNOWFLAKE DataSource_SourceType = 8
        DataSource_BATCH_BIGQUERY  DataSource_SourceType = 2
        DataSource_BATCH_REDSHIFT  DataSource_SourceType = 5
        DataSource_STREAM_KAFKA    DataSource_SourceType = 3
        DataSource_STREAM_KINESIS  DataSource_SourceType = 4
        DataSource_CUSTOM_SOURCE   DataSource_SourceType = 6
        DataSource_REQUEST_SOURCE  DataSource_SourceType = 7
        DataSource_PUSH_SOURCE     DataSource_SourceType = 9
        DataSource_BATCH_TRINO     DataSource_SourceType = 10
        DataSource_BATCH_SPARK     DataSource_SourceType = 11
        DataSource_BATCH_ATHENA    DataSource_SourceType = 12
)

// Enum value maps for DataSource_SourceType.
var (
        DataSource_SourceType_name = map[int32]string{
                0:  "INVALID",
                1:  "BATCH_FILE",
                8:  "BATCH_SNOWFLAKE",
                2:  "BATCH_BIGQUERY",
                5:  "BATCH_REDSHIFT",
                3:  "STREAM_KAFKA",
                4:  "STREAM_KINESIS",
                6:  "CUSTOM_SOURCE",
                7:  "REQUEST_SOURCE",
                9:  "PUSH_SOURCE",
                10: "BATCH_TRINO",
                11: "BATCH_SPARK",
                12: "BATCH_ATHENA",
        }
        DataSource_SourceType_value = map[string]int32{
                "INVALID":         0,
                "BATCH_FILE":      1,
                "BATCH_SNOWFLAKE": 8,
                "BATCH_BIGQUERY":  2,
                "BATCH_REDSHIFT":  5,
                "STREAM_KAFKA":    3,
                "STREAM_KINESIS":  4,
                "CUSTOM_SOURCE":   6,
                "REQUEST_SOURCE":  7,
                "PUSH_SOURCE":     9,
                "BATCH_TRINO":     10,
                "BATCH_SPARK":     11,
                "BATCH_ATHENA":    12,
        }
)

func (x DataSource_SourceType) Enum() *DataSource_SourceType <span class="cov0" title="0">{
        p := new(DataSource_SourceType)
        *p = x
        return p
}</span>

func (x DataSource_SourceType) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (DataSource_SourceType) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_feast_core_DataSource_proto_enumTypes[0].Descriptor()
}</span>

func (DataSource_SourceType) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_feast_core_DataSource_proto_enumTypes[0]
}</span>

func (x DataSource_SourceType) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use DataSource_SourceType.Descriptor instead.
func (DataSource_SourceType) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_DataSource_proto_rawDescGZIP(), []int{0, 0}
}</span>

// Defines a Data Source that can be used source Feature data
// Next available id: 28
type DataSource struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Unique name of data source within the project
        Name string `protobuf:"bytes,20,opt,name=name,proto3" json:"name,omitempty"`
        // Name of Feast project that this data source belongs to.
        Project     string                `protobuf:"bytes,21,opt,name=project,proto3" json:"project,omitempty"`
        Description string                `protobuf:"bytes,23,opt,name=description,proto3" json:"description,omitempty"`
        Tags        map[string]string     `protobuf:"bytes,24,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        Owner       string                `protobuf:"bytes,25,opt,name=owner,proto3" json:"owner,omitempty"`
        Type        DataSource_SourceType `protobuf:"varint,1,opt,name=type,proto3,enum=feast.core.DataSource_SourceType" json:"type,omitempty"`
        // Defines mapping between fields in the sourced data
        // and fields in parent FeatureTable.
        FieldMapping map[string]string `protobuf:"bytes,2,rep,name=field_mapping,json=fieldMapping,proto3" json:"field_mapping,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        // Must specify event timestamp column name
        TimestampField string `protobuf:"bytes,3,opt,name=timestamp_field,json=timestampField,proto3" json:"timestamp_field,omitempty"`
        // (Optional) Specify partition column
        // useful for file sources
        DatePartitionColumn string `protobuf:"bytes,4,opt,name=date_partition_column,json=datePartitionColumn,proto3" json:"date_partition_column,omitempty"`
        // Must specify creation timestamp column name
        CreatedTimestampColumn string `protobuf:"bytes,5,opt,name=created_timestamp_column,json=createdTimestampColumn,proto3" json:"created_timestamp_column,omitempty"`
        // This is an internal field that is represents the python class for the data source object a proto object represents.
        // This should be set by feast, and not by users.
        // The field is used primarily by custom data sources and is mandatory for them to set. Feast may set it for
        // first party sources as well.
        DataSourceClassType string `protobuf:"bytes,17,opt,name=data_source_class_type,json=dataSourceClassType,proto3" json:"data_source_class_type,omitempty"`
        // Optional batch source for streaming sources for historical features and materialization.
        BatchSource *DataSource            `protobuf:"bytes,26,opt,name=batch_source,json=batchSource,proto3" json:"batch_source,omitempty"`
        Meta        *DataSource_SourceMeta `protobuf:"bytes,50,opt,name=meta,proto3" json:"meta,omitempty"`
        // DataSource options.
        //
        // Types that are assignable to Options:
        //
        //        *DataSource_FileOptions_
        //        *DataSource_BigqueryOptions
        //        *DataSource_KafkaOptions_
        //        *DataSource_KinesisOptions_
        //        *DataSource_RedshiftOptions_
        //        *DataSource_RequestDataOptions_
        //        *DataSource_CustomOptions
        //        *DataSource_SnowflakeOptions_
        //        *DataSource_PushOptions_
        //        *DataSource_SparkOptions_
        //        *DataSource_TrinoOptions_
        //        *DataSource_AthenaOptions_
        Options isDataSource_Options `protobuf_oneof:"options"`
}

func (x *DataSource) Reset() <span class="cov0" title="0">{
        *x = DataSource{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_DataSource_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DataSource) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DataSource) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DataSource) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_DataSource_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use DataSource.ProtoReflect.Descriptor instead.
func (*DataSource) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_DataSource_proto_rawDescGZIP(), []int{0}
}</span>

func (x *DataSource) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DataSource) GetProject() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Project
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DataSource) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DataSource) GetTags() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tags
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DataSource) GetOwner() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Owner
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DataSource) GetType() DataSource_SourceType <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return DataSource_INVALID</span>
}

func (x *DataSource) GetFieldMapping() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FieldMapping
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DataSource) GetTimestampField() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TimestampField
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DataSource) GetDatePartitionColumn() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DatePartitionColumn
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DataSource) GetCreatedTimestampColumn() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedTimestampColumn
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DataSource) GetDataSourceClassType() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DataSourceClassType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DataSource) GetBatchSource() *DataSource <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.BatchSource
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DataSource) GetMeta() *DataSource_SourceMeta <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Meta
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *DataSource) GetOptions() isDataSource_Options <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Options
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DataSource) GetFileOptions() *DataSource_FileOptions <span class="cov0" title="0">{
        if x, ok := x.GetOptions().(*DataSource_FileOptions_); ok </span><span class="cov0" title="0">{
                return x.FileOptions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DataSource) GetBigqueryOptions() *DataSource_BigQueryOptions <span class="cov0" title="0">{
        if x, ok := x.GetOptions().(*DataSource_BigqueryOptions); ok </span><span class="cov0" title="0">{
                return x.BigqueryOptions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DataSource) GetKafkaOptions() *DataSource_KafkaOptions <span class="cov0" title="0">{
        if x, ok := x.GetOptions().(*DataSource_KafkaOptions_); ok </span><span class="cov0" title="0">{
                return x.KafkaOptions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DataSource) GetKinesisOptions() *DataSource_KinesisOptions <span class="cov0" title="0">{
        if x, ok := x.GetOptions().(*DataSource_KinesisOptions_); ok </span><span class="cov0" title="0">{
                return x.KinesisOptions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DataSource) GetRedshiftOptions() *DataSource_RedshiftOptions <span class="cov0" title="0">{
        if x, ok := x.GetOptions().(*DataSource_RedshiftOptions_); ok </span><span class="cov0" title="0">{
                return x.RedshiftOptions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DataSource) GetRequestDataOptions() *DataSource_RequestDataOptions <span class="cov0" title="0">{
        if x, ok := x.GetOptions().(*DataSource_RequestDataOptions_); ok </span><span class="cov0" title="0">{
                return x.RequestDataOptions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DataSource) GetCustomOptions() *DataSource_CustomSourceOptions <span class="cov0" title="0">{
        if x, ok := x.GetOptions().(*DataSource_CustomOptions); ok </span><span class="cov0" title="0">{
                return x.CustomOptions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DataSource) GetSnowflakeOptions() *DataSource_SnowflakeOptions <span class="cov0" title="0">{
        if x, ok := x.GetOptions().(*DataSource_SnowflakeOptions_); ok </span><span class="cov0" title="0">{
                return x.SnowflakeOptions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DataSource) GetPushOptions() *DataSource_PushOptions <span class="cov0" title="0">{
        if x, ok := x.GetOptions().(*DataSource_PushOptions_); ok </span><span class="cov0" title="0">{
                return x.PushOptions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DataSource) GetSparkOptions() *DataSource_SparkOptions <span class="cov0" title="0">{
        if x, ok := x.GetOptions().(*DataSource_SparkOptions_); ok </span><span class="cov0" title="0">{
                return x.SparkOptions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DataSource) GetTrinoOptions() *DataSource_TrinoOptions <span class="cov0" title="0">{
        if x, ok := x.GetOptions().(*DataSource_TrinoOptions_); ok </span><span class="cov0" title="0">{
                return x.TrinoOptions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DataSource) GetAthenaOptions() *DataSource_AthenaOptions <span class="cov0" title="0">{
        if x, ok := x.GetOptions().(*DataSource_AthenaOptions_); ok </span><span class="cov0" title="0">{
                return x.AthenaOptions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type isDataSource_Options interface {
        isDataSource_Options()
}

type DataSource_FileOptions_ struct {
        FileOptions *DataSource_FileOptions `protobuf:"bytes,11,opt,name=file_options,json=fileOptions,proto3,oneof"`
}

type DataSource_BigqueryOptions struct {
        BigqueryOptions *DataSource_BigQueryOptions `protobuf:"bytes,12,opt,name=bigquery_options,json=bigqueryOptions,proto3,oneof"`
}

type DataSource_KafkaOptions_ struct {
        KafkaOptions *DataSource_KafkaOptions `protobuf:"bytes,13,opt,name=kafka_options,json=kafkaOptions,proto3,oneof"`
}

type DataSource_KinesisOptions_ struct {
        KinesisOptions *DataSource_KinesisOptions `protobuf:"bytes,14,opt,name=kinesis_options,json=kinesisOptions,proto3,oneof"`
}

type DataSource_RedshiftOptions_ struct {
        RedshiftOptions *DataSource_RedshiftOptions `protobuf:"bytes,15,opt,name=redshift_options,json=redshiftOptions,proto3,oneof"`
}

type DataSource_RequestDataOptions_ struct {
        RequestDataOptions *DataSource_RequestDataOptions `protobuf:"bytes,18,opt,name=request_data_options,json=requestDataOptions,proto3,oneof"`
}

type DataSource_CustomOptions struct {
        CustomOptions *DataSource_CustomSourceOptions `protobuf:"bytes,16,opt,name=custom_options,json=customOptions,proto3,oneof"`
}

type DataSource_SnowflakeOptions_ struct {
        SnowflakeOptions *DataSource_SnowflakeOptions `protobuf:"bytes,19,opt,name=snowflake_options,json=snowflakeOptions,proto3,oneof"`
}

type DataSource_PushOptions_ struct {
        PushOptions *DataSource_PushOptions `protobuf:"bytes,22,opt,name=push_options,json=pushOptions,proto3,oneof"`
}

type DataSource_SparkOptions_ struct {
        SparkOptions *DataSource_SparkOptions `protobuf:"bytes,27,opt,name=spark_options,json=sparkOptions,proto3,oneof"`
}

type DataSource_TrinoOptions_ struct {
        TrinoOptions *DataSource_TrinoOptions `protobuf:"bytes,30,opt,name=trino_options,json=trinoOptions,proto3,oneof"`
}

type DataSource_AthenaOptions_ struct {
        AthenaOptions *DataSource_AthenaOptions `protobuf:"bytes,35,opt,name=athena_options,json=athenaOptions,proto3,oneof"`
}

func (*DataSource_FileOptions_) isDataSource_Options() {<span class="cov0" title="0">}</span>

func (*DataSource_BigqueryOptions) isDataSource_Options() {<span class="cov0" title="0">}</span>

func (*DataSource_KafkaOptions_) isDataSource_Options() {<span class="cov0" title="0">}</span>

func (*DataSource_KinesisOptions_) isDataSource_Options() {<span class="cov0" title="0">}</span>

func (*DataSource_RedshiftOptions_) isDataSource_Options() {<span class="cov0" title="0">}</span>

func (*DataSource_RequestDataOptions_) isDataSource_Options() {<span class="cov0" title="0">}</span>

func (*DataSource_CustomOptions) isDataSource_Options() {<span class="cov0" title="0">}</span>

func (*DataSource_SnowflakeOptions_) isDataSource_Options() {<span class="cov0" title="0">}</span>

func (*DataSource_PushOptions_) isDataSource_Options() {<span class="cov0" title="0">}</span>

func (*DataSource_SparkOptions_) isDataSource_Options() {<span class="cov0" title="0">}</span>

func (*DataSource_TrinoOptions_) isDataSource_Options() {<span class="cov0" title="0">}</span>

func (*DataSource_AthenaOptions_) isDataSource_Options() {<span class="cov0" title="0">}</span>

type DataSourceList struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Datasources []*DataSource `protobuf:"bytes,1,rep,name=datasources,proto3" json:"datasources,omitempty"`
}

func (x *DataSourceList) Reset() <span class="cov8" title="1">{
        *x = DataSourceList{}
        if protoimpl.UnsafeEnabled </span><span class="cov8" title="1">{
                mi := &amp;file_feast_core_DataSource_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DataSourceList) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DataSourceList) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DataSourceList) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_DataSource_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov8" title="1">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov8" title="1">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov8" title="1">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use DataSourceList.ProtoReflect.Descriptor instead.
func (*DataSourceList) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_DataSource_proto_rawDescGZIP(), []int{1}
}</span>

func (x *DataSourceList) GetDatasources() []*DataSource <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.Datasources
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type DataSource_SourceMeta struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        EarliestEventTimestamp *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=earliestEventTimestamp,proto3" json:"earliestEventTimestamp,omitempty"`
        LatestEventTimestamp   *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=latestEventTimestamp,proto3" json:"latestEventTimestamp,omitempty"`
}

func (x *DataSource_SourceMeta) Reset() <span class="cov0" title="0">{
        *x = DataSource_SourceMeta{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_DataSource_proto_msgTypes[4]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DataSource_SourceMeta) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DataSource_SourceMeta) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DataSource_SourceMeta) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_DataSource_proto_msgTypes[4]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use DataSource_SourceMeta.ProtoReflect.Descriptor instead.
func (*DataSource_SourceMeta) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_DataSource_proto_rawDescGZIP(), []int{0, 2}
}</span>

func (x *DataSource_SourceMeta) GetEarliestEventTimestamp() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.EarliestEventTimestamp
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DataSource_SourceMeta) GetLatestEventTimestamp() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LatestEventTimestamp
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Defines options for DataSource that sources features from a file
type DataSource_FileOptions struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        FileFormat *FileFormat `protobuf:"bytes,1,opt,name=file_format,json=fileFormat,proto3" json:"file_format,omitempty"`
        // Target URL of file to retrieve and source features from.
        // s3://path/to/file for AWS S3 storage
        // gs://path/to/file for GCP GCS storage
        // file:///path/to/file for local storage
        Uri string `protobuf:"bytes,2,opt,name=uri,proto3" json:"uri,omitempty"`
        // override AWS S3 storage endpoint with custom S3 endpoint
        S3EndpointOverride string `protobuf:"bytes,3,opt,name=s3_endpoint_override,json=s3EndpointOverride,proto3" json:"s3_endpoint_override,omitempty"`
}

func (x *DataSource_FileOptions) Reset() <span class="cov0" title="0">{
        *x = DataSource_FileOptions{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_DataSource_proto_msgTypes[5]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DataSource_FileOptions) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DataSource_FileOptions) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DataSource_FileOptions) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_DataSource_proto_msgTypes[5]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use DataSource_FileOptions.ProtoReflect.Descriptor instead.
func (*DataSource_FileOptions) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_DataSource_proto_rawDescGZIP(), []int{0, 3}
}</span>

func (x *DataSource_FileOptions) GetFileFormat() *FileFormat <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FileFormat
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DataSource_FileOptions) GetUri() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Uri
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DataSource_FileOptions) GetS3EndpointOverride() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.S3EndpointOverride
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Defines options for DataSource that sources features from a BigQuery Query
type DataSource_BigQueryOptions struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Full table reference in the form of [project:dataset.table]
        Table string `protobuf:"bytes,1,opt,name=table,proto3" json:"table,omitempty"`
        // SQL query that returns a table containing feature data. Must contain an event_timestamp column, and respective
        // entity columns
        Query string `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
}

func (x *DataSource_BigQueryOptions) Reset() <span class="cov0" title="0">{
        *x = DataSource_BigQueryOptions{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_DataSource_proto_msgTypes[6]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DataSource_BigQueryOptions) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DataSource_BigQueryOptions) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DataSource_BigQueryOptions) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_DataSource_proto_msgTypes[6]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use DataSource_BigQueryOptions.ProtoReflect.Descriptor instead.
func (*DataSource_BigQueryOptions) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_DataSource_proto_rawDescGZIP(), []int{0, 4}
}</span>

func (x *DataSource_BigQueryOptions) GetTable() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Table
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DataSource_BigQueryOptions) GetQuery() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Query
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Defines options for DataSource that sources features from a Trino Query
type DataSource_TrinoOptions struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Full table reference in the form of [project:dataset.table]
        Table string `protobuf:"bytes,1,opt,name=table,proto3" json:"table,omitempty"`
        // SQL query that returns a table containing feature data. Must contain an event_timestamp column, and respective
        // entity columns
        Query string `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
}

func (x *DataSource_TrinoOptions) Reset() <span class="cov0" title="0">{
        *x = DataSource_TrinoOptions{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_DataSource_proto_msgTypes[7]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DataSource_TrinoOptions) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DataSource_TrinoOptions) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DataSource_TrinoOptions) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_DataSource_proto_msgTypes[7]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use DataSource_TrinoOptions.ProtoReflect.Descriptor instead.
func (*DataSource_TrinoOptions) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_DataSource_proto_rawDescGZIP(), []int{0, 5}
}</span>

func (x *DataSource_TrinoOptions) GetTable() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Table
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DataSource_TrinoOptions) GetQuery() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Query
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Defines options for DataSource that sources features from Kafka messages.
// Each message should be a Protobuf that can be decoded with the generated
// Java Protobuf class at the given class path
type DataSource_KafkaOptions struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Comma separated list of Kafka bootstrap servers. Used for feature tables without a defined source host[:port]]
        KafkaBootstrapServers string `protobuf:"bytes,1,opt,name=kafka_bootstrap_servers,json=kafkaBootstrapServers,proto3" json:"kafka_bootstrap_servers,omitempty"`
        // Kafka topic to collect feature data from.
        Topic string `protobuf:"bytes,2,opt,name=topic,proto3" json:"topic,omitempty"`
        // Defines the stream data format encoding feature/entity data in Kafka messages.
        MessageFormat *StreamFormat `protobuf:"bytes,3,opt,name=message_format,json=messageFormat,proto3" json:"message_format,omitempty"`
        // Watermark delay threshold for stream data
        WatermarkDelayThreshold *durationpb.Duration `protobuf:"bytes,4,opt,name=watermark_delay_threshold,json=watermarkDelayThreshold,proto3" json:"watermark_delay_threshold,omitempty"`
}

func (x *DataSource_KafkaOptions) Reset() <span class="cov0" title="0">{
        *x = DataSource_KafkaOptions{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_DataSource_proto_msgTypes[8]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DataSource_KafkaOptions) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DataSource_KafkaOptions) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DataSource_KafkaOptions) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_DataSource_proto_msgTypes[8]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use DataSource_KafkaOptions.ProtoReflect.Descriptor instead.
func (*DataSource_KafkaOptions) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_DataSource_proto_rawDescGZIP(), []int{0, 6}
}</span>

func (x *DataSource_KafkaOptions) GetKafkaBootstrapServers() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.KafkaBootstrapServers
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DataSource_KafkaOptions) GetTopic() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Topic
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DataSource_KafkaOptions) GetMessageFormat() *StreamFormat <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MessageFormat
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DataSource_KafkaOptions) GetWatermarkDelayThreshold() *durationpb.Duration <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.WatermarkDelayThreshold
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Defines options for DataSource that sources features from Kinesis records.
// Each record should be a Protobuf that can be decoded with the generated
// Java Protobuf class at the given class path
type DataSource_KinesisOptions struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // AWS region of the Kinesis stream
        Region string `protobuf:"bytes,1,opt,name=region,proto3" json:"region,omitempty"`
        // Name of the Kinesis stream to obtain feature data from.
        StreamName string `protobuf:"bytes,2,opt,name=stream_name,json=streamName,proto3" json:"stream_name,omitempty"`
        // Defines the data format encoding the feature/entity data in Kinesis records.
        // Kinesis Data Sources support Avro and Proto as data formats.
        RecordFormat *StreamFormat `protobuf:"bytes,3,opt,name=record_format,json=recordFormat,proto3" json:"record_format,omitempty"`
}

func (x *DataSource_KinesisOptions) Reset() <span class="cov0" title="0">{
        *x = DataSource_KinesisOptions{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_DataSource_proto_msgTypes[9]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DataSource_KinesisOptions) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DataSource_KinesisOptions) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DataSource_KinesisOptions) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_DataSource_proto_msgTypes[9]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use DataSource_KinesisOptions.ProtoReflect.Descriptor instead.
func (*DataSource_KinesisOptions) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_DataSource_proto_rawDescGZIP(), []int{0, 7}
}</span>

func (x *DataSource_KinesisOptions) GetRegion() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Region
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DataSource_KinesisOptions) GetStreamName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.StreamName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DataSource_KinesisOptions) GetRecordFormat() *StreamFormat <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RecordFormat
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Defines options for DataSource that sources features from a Redshift Query
type DataSource_RedshiftOptions struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Redshift table name
        Table string `protobuf:"bytes,1,opt,name=table,proto3" json:"table,omitempty"`
        // SQL query that returns a table containing feature data. Must contain an event_timestamp column, and respective
        // entity columns
        Query string `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
        // Redshift schema name
        Schema string `protobuf:"bytes,3,opt,name=schema,proto3" json:"schema,omitempty"`
        // Redshift database name
        Database string `protobuf:"bytes,4,opt,name=database,proto3" json:"database,omitempty"`
}

func (x *DataSource_RedshiftOptions) Reset() <span class="cov0" title="0">{
        *x = DataSource_RedshiftOptions{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_DataSource_proto_msgTypes[10]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DataSource_RedshiftOptions) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DataSource_RedshiftOptions) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DataSource_RedshiftOptions) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_DataSource_proto_msgTypes[10]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use DataSource_RedshiftOptions.ProtoReflect.Descriptor instead.
func (*DataSource_RedshiftOptions) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_DataSource_proto_rawDescGZIP(), []int{0, 8}
}</span>

func (x *DataSource_RedshiftOptions) GetTable() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Table
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DataSource_RedshiftOptions) GetQuery() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Query
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DataSource_RedshiftOptions) GetSchema() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Schema
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DataSource_RedshiftOptions) GetDatabase() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Database
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Defines options for DataSource that sources features from a Athena Query
type DataSource_AthenaOptions struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Athena table name
        Table string `protobuf:"bytes,1,opt,name=table,proto3" json:"table,omitempty"`
        // SQL query that returns a table containing feature data. Must contain an event_timestamp column, and respective
        // entity columns
        Query string `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
        // Athena database name
        Database string `protobuf:"bytes,3,opt,name=database,proto3" json:"database,omitempty"`
        // Athena schema name
        DataSource string `protobuf:"bytes,4,opt,name=data_source,json=dataSource,proto3" json:"data_source,omitempty"`
}

func (x *DataSource_AthenaOptions) Reset() <span class="cov0" title="0">{
        *x = DataSource_AthenaOptions{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_DataSource_proto_msgTypes[11]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DataSource_AthenaOptions) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DataSource_AthenaOptions) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DataSource_AthenaOptions) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_DataSource_proto_msgTypes[11]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use DataSource_AthenaOptions.ProtoReflect.Descriptor instead.
func (*DataSource_AthenaOptions) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_DataSource_proto_rawDescGZIP(), []int{0, 9}
}</span>

func (x *DataSource_AthenaOptions) GetTable() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Table
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DataSource_AthenaOptions) GetQuery() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Query
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DataSource_AthenaOptions) GetDatabase() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Database
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DataSource_AthenaOptions) GetDataSource() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DataSource
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Defines options for DataSource that sources features from a Snowflake Query
type DataSource_SnowflakeOptions struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Snowflake table name
        Table string `protobuf:"bytes,1,opt,name=table,proto3" json:"table,omitempty"`
        // SQL query that returns a table containing feature data. Must contain an event_timestamp column, and respective
        // entity columns
        Query string `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
        // Snowflake schema name
        Schema string `protobuf:"bytes,3,opt,name=schema,proto3" json:"schema,omitempty"`
        // Snowflake schema name
        Database string `protobuf:"bytes,4,opt,name=database,proto3" json:"database,omitempty"`
}

func (x *DataSource_SnowflakeOptions) Reset() <span class="cov0" title="0">{
        *x = DataSource_SnowflakeOptions{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_DataSource_proto_msgTypes[12]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DataSource_SnowflakeOptions) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DataSource_SnowflakeOptions) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DataSource_SnowflakeOptions) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_DataSource_proto_msgTypes[12]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use DataSource_SnowflakeOptions.ProtoReflect.Descriptor instead.
func (*DataSource_SnowflakeOptions) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_DataSource_proto_rawDescGZIP(), []int{0, 10}
}</span>

func (x *DataSource_SnowflakeOptions) GetTable() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Table
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DataSource_SnowflakeOptions) GetQuery() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Query
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DataSource_SnowflakeOptions) GetSchema() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Schema
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DataSource_SnowflakeOptions) GetDatabase() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Database
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Defines options for DataSource that sources features from a spark table/query
type DataSource_SparkOptions struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Table name
        Table string `protobuf:"bytes,1,opt,name=table,proto3" json:"table,omitempty"`
        // Spark SQl query that returns the table, this is an alternative to `table`
        Query string `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty"`
        // Path from which spark can read the table, this is an alternative to `table`
        Path string `protobuf:"bytes,3,opt,name=path,proto3" json:"path,omitempty"`
        // Format of files at `path` (e.g. parquet, avro, etc)
        FileFormat string `protobuf:"bytes,4,opt,name=file_format,json=fileFormat,proto3" json:"file_format,omitempty"`
}

func (x *DataSource_SparkOptions) Reset() <span class="cov0" title="0">{
        *x = DataSource_SparkOptions{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_DataSource_proto_msgTypes[13]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DataSource_SparkOptions) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DataSource_SparkOptions) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DataSource_SparkOptions) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_DataSource_proto_msgTypes[13]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use DataSource_SparkOptions.ProtoReflect.Descriptor instead.
func (*DataSource_SparkOptions) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_DataSource_proto_rawDescGZIP(), []int{0, 11}
}</span>

func (x *DataSource_SparkOptions) GetTable() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Table
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DataSource_SparkOptions) GetQuery() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Query
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DataSource_SparkOptions) GetPath() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Path
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DataSource_SparkOptions) GetFileFormat() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FileFormat
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Defines configuration for custom third-party data sources.
type DataSource_CustomSourceOptions struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Serialized configuration information for the data source. The implementer of the custom data source is
        // responsible for serializing and deserializing data from bytes
        Configuration []byte `protobuf:"bytes,1,opt,name=configuration,proto3" json:"configuration,omitempty"`
}

func (x *DataSource_CustomSourceOptions) Reset() <span class="cov0" title="0">{
        *x = DataSource_CustomSourceOptions{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_DataSource_proto_msgTypes[14]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DataSource_CustomSourceOptions) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DataSource_CustomSourceOptions) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DataSource_CustomSourceOptions) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_DataSource_proto_msgTypes[14]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use DataSource_CustomSourceOptions.ProtoReflect.Descriptor instead.
func (*DataSource_CustomSourceOptions) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_DataSource_proto_rawDescGZIP(), []int{0, 12}
}</span>

func (x *DataSource_CustomSourceOptions) GetConfiguration() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Configuration
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Defines options for DataSource that sources features from request data
type DataSource_RequestDataOptions struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Mapping of feature name to type
        DeprecatedSchema map[string]types.ValueType_Enum `protobuf:"bytes,2,rep,name=deprecated_schema,json=deprecatedSchema,proto3" json:"deprecated_schema,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3,enum=feast.types.ValueType_Enum"`
        Schema           []*FeatureSpecV2                `protobuf:"bytes,3,rep,name=schema,proto3" json:"schema,omitempty"`
}

func (x *DataSource_RequestDataOptions) Reset() <span class="cov0" title="0">{
        *x = DataSource_RequestDataOptions{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_DataSource_proto_msgTypes[15]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DataSource_RequestDataOptions) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DataSource_RequestDataOptions) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DataSource_RequestDataOptions) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_DataSource_proto_msgTypes[15]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use DataSource_RequestDataOptions.ProtoReflect.Descriptor instead.
func (*DataSource_RequestDataOptions) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_DataSource_proto_rawDescGZIP(), []int{0, 13}
}</span>

func (x *DataSource_RequestDataOptions) GetDeprecatedSchema() map[string]types.ValueType_Enum <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DeprecatedSchema
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DataSource_RequestDataOptions) GetSchema() []*FeatureSpecV2 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Schema
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Defines options for DataSource that supports pushing data to it. This allows data to be pushed to
// the online store on-demand, such as by stream consumers.
type DataSource_PushOptions struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *DataSource_PushOptions) Reset() <span class="cov0" title="0">{
        *x = DataSource_PushOptions{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_DataSource_proto_msgTypes[16]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DataSource_PushOptions) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DataSource_PushOptions) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DataSource_PushOptions) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_DataSource_proto_msgTypes[16]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use DataSource_PushOptions.ProtoReflect.Descriptor instead.
func (*DataSource_PushOptions) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_DataSource_proto_rawDescGZIP(), []int{0, 14}
}</span>

var File_feast_core_DataSource_proto protoreflect.FileDescriptor

var file_feast_core_DataSource_proto_rawDesc = []byte{
        0x0a, 0x1b, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x44, 0x61, 0x74,
        0x61, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0a, 0x66,
        0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x1a, 0x1e, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
        0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x64, 0x75, 0x72, 0x61, 0x74,
        0x69, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1f, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
        0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x74, 0x69, 0x6d, 0x65, 0x73,
        0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1b, 0x66, 0x65, 0x61, 0x73,
        0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x44, 0x61, 0x74, 0x61, 0x46, 0x6f, 0x72, 0x6d, 0x61,
        0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x17, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x74,
        0x79, 0x70, 0x65, 0x73, 0x2f, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x1a, 0x18, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x46, 0x65, 0x61,
        0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xc6, 0x1c, 0x0a, 0x0a, 0x44,
        0x61, 0x74, 0x61, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d,
        0x65, 0x18, 0x14, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x18, 0x0a,
        0x07, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x18, 0x15, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07,
        0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72,
        0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x17, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65,
        0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x34, 0x0a, 0x04, 0x74, 0x61, 0x67,
        0x73, 0x18, 0x18, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e,
        0x63, 0x6f, 0x72, 0x65, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e,
        0x54, 0x61, 0x67, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x04, 0x74, 0x61, 0x67, 0x73, 0x12,
        0x14, 0x0a, 0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x18, 0x19, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05,
        0x6f, 0x77, 0x6e, 0x65, 0x72, 0x12, 0x35, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x0e, 0x32, 0x21, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65,
        0x2e, 0x44, 0x61, 0x74, 0x61, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x53, 0x6f, 0x75, 0x72,
        0x63, 0x65, 0x54, 0x79, 0x70, 0x65, 0x52, 0x04, 0x74, 0x79, 0x70, 0x65, 0x12, 0x4d, 0x0a, 0x0d,
        0x66, 0x69, 0x65, 0x6c, 0x64, 0x5f, 0x6d, 0x61, 0x70, 0x70, 0x69, 0x6e, 0x67, 0x18, 0x02, 0x20,
        0x03, 0x28, 0x0b, 0x32, 0x28, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65,
        0x2e, 0x44, 0x61, 0x74, 0x61, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x46, 0x69, 0x65, 0x6c,
        0x64, 0x4d, 0x61, 0x70, 0x70, 0x69, 0x6e, 0x67, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x0c, 0x66,
        0x69, 0x65, 0x6c, 0x64, 0x4d, 0x61, 0x70, 0x70, 0x69, 0x6e, 0x67, 0x12, 0x27, 0x0a, 0x0f, 0x74,
        0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x5f, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x18, 0x03,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x46,
        0x69, 0x65, 0x6c, 0x64, 0x12, 0x32, 0x0a, 0x15, 0x64, 0x61, 0x74, 0x65, 0x5f, 0x70, 0x61, 0x72,
        0x74, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x63, 0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x18, 0x04, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x13, 0x64, 0x61, 0x74, 0x65, 0x50, 0x61, 0x72, 0x74, 0x69, 0x74, 0x69,
        0x6f, 0x6e, 0x43, 0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x12, 0x38, 0x0a, 0x18, 0x63, 0x72, 0x65, 0x61,
        0x74, 0x65, 0x64, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x5f, 0x63, 0x6f,
        0x6c, 0x75, 0x6d, 0x6e, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x16, 0x63, 0x72, 0x65, 0x61,
        0x74, 0x65, 0x64, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x43, 0x6f, 0x6c, 0x75,
        0x6d, 0x6e, 0x12, 0x33, 0x0a, 0x16, 0x64, 0x61, 0x74, 0x61, 0x5f, 0x73, 0x6f, 0x75, 0x72, 0x63,
        0x65, 0x5f, 0x63, 0x6c, 0x61, 0x73, 0x73, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x11, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x13, 0x64, 0x61, 0x74, 0x61, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x43, 0x6c,
        0x61, 0x73, 0x73, 0x54, 0x79, 0x70, 0x65, 0x12, 0x39, 0x0a, 0x0c, 0x62, 0x61, 0x74, 0x63, 0x68,
        0x5f, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x18, 0x1a, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e,
        0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x53,
        0x6f, 0x75, 0x72, 0x63, 0x65, 0x52, 0x0b, 0x62, 0x61, 0x74, 0x63, 0x68, 0x53, 0x6f, 0x75, 0x72,
        0x63, 0x65, 0x12, 0x35, 0x0a, 0x04, 0x6d, 0x65, 0x74, 0x61, 0x18, 0x32, 0x20, 0x01, 0x28, 0x0b,
        0x32, 0x21, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x44, 0x61,
        0x74, 0x61, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x4d,
        0x65, 0x74, 0x61, 0x52, 0x04, 0x6d, 0x65, 0x74, 0x61, 0x12, 0x47, 0x0a, 0x0c, 0x66, 0x69, 0x6c,
        0x65, 0x5f, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0b, 0x32,
        0x22, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x44, 0x61, 0x74,
        0x61, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x46, 0x69, 0x6c, 0x65, 0x4f, 0x70, 0x74, 0x69,
        0x6f, 0x6e, 0x73, 0x48, 0x00, 0x52, 0x0b, 0x66, 0x69, 0x6c, 0x65, 0x4f, 0x70, 0x74, 0x69, 0x6f,
        0x6e, 0x73, 0x12, 0x53, 0x0a, 0x10, 0x62, 0x69, 0x67, 0x71, 0x75, 0x65, 0x72, 0x79, 0x5f, 0x6f,
        0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x66,
        0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x53, 0x6f,
        0x75, 0x72, 0x63, 0x65, 0x2e, 0x42, 0x69, 0x67, 0x51, 0x75, 0x65, 0x72, 0x79, 0x4f, 0x70, 0x74,
        0x69, 0x6f, 0x6e, 0x73, 0x48, 0x00, 0x52, 0x0f, 0x62, 0x69, 0x67, 0x71, 0x75, 0x65, 0x72, 0x79,
        0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x4a, 0x0a, 0x0d, 0x6b, 0x61, 0x66, 0x6b, 0x61,
        0x5f, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23,
        0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x44, 0x61, 0x74, 0x61,
        0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x4b, 0x61, 0x66, 0x6b, 0x61, 0x4f, 0x70, 0x74, 0x69,
        0x6f, 0x6e, 0x73, 0x48, 0x00, 0x52, 0x0c, 0x6b, 0x61, 0x66, 0x6b, 0x61, 0x4f, 0x70, 0x74, 0x69,
        0x6f, 0x6e, 0x73, 0x12, 0x50, 0x0a, 0x0f, 0x6b, 0x69, 0x6e, 0x65, 0x73, 0x69, 0x73, 0x5f, 0x6f,
        0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x25, 0x2e, 0x66,
        0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x53, 0x6f,
        0x75, 0x72, 0x63, 0x65, 0x2e, 0x4b, 0x69, 0x6e, 0x65, 0x73, 0x69, 0x73, 0x4f, 0x70, 0x74, 0x69,
        0x6f, 0x6e, 0x73, 0x48, 0x00, 0x52, 0x0e, 0x6b, 0x69, 0x6e, 0x65, 0x73, 0x69, 0x73, 0x4f, 0x70,
        0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x53, 0x0a, 0x10, 0x72, 0x65, 0x64, 0x73, 0x68, 0x69, 0x66,
        0x74, 0x5f, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x0f, 0x20, 0x01, 0x28, 0x0b, 0x32,
        0x26, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x44, 0x61, 0x74,
        0x61, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x52, 0x65, 0x64, 0x73, 0x68, 0x69, 0x66, 0x74,
        0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x48, 0x00, 0x52, 0x0f, 0x72, 0x65, 0x64, 0x73, 0x68,
        0x69, 0x66, 0x74, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x5d, 0x0a, 0x14, 0x72, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x5f, 0x64, 0x61, 0x74, 0x61, 0x5f, 0x6f, 0x70, 0x74, 0x69, 0x6f,
        0x6e, 0x73, 0x18, 0x12, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74,
        0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65,
        0x2e, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x44, 0x61, 0x74, 0x61, 0x4f, 0x70, 0x74, 0x69,
        0x6f, 0x6e, 0x73, 0x48, 0x00, 0x52, 0x12, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x44, 0x61,
        0x74, 0x61, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x53, 0x0a, 0x0e, 0x63, 0x75, 0x73,
        0x74, 0x6f, 0x6d, 0x5f, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x10, 0x20, 0x01, 0x28,
        0x0b, 0x32, 0x2a, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x44,
        0x61, 0x74, 0x61, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x43, 0x75, 0x73, 0x74, 0x6f, 0x6d,
        0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x48, 0x00, 0x52,
        0x0d, 0x63, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x56,
        0x0a, 0x11, 0x73, 0x6e, 0x6f, 0x77, 0x66, 0x6c, 0x61, 0x6b, 0x65, 0x5f, 0x6f, 0x70, 0x74, 0x69,
        0x6f, 0x6e, 0x73, 0x18, 0x13, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x27, 0x2e, 0x66, 0x65, 0x61, 0x73,
        0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x53, 0x6f, 0x75, 0x72, 0x63,
        0x65, 0x2e, 0x53, 0x6e, 0x6f, 0x77, 0x66, 0x6c, 0x61, 0x6b, 0x65, 0x4f, 0x70, 0x74, 0x69, 0x6f,
        0x6e, 0x73, 0x48, 0x00, 0x52, 0x10, 0x73, 0x6e, 0x6f, 0x77, 0x66, 0x6c, 0x61, 0x6b, 0x65, 0x4f,
        0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x47, 0x0a, 0x0c, 0x70, 0x75, 0x73, 0x68, 0x5f, 0x6f,
        0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x16, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x22, 0x2e, 0x66,
        0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x53, 0x6f,
        0x75, 0x72, 0x63, 0x65, 0x2e, 0x50, 0x75, 0x73, 0x68, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73,
        0x48, 0x00, 0x52, 0x0b, 0x70, 0x75, 0x73, 0x68, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12,
        0x4a, 0x0a, 0x0d, 0x73, 0x70, 0x61, 0x72, 0x6b, 0x5f, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73,
        0x18, 0x1b, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63,
        0x6f, 0x72, 0x65, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x53,
        0x70, 0x61, 0x72, 0x6b, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x48, 0x00, 0x52, 0x0c, 0x73,
        0x70, 0x61, 0x72, 0x6b, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x4a, 0x0a, 0x0d, 0x74,
        0x72, 0x69, 0x6e, 0x6f, 0x5f, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x1e, 0x20, 0x01,
        0x28, 0x0b, 0x32, 0x23, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e,
        0x44, 0x61, 0x74, 0x61, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x54, 0x72, 0x69, 0x6e, 0x6f,
        0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x48, 0x00, 0x52, 0x0c, 0x74, 0x72, 0x69, 0x6e, 0x6f,
        0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x4d, 0x0a, 0x0e, 0x61, 0x74, 0x68, 0x65, 0x6e,
        0x61, 0x5f, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x23, 0x20, 0x01, 0x28, 0x0b, 0x32,
        0x24, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x44, 0x61, 0x74,
        0x61, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x41, 0x74, 0x68, 0x65, 0x6e, 0x61, 0x4f, 0x70,
        0x74, 0x69, 0x6f, 0x6e, 0x73, 0x48, 0x00, 0x52, 0x0d, 0x61, 0x74, 0x68, 0x65, 0x6e, 0x61, 0x4f,
        0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x1a, 0x37, 0x0a, 0x09, 0x54, 0x61, 0x67, 0x73, 0x45, 0x6e,
        0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x1a,
        0x3f, 0x0a, 0x11, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x4d, 0x61, 0x70, 0x70, 0x69, 0x6e, 0x67, 0x45,
        0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18,
        0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01,
        0x1a, 0xb0, 0x01, 0x0a, 0x0a, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x4d, 0x65, 0x74, 0x61, 0x12,
        0x52, 0x0a, 0x16, 0x65, 0x61, 0x72, 0x6c, 0x69, 0x65, 0x73, 0x74, 0x45, 0x76, 0x65, 0x6e, 0x74,
        0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32,
        0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75,
        0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x16, 0x65, 0x61, 0x72,
        0x6c, 0x69, 0x65, 0x73, 0x74, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74,
        0x61, 0x6d, 0x70, 0x12, 0x4e, 0x0a, 0x14, 0x6c, 0x61, 0x74, 0x65, 0x73, 0x74, 0x45, 0x76, 0x65,
        0x6e, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x02, 0x20, 0x01, 0x28,
        0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x14, 0x6c,
        0x61, 0x74, 0x65, 0x73, 0x74, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74,
        0x61, 0x6d, 0x70, 0x1a, 0x8a, 0x01, 0x0a, 0x0b, 0x46, 0x69, 0x6c, 0x65, 0x4f, 0x70, 0x74, 0x69,
        0x6f, 0x6e, 0x73, 0x12, 0x37, 0x0a, 0x0b, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x66, 0x6f, 0x72, 0x6d,
        0x61, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74,
        0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x46, 0x69, 0x6c, 0x65, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74,
        0x52, 0x0a, 0x66, 0x69, 0x6c, 0x65, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x12, 0x10, 0x0a, 0x03,
        0x75, 0x72, 0x69, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x75, 0x72, 0x69, 0x12, 0x30,
        0x0a, 0x14, 0x73, 0x33, 0x5f, 0x65, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x5f, 0x6f, 0x76,
        0x65, 0x72, 0x72, 0x69, 0x64, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x12, 0x73, 0x33,
        0x45, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x4f, 0x76, 0x65, 0x72, 0x72, 0x69, 0x64, 0x65,
        0x1a, 0x3d, 0x0a, 0x0f, 0x42, 0x69, 0x67, 0x51, 0x75, 0x65, 0x72, 0x79, 0x4f, 0x70, 0x74, 0x69,
        0x6f, 0x6e, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x18, 0x01, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x05, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x71, 0x75, 0x65,
        0x72, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x71, 0x75, 0x65, 0x72, 0x79, 0x1a,
        0x3a, 0x0a, 0x0c, 0x54, 0x72, 0x69, 0x6e, 0x6f, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12,
        0x14, 0x0a, 0x05, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05,
        0x74, 0x61, 0x62, 0x6c, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x71, 0x75, 0x65, 0x72, 0x79, 0x18, 0x02,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x71, 0x75, 0x65, 0x72, 0x79, 0x1a, 0xf4, 0x01, 0x0a, 0x0c,
        0x4b, 0x61, 0x66, 0x6b, 0x61, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x36, 0x0a, 0x17,
        0x6b, 0x61, 0x66, 0x6b, 0x61, 0x5f, 0x62, 0x6f, 0x6f, 0x74, 0x73, 0x74, 0x72, 0x61, 0x70, 0x5f,
        0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x15, 0x6b,
        0x61, 0x66, 0x6b, 0x61, 0x42, 0x6f, 0x6f, 0x74, 0x73, 0x74, 0x72, 0x61, 0x70, 0x53, 0x65, 0x72,
        0x76, 0x65, 0x72, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x74, 0x6f, 0x70, 0x69, 0x63, 0x18, 0x02, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x05, 0x74, 0x6f, 0x70, 0x69, 0x63, 0x12, 0x3f, 0x0a, 0x0e, 0x6d, 0x65,
        0x73, 0x73, 0x61, 0x67, 0x65, 0x5f, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x18, 0x03, 0x20, 0x01,
        0x28, 0x0b, 0x32, 0x18, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e,
        0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x52, 0x0d, 0x6d, 0x65,
        0x73, 0x73, 0x61, 0x67, 0x65, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x12, 0x55, 0x0a, 0x19, 0x77,
        0x61, 0x74, 0x65, 0x72, 0x6d, 0x61, 0x72, 0x6b, 0x5f, 0x64, 0x65, 0x6c, 0x61, 0x79, 0x5f, 0x74,
        0x68, 0x72, 0x65, 0x73, 0x68, 0x6f, 0x6c, 0x64, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19,
        0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66,
        0x2e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x17, 0x77, 0x61, 0x74, 0x65, 0x72,
        0x6d, 0x61, 0x72, 0x6b, 0x44, 0x65, 0x6c, 0x61, 0x79, 0x54, 0x68, 0x72, 0x65, 0x73, 0x68, 0x6f,
        0x6c, 0x64, 0x1a, 0x88, 0x01, 0x0a, 0x0e, 0x4b, 0x69, 0x6e, 0x65, 0x73, 0x69, 0x73, 0x4f, 0x70,
        0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x16, 0x0a, 0x06, 0x72, 0x65, 0x67, 0x69, 0x6f, 0x6e, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x72, 0x65, 0x67, 0x69, 0x6f, 0x6e, 0x12, 0x1f, 0x0a,
        0x0b, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x0a, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x3d,
        0x0a, 0x0d, 0x72, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x5f, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x18,
        0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f,
        0x72, 0x65, 0x2e, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x52,
        0x0c, 0x72, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x1a, 0x71, 0x0a,
        0x0f, 0x52, 0x65, 0x64, 0x73, 0x68, 0x69, 0x66, 0x74, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73,
        0x12, 0x14, 0x0a, 0x05, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x05, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x71, 0x75, 0x65, 0x72, 0x79, 0x18,
        0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x71, 0x75, 0x65, 0x72, 0x79, 0x12, 0x16, 0x0a, 0x06,
        0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x73, 0x63,
        0x68, 0x65, 0x6d, 0x61, 0x12, 0x1a, 0x0a, 0x08, 0x64, 0x61, 0x74, 0x61, 0x62, 0x61, 0x73, 0x65,
        0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x64, 0x61, 0x74, 0x61, 0x62, 0x61, 0x73, 0x65,
        0x1a, 0x78, 0x0a, 0x0d, 0x41, 0x74, 0x68, 0x65, 0x6e, 0x61, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e,
        0x73, 0x12, 0x14, 0x0a, 0x05, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x05, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x71, 0x75, 0x65, 0x72, 0x79,
        0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x71, 0x75, 0x65, 0x72, 0x79, 0x12, 0x1a, 0x0a,
        0x08, 0x64, 0x61, 0x74, 0x61, 0x62, 0x61, 0x73, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x08, 0x64, 0x61, 0x74, 0x61, 0x62, 0x61, 0x73, 0x65, 0x12, 0x1f, 0x0a, 0x0b, 0x64, 0x61, 0x74,
        0x61, 0x5f, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a,
        0x64, 0x61, 0x74, 0x61, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x1a, 0x78, 0x0a, 0x10, 0x53, 0x6e,
        0x6f, 0x77, 0x66, 0x6c, 0x61, 0x6b, 0x65, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x14,
        0x0a, 0x05, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x74,
        0x61, 0x62, 0x6c, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x71, 0x75, 0x65, 0x72, 0x79, 0x18, 0x02, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x05, 0x71, 0x75, 0x65, 0x72, 0x79, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x63,
        0x68, 0x65, 0x6d, 0x61, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x73, 0x63, 0x68, 0x65,
        0x6d, 0x61, 0x12, 0x1a, 0x0a, 0x08, 0x64, 0x61, 0x74, 0x61, 0x62, 0x61, 0x73, 0x65, 0x18, 0x04,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x64, 0x61, 0x74, 0x61, 0x62, 0x61, 0x73, 0x65, 0x4a, 0x04,
        0x08, 0x05, 0x10, 0x06, 0x1a, 0x6f, 0x0a, 0x0c, 0x53, 0x70, 0x61, 0x72, 0x6b, 0x4f, 0x70, 0x74,
        0x69, 0x6f, 0x6e, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x05, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x71, 0x75,
        0x65, 0x72, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x71, 0x75, 0x65, 0x72, 0x79,
        0x12, 0x12, 0x0a, 0x04, 0x70, 0x61, 0x74, 0x68, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04,
        0x70, 0x61, 0x74, 0x68, 0x12, 0x1f, 0x0a, 0x0b, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x66, 0x6f, 0x72,
        0x6d, 0x61, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x66, 0x69, 0x6c, 0x65, 0x46,
        0x6f, 0x72, 0x6d, 0x61, 0x74, 0x1a, 0x3b, 0x0a, 0x13, 0x43, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x53,
        0x6f, 0x75, 0x72, 0x63, 0x65, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x24, 0x0a, 0x0d,
        0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x0c, 0x52, 0x0d, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x75, 0x72, 0x61, 0x74, 0x69,
        0x6f, 0x6e, 0x1a, 0x9d, 0x02, 0x0a, 0x12, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x44, 0x61,
        0x74, 0x61, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x6c, 0x0a, 0x11, 0x64, 0x65, 0x70,
        0x72, 0x65, 0x63, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x18, 0x02,
        0x20, 0x03, 0x28, 0x0b, 0x32, 0x3f, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72,
        0x65, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x52, 0x65, 0x71,
        0x75, 0x65, 0x73, 0x74, 0x44, 0x61, 0x74, 0x61, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e,
        0x44, 0x65, 0x70, 0x72, 0x65, 0x63, 0x61, 0x74, 0x65, 0x64, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61,
        0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x10, 0x64, 0x65, 0x70, 0x72, 0x65, 0x63, 0x61, 0x74, 0x65,
        0x64, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x12, 0x31, 0x0a, 0x06, 0x73, 0x63, 0x68, 0x65, 0x6d,
        0x61, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e,
        0x63, 0x6f, 0x72, 0x65, 0x2e, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x53, 0x70, 0x65, 0x63,
        0x56, 0x32, 0x52, 0x06, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x1a, 0x60, 0x0a, 0x15, 0x44, 0x65,
        0x70, 0x72, 0x65, 0x63, 0x61, 0x74, 0x65, 0x64, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x45, 0x6e,
        0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x31, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02,
        0x20, 0x01, 0x28, 0x0e, 0x32, 0x1b, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x74, 0x79, 0x70,
        0x65, 0x73, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x54, 0x79, 0x70, 0x65, 0x2e, 0x45, 0x6e, 0x75,
        0x6d, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x4a, 0x04, 0x08, 0x01,
        0x10, 0x02, 0x1a, 0x13, 0x0a, 0x0b, 0x50, 0x75, 0x73, 0x68, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e,
        0x73, 0x4a, 0x04, 0x08, 0x01, 0x10, 0x02, 0x22, 0xf8, 0x01, 0x0a, 0x0a, 0x53, 0x6f, 0x75, 0x72,
        0x63, 0x65, 0x54, 0x79, 0x70, 0x65, 0x12, 0x0b, 0x0a, 0x07, 0x49, 0x4e, 0x56, 0x41, 0x4c, 0x49,
        0x44, 0x10, 0x00, 0x12, 0x0e, 0x0a, 0x0a, 0x42, 0x41, 0x54, 0x43, 0x48, 0x5f, 0x46, 0x49, 0x4c,
        0x45, 0x10, 0x01, 0x12, 0x13, 0x0a, 0x0f, 0x42, 0x41, 0x54, 0x43, 0x48, 0x5f, 0x53, 0x4e, 0x4f,
        0x57, 0x46, 0x4c, 0x41, 0x4b, 0x45, 0x10, 0x08, 0x12, 0x12, 0x0a, 0x0e, 0x42, 0x41, 0x54, 0x43,
        0x48, 0x5f, 0x42, 0x49, 0x47, 0x51, 0x55, 0x45, 0x52, 0x59, 0x10, 0x02, 0x12, 0x12, 0x0a, 0x0e,
        0x42, 0x41, 0x54, 0x43, 0x48, 0x5f, 0x52, 0x45, 0x44, 0x53, 0x48, 0x49, 0x46, 0x54, 0x10, 0x05,
        0x12, 0x10, 0x0a, 0x0c, 0x53, 0x54, 0x52, 0x45, 0x41, 0x4d, 0x5f, 0x4b, 0x41, 0x46, 0x4b, 0x41,
        0x10, 0x03, 0x12, 0x12, 0x0a, 0x0e, 0x53, 0x54, 0x52, 0x45, 0x41, 0x4d, 0x5f, 0x4b, 0x49, 0x4e,
        0x45, 0x53, 0x49, 0x53, 0x10, 0x04, 0x12, 0x11, 0x0a, 0x0d, 0x43, 0x55, 0x53, 0x54, 0x4f, 0x4d,
        0x5f, 0x53, 0x4f, 0x55, 0x52, 0x43, 0x45, 0x10, 0x06, 0x12, 0x12, 0x0a, 0x0e, 0x52, 0x45, 0x51,
        0x55, 0x45, 0x53, 0x54, 0x5f, 0x53, 0x4f, 0x55, 0x52, 0x43, 0x45, 0x10, 0x07, 0x12, 0x0f, 0x0a,
        0x0b, 0x50, 0x55, 0x53, 0x48, 0x5f, 0x53, 0x4f, 0x55, 0x52, 0x43, 0x45, 0x10, 0x09, 0x12, 0x0f,
        0x0a, 0x0b, 0x42, 0x41, 0x54, 0x43, 0x48, 0x5f, 0x54, 0x52, 0x49, 0x4e, 0x4f, 0x10, 0x0a, 0x12,
        0x0f, 0x0a, 0x0b, 0x42, 0x41, 0x54, 0x43, 0x48, 0x5f, 0x53, 0x50, 0x41, 0x52, 0x4b, 0x10, 0x0b,
        0x12, 0x10, 0x0a, 0x0c, 0x42, 0x41, 0x54, 0x43, 0x48, 0x5f, 0x41, 0x54, 0x48, 0x45, 0x4e, 0x41,
        0x10, 0x0c, 0x42, 0x09, 0x0a, 0x07, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x4a, 0x04, 0x08,
        0x06, 0x10, 0x0b, 0x22, 0x4a, 0x0a, 0x0e, 0x44, 0x61, 0x74, 0x61, 0x53, 0x6f, 0x75, 0x72, 0x63,
        0x65, 0x4c, 0x69, 0x73, 0x74, 0x12, 0x38, 0x0a, 0x0b, 0x64, 0x61, 0x74, 0x61, 0x73, 0x6f, 0x75,
        0x72, 0x63, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x66, 0x65, 0x61,
        0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x53, 0x6f, 0x75, 0x72,
        0x63, 0x65, 0x52, 0x0b, 0x64, 0x61, 0x74, 0x61, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x42,
        0x54, 0x0a, 0x10, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x63,
        0x6f, 0x72, 0x65, 0x42, 0x0f, 0x44, 0x61, 0x74, 0x61, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x50,
        0x72, 0x6f, 0x74, 0x6f, 0x5a, 0x2f, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d,
        0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2d, 0x64, 0x65, 0x76, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74,
        0x2f, 0x67, 0x6f, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x73, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74,
        0x2f, 0x63, 0x6f, 0x72, 0x65, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_feast_core_DataSource_proto_rawDescOnce sync.Once
        file_feast_core_DataSource_proto_rawDescData = file_feast_core_DataSource_proto_rawDesc
)

func file_feast_core_DataSource_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_feast_core_DataSource_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_feast_core_DataSource_proto_rawDescData = protoimpl.X.CompressGZIP(file_feast_core_DataSource_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_feast_core_DataSource_proto_rawDescData</span>
}

var file_feast_core_DataSource_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_feast_core_DataSource_proto_msgTypes = make([]protoimpl.MessageInfo, 18)
var file_feast_core_DataSource_proto_goTypes = []interface{}{
        (DataSource_SourceType)(0),             // 0: feast.core.DataSource.SourceType
        (*DataSource)(nil),                     // 1: feast.core.DataSource
        (*DataSourceList)(nil),                 // 2: feast.core.DataSourceList
        nil,                                    // 3: feast.core.DataSource.TagsEntry
        nil,                                    // 4: feast.core.DataSource.FieldMappingEntry
        (*DataSource_SourceMeta)(nil),          // 5: feast.core.DataSource.SourceMeta
        (*DataSource_FileOptions)(nil),         // 6: feast.core.DataSource.FileOptions
        (*DataSource_BigQueryOptions)(nil),     // 7: feast.core.DataSource.BigQueryOptions
        (*DataSource_TrinoOptions)(nil),        // 8: feast.core.DataSource.TrinoOptions
        (*DataSource_KafkaOptions)(nil),        // 9: feast.core.DataSource.KafkaOptions
        (*DataSource_KinesisOptions)(nil),      // 10: feast.core.DataSource.KinesisOptions
        (*DataSource_RedshiftOptions)(nil),     // 11: feast.core.DataSource.RedshiftOptions
        (*DataSource_AthenaOptions)(nil),       // 12: feast.core.DataSource.AthenaOptions
        (*DataSource_SnowflakeOptions)(nil),    // 13: feast.core.DataSource.SnowflakeOptions
        (*DataSource_SparkOptions)(nil),        // 14: feast.core.DataSource.SparkOptions
        (*DataSource_CustomSourceOptions)(nil), // 15: feast.core.DataSource.CustomSourceOptions
        (*DataSource_RequestDataOptions)(nil),  // 16: feast.core.DataSource.RequestDataOptions
        (*DataSource_PushOptions)(nil),         // 17: feast.core.DataSource.PushOptions
        nil,                                    // 18: feast.core.DataSource.RequestDataOptions.DeprecatedSchemaEntry
        (*timestamppb.Timestamp)(nil),          // 19: google.protobuf.Timestamp
        (*FileFormat)(nil),                     // 20: feast.core.FileFormat
        (*StreamFormat)(nil),                   // 21: feast.core.StreamFormat
        (*durationpb.Duration)(nil),            // 22: google.protobuf.Duration
        (*FeatureSpecV2)(nil),                  // 23: feast.core.FeatureSpecV2
        (types.ValueType_Enum)(0),              // 24: feast.types.ValueType.Enum
}
var file_feast_core_DataSource_proto_depIdxs = []int32{
        3,  // 0: feast.core.DataSource.tags:type_name -&gt; feast.core.DataSource.TagsEntry
        0,  // 1: feast.core.DataSource.type:type_name -&gt; feast.core.DataSource.SourceType
        4,  // 2: feast.core.DataSource.field_mapping:type_name -&gt; feast.core.DataSource.FieldMappingEntry
        1,  // 3: feast.core.DataSource.batch_source:type_name -&gt; feast.core.DataSource
        5,  // 4: feast.core.DataSource.meta:type_name -&gt; feast.core.DataSource.SourceMeta
        6,  // 5: feast.core.DataSource.file_options:type_name -&gt; feast.core.DataSource.FileOptions
        7,  // 6: feast.core.DataSource.bigquery_options:type_name -&gt; feast.core.DataSource.BigQueryOptions
        9,  // 7: feast.core.DataSource.kafka_options:type_name -&gt; feast.core.DataSource.KafkaOptions
        10, // 8: feast.core.DataSource.kinesis_options:type_name -&gt; feast.core.DataSource.KinesisOptions
        11, // 9: feast.core.DataSource.redshift_options:type_name -&gt; feast.core.DataSource.RedshiftOptions
        16, // 10: feast.core.DataSource.request_data_options:type_name -&gt; feast.core.DataSource.RequestDataOptions
        15, // 11: feast.core.DataSource.custom_options:type_name -&gt; feast.core.DataSource.CustomSourceOptions
        13, // 12: feast.core.DataSource.snowflake_options:type_name -&gt; feast.core.DataSource.SnowflakeOptions
        17, // 13: feast.core.DataSource.push_options:type_name -&gt; feast.core.DataSource.PushOptions
        14, // 14: feast.core.DataSource.spark_options:type_name -&gt; feast.core.DataSource.SparkOptions
        8,  // 15: feast.core.DataSource.trino_options:type_name -&gt; feast.core.DataSource.TrinoOptions
        12, // 16: feast.core.DataSource.athena_options:type_name -&gt; feast.core.DataSource.AthenaOptions
        1,  // 17: feast.core.DataSourceList.datasources:type_name -&gt; feast.core.DataSource
        19, // 18: feast.core.DataSource.SourceMeta.earliestEventTimestamp:type_name -&gt; google.protobuf.Timestamp
        19, // 19: feast.core.DataSource.SourceMeta.latestEventTimestamp:type_name -&gt; google.protobuf.Timestamp
        20, // 20: feast.core.DataSource.FileOptions.file_format:type_name -&gt; feast.core.FileFormat
        21, // 21: feast.core.DataSource.KafkaOptions.message_format:type_name -&gt; feast.core.StreamFormat
        22, // 22: feast.core.DataSource.KafkaOptions.watermark_delay_threshold:type_name -&gt; google.protobuf.Duration
        21, // 23: feast.core.DataSource.KinesisOptions.record_format:type_name -&gt; feast.core.StreamFormat
        18, // 24: feast.core.DataSource.RequestDataOptions.deprecated_schema:type_name -&gt; feast.core.DataSource.RequestDataOptions.DeprecatedSchemaEntry
        23, // 25: feast.core.DataSource.RequestDataOptions.schema:type_name -&gt; feast.core.FeatureSpecV2
        24, // 26: feast.core.DataSource.RequestDataOptions.DeprecatedSchemaEntry.value:type_name -&gt; feast.types.ValueType.Enum
        27, // [27:27] is the sub-list for method output_type
        27, // [27:27] is the sub-list for method input_type
        27, // [27:27] is the sub-list for extension type_name
        27, // [27:27] is the sub-list for extension extendee
        0,  // [0:27] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_feast_core_DataSource_proto_init() }</span>
func file_feast_core_DataSource_proto_init() <span class="cov8" title="1">{
        if File_feast_core_DataSource_proto != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">file_feast_core_DataFormat_proto_init()
        file_feast_core_Feature_proto_init()
        if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_feast_core_DataSource_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*DataSource); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_DataSource_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*DataSourceList); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_DataSource_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*DataSource_SourceMeta); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_DataSource_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*DataSource_FileOptions); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_DataSource_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*DataSource_BigQueryOptions); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_DataSource_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*DataSource_TrinoOptions); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_DataSource_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*DataSource_KafkaOptions); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_DataSource_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*DataSource_KinesisOptions); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_DataSource_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*DataSource_RedshiftOptions); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_DataSource_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*DataSource_AthenaOptions); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_DataSource_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*DataSource_SnowflakeOptions); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_DataSource_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*DataSource_SparkOptions); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_DataSource_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*DataSource_CustomSourceOptions); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_DataSource_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*DataSource_RequestDataOptions); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_DataSource_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*DataSource_PushOptions); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">file_feast_core_DataSource_proto_msgTypes[0].OneofWrappers = []interface{}{
                (*DataSource_FileOptions_)(nil),
                (*DataSource_BigqueryOptions)(nil),
                (*DataSource_KafkaOptions_)(nil),
                (*DataSource_KinesisOptions_)(nil),
                (*DataSource_RedshiftOptions_)(nil),
                (*DataSource_RequestDataOptions_)(nil),
                (*DataSource_CustomOptions)(nil),
                (*DataSource_SnowflakeOptions_)(nil),
                (*DataSource_PushOptions_)(nil),
                (*DataSource_SparkOptions_)(nil),
                (*DataSource_TrinoOptions_)(nil),
                (*DataSource_AthenaOptions_)(nil),
        }
        type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_feast_core_DataSource_proto_rawDesc,
                        NumEnums:      1,
                        NumMessages:   18,
                        NumExtensions: 0,
                        NumServices:   0,
                },
                GoTypes:           file_feast_core_DataSource_proto_goTypes,
                DependencyIndexes: file_feast_core_DataSource_proto_depIdxs,
                EnumInfos:         file_feast_core_DataSource_proto_enumTypes,
                MessageInfos:      file_feast_core_DataSource_proto_msgTypes,
        }.Build()
        File_feast_core_DataSource_proto = out.File
        file_feast_core_DataSource_proto_rawDesc = nil
        file_feast_core_DataSource_proto_goTypes = nil
        file_feast_core_DataSource_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">//
// * Copyright 2021 The Feast Authors
// *
// * Licensed under the Apache License, Version 2.0 (the "License");
// * you may not use this file except in compliance with the License.
// * You may obtain a copy of the License at
// *
// *     https://www.apache.org/licenses/LICENSE-2.0
// *
// * Unless required by applicable law or agreed to in writing, software
// * distributed under the License is distributed on an "AS IS" BASIS,
// * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// * See the License for the specific language governing permissions and
// * limitations under the License.
//

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.31.0
//         protoc        v4.25.1
// source: feast/core/DatastoreTable.proto

package core

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Represents a Datastore table
type DatastoreTable struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Feast project of the table
        Project string `protobuf:"bytes,1,opt,name=project,proto3" json:"project,omitempty"`
        // Name of the table
        Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
        // GCP project id
        ProjectId *wrapperspb.StringValue `protobuf:"bytes,3,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
        // Datastore namespace
        Namespace *wrapperspb.StringValue `protobuf:"bytes,4,opt,name=namespace,proto3" json:"namespace,omitempty"`
        // Firestore database
        Database *wrapperspb.StringValue `protobuf:"bytes,5,opt,name=database,proto3" json:"database,omitempty"`
}

func (x *DatastoreTable) Reset() <span class="cov0" title="0">{
        *x = DatastoreTable{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_DatastoreTable_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DatastoreTable) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DatastoreTable) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DatastoreTable) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_DatastoreTable_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use DatastoreTable.ProtoReflect.Descriptor instead.
func (*DatastoreTable) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_DatastoreTable_proto_rawDescGZIP(), []int{0}
}</span>

func (x *DatastoreTable) GetProject() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Project
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DatastoreTable) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DatastoreTable) GetProjectId() *wrapperspb.StringValue <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ProjectId
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DatastoreTable) GetNamespace() *wrapperspb.StringValue <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Namespace
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *DatastoreTable) GetDatabase() *wrapperspb.StringValue <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Database
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_feast_core_DatastoreTable_proto protoreflect.FileDescriptor

var file_feast_core_DatastoreTable_proto_rawDesc = []byte{
        0x0a, 0x1f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x44, 0x61, 0x74,
        0x61, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x12, 0x0a, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x1a, 0x1e, 0x67,
        0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x77,
        0x72, 0x61, 0x70, 0x70, 0x65, 0x72, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xf1, 0x01,
        0x0a, 0x0e, 0x44, 0x61, 0x74, 0x61, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x54, 0x61, 0x62, 0x6c, 0x65,
        0x12, 0x18, 0x0a, 0x07, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x07, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61,
        0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x3b,
        0x0a, 0x0a, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x03, 0x20, 0x01,
        0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x62, 0x75, 0x66, 0x2e, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x56, 0x61, 0x6c, 0x75, 0x65,
        0x52, 0x09, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x49, 0x64, 0x12, 0x3a, 0x0a, 0x09, 0x6e,
        0x61, 0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c,
        0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66,
        0x2e, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x09, 0x6e, 0x61,
        0x6d, 0x65, 0x73, 0x70, 0x61, 0x63, 0x65, 0x12, 0x38, 0x0a, 0x08, 0x64, 0x61, 0x74, 0x61, 0x62,
        0x61, 0x73, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x67, 0x6f, 0x6f, 0x67,
        0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x53, 0x74, 0x72, 0x69,
        0x6e, 0x67, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x08, 0x64, 0x61, 0x74, 0x61, 0x62, 0x61, 0x73,
        0x65, 0x42, 0x58, 0x0a, 0x10, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x2e, 0x63, 0x6f, 0x72, 0x65, 0x42, 0x13, 0x44, 0x61, 0x74, 0x61, 0x73, 0x74, 0x6f, 0x72, 0x65,
        0x54, 0x61, 0x62, 0x6c, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x5a, 0x2f, 0x67, 0x69, 0x74, 0x68,
        0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2d, 0x64, 0x65, 0x76,
        0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x67, 0x6f, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x73,
        0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x62, 0x06, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x33,
}

var (
        file_feast_core_DatastoreTable_proto_rawDescOnce sync.Once
        file_feast_core_DatastoreTable_proto_rawDescData = file_feast_core_DatastoreTable_proto_rawDesc
)

func file_feast_core_DatastoreTable_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_feast_core_DatastoreTable_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_feast_core_DatastoreTable_proto_rawDescData = protoimpl.X.CompressGZIP(file_feast_core_DatastoreTable_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_feast_core_DatastoreTable_proto_rawDescData</span>
}

var file_feast_core_DatastoreTable_proto_msgTypes = make([]protoimpl.MessageInfo, 1)
var file_feast_core_DatastoreTable_proto_goTypes = []interface{}{
        (*DatastoreTable)(nil),         // 0: feast.core.DatastoreTable
        (*wrapperspb.StringValue)(nil), // 1: google.protobuf.StringValue
}
var file_feast_core_DatastoreTable_proto_depIdxs = []int32{
        1, // 0: feast.core.DatastoreTable.project_id:type_name -&gt; google.protobuf.StringValue
        1, // 1: feast.core.DatastoreTable.namespace:type_name -&gt; google.protobuf.StringValue
        1, // 2: feast.core.DatastoreTable.database:type_name -&gt; google.protobuf.StringValue
        3, // [3:3] is the sub-list for method output_type
        3, // [3:3] is the sub-list for method input_type
        3, // [3:3] is the sub-list for extension type_name
        3, // [3:3] is the sub-list for extension extendee
        0, // [0:3] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_feast_core_DatastoreTable_proto_init() }</span>
func file_feast_core_DatastoreTable_proto_init() <span class="cov8" title="1">{
        if File_feast_core_DatastoreTable_proto != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_feast_core_DatastoreTable_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*DatastoreTable); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_feast_core_DatastoreTable_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   1,
                        NumExtensions: 0,
                        NumServices:   0,
                },
                GoTypes:           file_feast_core_DatastoreTable_proto_goTypes,
                DependencyIndexes: file_feast_core_DatastoreTable_proto_depIdxs,
                MessageInfos:      file_feast_core_DatastoreTable_proto_msgTypes,
        }.Build()
        File_feast_core_DatastoreTable_proto = out.File
        file_feast_core_DatastoreTable_proto_rawDesc = nil
        file_feast_core_DatastoreTable_proto_goTypes = nil
        file_feast_core_DatastoreTable_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">//
// * Copyright 2021 The Feast Authors
// *
// * Licensed under the Apache License, Version 2.0 (the "License");
// * you may not use this file except in compliance with the License.
// * You may obtain a copy of the License at
// *
// *     https://www.apache.org/licenses/LICENSE-2.0
// *
// * Unless required by applicable law or agreed to in writing, software
// * distributed under the License is distributed on an "AS IS" BASIS,
// * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// * See the License for the specific language governing permissions and
// * limitations under the License.
//

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.31.0
//         protoc        v4.25.1
// source: feast/core/DynamoDBTable.proto

package core

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Represents a DynamoDB table
type DynamoDBTable struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Name of the table
        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        // Region of the table
        Region string `protobuf:"bytes,2,opt,name=region,proto3" json:"region,omitempty"`
}

func (x *DynamoDBTable) Reset() <span class="cov0" title="0">{
        *x = DynamoDBTable{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_DynamoDBTable_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DynamoDBTable) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DynamoDBTable) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DynamoDBTable) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_DynamoDBTable_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use DynamoDBTable.ProtoReflect.Descriptor instead.
func (*DynamoDBTable) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_DynamoDBTable_proto_rawDescGZIP(), []int{0}
}</span>

func (x *DynamoDBTable) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *DynamoDBTable) GetRegion() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Region
        }</span>
        <span class="cov0" title="0">return ""</span>
}

var File_feast_core_DynamoDBTable_proto protoreflect.FileDescriptor

var file_feast_core_DynamoDBTable_proto_rawDesc = []byte{
        0x0a, 0x1e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x44, 0x79, 0x6e,
        0x61, 0x6d, 0x6f, 0x44, 0x42, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x12, 0x0a, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x22, 0x3b, 0x0a, 0x0d,
        0x44, 0x79, 0x6e, 0x61, 0x6d, 0x6f, 0x44, 0x42, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x12, 0x12, 0x0a,
        0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d,
        0x65, 0x12, 0x16, 0x0a, 0x06, 0x72, 0x65, 0x67, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x06, 0x72, 0x65, 0x67, 0x69, 0x6f, 0x6e, 0x42, 0x57, 0x0a, 0x10, 0x66, 0x65, 0x61,
        0x73, 0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x42, 0x12, 0x44,
        0x79, 0x6e, 0x61, 0x6d, 0x6f, 0x44, 0x42, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x50, 0x72, 0x6f, 0x74,
        0x6f, 0x5a, 0x2f, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x66, 0x65,
        0x61, 0x73, 0x74, 0x2d, 0x64, 0x65, 0x76, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x67, 0x6f,
        0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x73, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f,
        0x72, 0x65, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_feast_core_DynamoDBTable_proto_rawDescOnce sync.Once
        file_feast_core_DynamoDBTable_proto_rawDescData = file_feast_core_DynamoDBTable_proto_rawDesc
)

func file_feast_core_DynamoDBTable_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_feast_core_DynamoDBTable_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_feast_core_DynamoDBTable_proto_rawDescData = protoimpl.X.CompressGZIP(file_feast_core_DynamoDBTable_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_feast_core_DynamoDBTable_proto_rawDescData</span>
}

var file_feast_core_DynamoDBTable_proto_msgTypes = make([]protoimpl.MessageInfo, 1)
var file_feast_core_DynamoDBTable_proto_goTypes = []interface{}{
        (*DynamoDBTable)(nil), // 0: feast.core.DynamoDBTable
}
var file_feast_core_DynamoDBTable_proto_depIdxs = []int32{
        0, // [0:0] is the sub-list for method output_type
        0, // [0:0] is the sub-list for method input_type
        0, // [0:0] is the sub-list for extension type_name
        0, // [0:0] is the sub-list for extension extendee
        0, // [0:0] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_feast_core_DynamoDBTable_proto_init() }</span>
func file_feast_core_DynamoDBTable_proto_init() <span class="cov8" title="1">{
        if File_feast_core_DynamoDBTable_proto != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_feast_core_DynamoDBTable_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*DynamoDBTable); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_feast_core_DynamoDBTable_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   1,
                        NumExtensions: 0,
                        NumServices:   0,
                },
                GoTypes:           file_feast_core_DynamoDBTable_proto_goTypes,
                DependencyIndexes: file_feast_core_DynamoDBTable_proto_depIdxs,
                MessageInfos:      file_feast_core_DynamoDBTable_proto_msgTypes,
        }.Build()
        File_feast_core_DynamoDBTable_proto = out.File
        file_feast_core_DynamoDBTable_proto_rawDesc = nil
        file_feast_core_DynamoDBTable_proto_goTypes = nil
        file_feast_core_DynamoDBTable_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">//
// * Copyright 2020 The Feast Authors
// *
// * Licensed under the Apache License, Version 2.0 (the "License");
// * you may not use this file except in compliance with the License.
// * You may obtain a copy of the License at
// *
// *     https://www.apache.org/licenses/LICENSE-2.0
// *
// * Unless required by applicable law or agreed to in writing, software
// * distributed under the License is distributed on an "AS IS" BASIS,
// * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// * See the License for the specific language governing permissions and
// * limitations under the License.
//

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.31.0
//         protoc        v4.25.1
// source: feast/core/Entity.proto

package core

import (
        types "github.com/feast-dev/feast/go/protos/feast/types"
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Entity struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // User-specified specifications of this entity.
        Spec *EntitySpecV2 `protobuf:"bytes,1,opt,name=spec,proto3" json:"spec,omitempty"`
        // System-populated metadata for this entity.
        Meta *EntityMeta `protobuf:"bytes,2,opt,name=meta,proto3" json:"meta,omitempty"`
}

func (x *Entity) Reset() <span class="cov0" title="0">{
        *x = Entity{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_Entity_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Entity) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Entity) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Entity) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_Entity_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use Entity.ProtoReflect.Descriptor instead.
func (*Entity) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_Entity_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Entity) GetSpec() *EntitySpecV2 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Spec
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Entity) GetMeta() *EntityMeta <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Meta
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type EntitySpecV2 struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Name of the entity.
        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        // Name of Feast project that this feature table belongs to.
        Project string `protobuf:"bytes,9,opt,name=project,proto3" json:"project,omitempty"`
        // Type of the entity.
        ValueType types.ValueType_Enum `protobuf:"varint,2,opt,name=value_type,json=valueType,proto3,enum=feast.types.ValueType_Enum" json:"value_type,omitempty"`
        // Description of the entity.
        Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
        // Join key for the entity (i.e. name of the column the entity maps to).
        JoinKey string `protobuf:"bytes,4,opt,name=join_key,json=joinKey,proto3" json:"join_key,omitempty"`
        // User defined metadata
        Tags map[string]string `protobuf:"bytes,8,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        // Owner of the entity.
        Owner string `protobuf:"bytes,10,opt,name=owner,proto3" json:"owner,omitempty"`
}

func (x *EntitySpecV2) Reset() <span class="cov0" title="0">{
        *x = EntitySpecV2{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_Entity_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *EntitySpecV2) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*EntitySpecV2) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *EntitySpecV2) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_Entity_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use EntitySpecV2.ProtoReflect.Descriptor instead.
func (*EntitySpecV2) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_Entity_proto_rawDescGZIP(), []int{1}
}</span>

func (x *EntitySpecV2) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *EntitySpecV2) GetProject() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Project
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *EntitySpecV2) GetValueType() types.ValueType_Enum <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ValueType
        }</span>
        <span class="cov0" title="0">return types.ValueType_Enum(0)</span>
}

func (x *EntitySpecV2) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *EntitySpecV2) GetJoinKey() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.JoinKey
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *EntitySpecV2) GetTags() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tags
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *EntitySpecV2) GetOwner() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Owner
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type EntityMeta struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        CreatedTimestamp     *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=created_timestamp,json=createdTimestamp,proto3" json:"created_timestamp,omitempty"`
        LastUpdatedTimestamp *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=last_updated_timestamp,json=lastUpdatedTimestamp,proto3" json:"last_updated_timestamp,omitempty"`
}

func (x *EntityMeta) Reset() <span class="cov0" title="0">{
        *x = EntityMeta{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_Entity_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *EntityMeta) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*EntityMeta) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *EntityMeta) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_Entity_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use EntityMeta.ProtoReflect.Descriptor instead.
func (*EntityMeta) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_Entity_proto_rawDescGZIP(), []int{2}
}</span>

func (x *EntityMeta) GetCreatedTimestamp() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedTimestamp
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *EntityMeta) GetLastUpdatedTimestamp() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LastUpdatedTimestamp
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type EntityList struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Entities []*Entity `protobuf:"bytes,1,rep,name=entities,proto3" json:"entities,omitempty"`
}

func (x *EntityList) Reset() <span class="cov8" title="1">{
        *x = EntityList{}
        if protoimpl.UnsafeEnabled </span><span class="cov8" title="1">{
                mi := &amp;file_feast_core_Entity_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *EntityList) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*EntityList) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *EntityList) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_Entity_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov8" title="1">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov8" title="1">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov8" title="1">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use EntityList.ProtoReflect.Descriptor instead.
func (*EntityList) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_Entity_proto_rawDescGZIP(), []int{3}
}</span>

func (x *EntityList) GetEntities() []*Entity <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.Entities
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_feast_core_Entity_proto protoreflect.FileDescriptor

var file_feast_core_Entity_proto_rawDesc = []byte{
        0x0a, 0x17, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x45, 0x6e, 0x74,
        0x69, 0x74, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0a, 0x66, 0x65, 0x61, 0x73, 0x74,
        0x2e, 0x63, 0x6f, 0x72, 0x65, 0x1a, 0x17, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x74, 0x79, 0x70,
        0x65, 0x73, 0x2f, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1f,
        0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f,
        0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22,
        0x62, 0x0a, 0x06, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x12, 0x2c, 0x0a, 0x04, 0x73, 0x70, 0x65,
        0x63, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e,
        0x63, 0x6f, 0x72, 0x65, 0x2e, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x53, 0x70, 0x65, 0x63, 0x56,
        0x32, 0x52, 0x04, 0x73, 0x70, 0x65, 0x63, 0x12, 0x2a, 0x0a, 0x04, 0x6d, 0x65, 0x74, 0x61, 0x18,
        0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f,
        0x72, 0x65, 0x2e, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x4d, 0x65, 0x74, 0x61, 0x52, 0x04, 0x6d,
        0x65, 0x74, 0x61, 0x22, 0xbc, 0x02, 0x0a, 0x0c, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x53, 0x70,
        0x65, 0x63, 0x56, 0x32, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x70, 0x72, 0x6f, 0x6a,
        0x65, 0x63, 0x74, 0x18, 0x09, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x70, 0x72, 0x6f, 0x6a, 0x65,
        0x63, 0x74, 0x12, 0x3a, 0x0a, 0x0a, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x5f, 0x74, 0x79, 0x70, 0x65,
        0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1b, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x74,
        0x79, 0x70, 0x65, 0x73, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x54, 0x79, 0x70, 0x65, 0x2e, 0x45,
        0x6e, 0x75, 0x6d, 0x52, 0x09, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x54, 0x79, 0x70, 0x65, 0x12, 0x20,
        0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e,
        0x12, 0x19, 0x0a, 0x08, 0x6a, 0x6f, 0x69, 0x6e, 0x5f, 0x6b, 0x65, 0x79, 0x18, 0x04, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x07, 0x6a, 0x6f, 0x69, 0x6e, 0x4b, 0x65, 0x79, 0x12, 0x36, 0x0a, 0x04, 0x74,
        0x61, 0x67, 0x73, 0x18, 0x08, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x22, 0x2e, 0x66, 0x65, 0x61, 0x73,
        0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x53, 0x70, 0x65,
        0x63, 0x56, 0x32, 0x2e, 0x54, 0x61, 0x67, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x04, 0x74,
        0x61, 0x67, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x18, 0x0a, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x1a, 0x37, 0x0a, 0x09, 0x54, 0x61, 0x67,
        0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75,
        0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02,
        0x38, 0x01, 0x22, 0xa7, 0x01, 0x0a, 0x0a, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x4d, 0x65, 0x74,
        0x61, 0x12, 0x47, 0x0a, 0x11, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x74, 0x69, 0x6d,
        0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67,
        0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54,
        0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x10, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65,
        0x64, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x12, 0x50, 0x0a, 0x16, 0x6c, 0x61,
        0x73, 0x74, 0x5f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x73,
        0x74, 0x61, 0x6d, 0x70, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f,
        0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d,
        0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x14, 0x6c, 0x61, 0x73, 0x74, 0x55, 0x70, 0x64, 0x61,
        0x74, 0x65, 0x64, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x22, 0x3c, 0x0a, 0x0a,
        0x45, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x4c, 0x69, 0x73, 0x74, 0x12, 0x2e, 0x0a, 0x08, 0x65, 0x6e,
        0x74, 0x69, 0x74, 0x69, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x66,
        0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x79,
        0x52, 0x08, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x69, 0x65, 0x73, 0x42, 0x50, 0x0a, 0x10, 0x66, 0x65,
        0x61, 0x73, 0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x42, 0x0b,
        0x45, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x5a, 0x2f, 0x67, 0x69, 0x74,
        0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2d, 0x64, 0x65,
        0x76, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x67, 0x6f, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x73, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x62, 0x06, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_feast_core_Entity_proto_rawDescOnce sync.Once
        file_feast_core_Entity_proto_rawDescData = file_feast_core_Entity_proto_rawDesc
)

func file_feast_core_Entity_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_feast_core_Entity_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_feast_core_Entity_proto_rawDescData = protoimpl.X.CompressGZIP(file_feast_core_Entity_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_feast_core_Entity_proto_rawDescData</span>
}

var file_feast_core_Entity_proto_msgTypes = make([]protoimpl.MessageInfo, 5)
var file_feast_core_Entity_proto_goTypes = []interface{}{
        (*Entity)(nil),                // 0: feast.core.Entity
        (*EntitySpecV2)(nil),          // 1: feast.core.EntitySpecV2
        (*EntityMeta)(nil),            // 2: feast.core.EntityMeta
        (*EntityList)(nil),            // 3: feast.core.EntityList
        nil,                           // 4: feast.core.EntitySpecV2.TagsEntry
        (types.ValueType_Enum)(0),     // 5: feast.types.ValueType.Enum
        (*timestamppb.Timestamp)(nil), // 6: google.protobuf.Timestamp
}
var file_feast_core_Entity_proto_depIdxs = []int32{
        1, // 0: feast.core.Entity.spec:type_name -&gt; feast.core.EntitySpecV2
        2, // 1: feast.core.Entity.meta:type_name -&gt; feast.core.EntityMeta
        5, // 2: feast.core.EntitySpecV2.value_type:type_name -&gt; feast.types.ValueType.Enum
        4, // 3: feast.core.EntitySpecV2.tags:type_name -&gt; feast.core.EntitySpecV2.TagsEntry
        6, // 4: feast.core.EntityMeta.created_timestamp:type_name -&gt; google.protobuf.Timestamp
        6, // 5: feast.core.EntityMeta.last_updated_timestamp:type_name -&gt; google.protobuf.Timestamp
        0, // 6: feast.core.EntityList.entities:type_name -&gt; feast.core.Entity
        7, // [7:7] is the sub-list for method output_type
        7, // [7:7] is the sub-list for method input_type
        7, // [7:7] is the sub-list for extension type_name
        7, // [7:7] is the sub-list for extension extendee
        0, // [0:7] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_feast_core_Entity_proto_init() }</span>
func file_feast_core_Entity_proto_init() <span class="cov8" title="1">{
        if File_feast_core_Entity_proto != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_feast_core_Entity_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Entity); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_Entity_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*EntitySpecV2); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_Entity_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*EntityMeta); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_Entity_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*EntityList); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_feast_core_Entity_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   5,
                        NumExtensions: 0,
                        NumServices:   0,
                },
                GoTypes:           file_feast_core_Entity_proto_goTypes,
                DependencyIndexes: file_feast_core_Entity_proto_depIdxs,
                MessageInfos:      file_feast_core_Entity_proto_msgTypes,
        }.Build()
        File_feast_core_Entity_proto = out.File
        file_feast_core_Entity_proto_rawDesc = nil
        file_feast_core_Entity_proto_goTypes = nil
        file_feast_core_Entity_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">//
// Copyright 2020 The Feast Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.31.0
//         protoc        v4.25.1
// source: feast/core/Feature.proto

package core

import (
        types "github.com/feast-dev/feast/go/protos/feast/types"
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type FeatureSpecV2 struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Name of the feature. Not updatable.
        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        // Value type of the feature. Not updatable.
        ValueType types.ValueType_Enum `protobuf:"varint,2,opt,name=value_type,json=valueType,proto3,enum=feast.types.ValueType_Enum" json:"value_type,omitempty"`
        // Tags for user defined metadata on a feature
        Tags        map[string]string `protobuf:"bytes,3,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        Description string            `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
}

func (x *FeatureSpecV2) Reset() <span class="cov0" title="0">{
        *x = FeatureSpecV2{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_Feature_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *FeatureSpecV2) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FeatureSpecV2) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FeatureSpecV2) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_Feature_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use FeatureSpecV2.ProtoReflect.Descriptor instead.
func (*FeatureSpecV2) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_Feature_proto_rawDescGZIP(), []int{0}
}</span>

func (x *FeatureSpecV2) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *FeatureSpecV2) GetValueType() types.ValueType_Enum <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ValueType
        }</span>
        <span class="cov0" title="0">return types.ValueType_Enum(0)</span>
}

func (x *FeatureSpecV2) GetTags() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tags
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FeatureSpecV2) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

var File_feast_core_Feature_proto protoreflect.FileDescriptor

var file_feast_core_Feature_proto_rawDesc = []byte{
        0x0a, 0x18, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x46, 0x65, 0x61,
        0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0a, 0x66, 0x65, 0x61, 0x73,
        0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x1a, 0x17, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x74, 0x79,
        0x70, 0x65, 0x73, 0x2f, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22,
        0xf3, 0x01, 0x0a, 0x0d, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x53, 0x70, 0x65, 0x63, 0x56,
        0x32, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x3a, 0x0a, 0x0a, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x5f, 0x74,
        0x79, 0x70, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1b, 0x2e, 0x66, 0x65, 0x61, 0x73,
        0x74, 0x2e, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x54, 0x79, 0x70,
        0x65, 0x2e, 0x45, 0x6e, 0x75, 0x6d, 0x52, 0x09, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x54, 0x79, 0x70,
        0x65, 0x12, 0x37, 0x0a, 0x04, 0x74, 0x61, 0x67, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32,
        0x23, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x46, 0x65, 0x61,
        0x74, 0x75, 0x72, 0x65, 0x53, 0x70, 0x65, 0x63, 0x56, 0x32, 0x2e, 0x54, 0x61, 0x67, 0x73, 0x45,
        0x6e, 0x74, 0x72, 0x79, 0x52, 0x04, 0x74, 0x61, 0x67, 0x73, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65,
        0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x1a, 0x37, 0x0a, 0x09,
        0x54, 0x61, 0x67, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76,
        0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75,
        0x65, 0x3a, 0x02, 0x38, 0x01, 0x42, 0x51, 0x0a, 0x10, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x42, 0x0c, 0x46, 0x65, 0x61, 0x74, 0x75,
        0x72, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x5a, 0x2f, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e,
        0x63, 0x6f, 0x6d, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2d, 0x64, 0x65, 0x76, 0x2f, 0x66, 0x65,
        0x61, 0x73, 0x74, 0x2f, 0x67, 0x6f, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x73, 0x2f, 0x66, 0x65,
        0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_feast_core_Feature_proto_rawDescOnce sync.Once
        file_feast_core_Feature_proto_rawDescData = file_feast_core_Feature_proto_rawDesc
)

func file_feast_core_Feature_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_feast_core_Feature_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_feast_core_Feature_proto_rawDescData = protoimpl.X.CompressGZIP(file_feast_core_Feature_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_feast_core_Feature_proto_rawDescData</span>
}

var file_feast_core_Feature_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_feast_core_Feature_proto_goTypes = []interface{}{
        (*FeatureSpecV2)(nil),     // 0: feast.core.FeatureSpecV2
        nil,                       // 1: feast.core.FeatureSpecV2.TagsEntry
        (types.ValueType_Enum)(0), // 2: feast.types.ValueType.Enum
}
var file_feast_core_Feature_proto_depIdxs = []int32{
        2, // 0: feast.core.FeatureSpecV2.value_type:type_name -&gt; feast.types.ValueType.Enum
        1, // 1: feast.core.FeatureSpecV2.tags:type_name -&gt; feast.core.FeatureSpecV2.TagsEntry
        2, // [2:2] is the sub-list for method output_type
        2, // [2:2] is the sub-list for method input_type
        2, // [2:2] is the sub-list for extension type_name
        2, // [2:2] is the sub-list for extension extendee
        0, // [0:2] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_feast_core_Feature_proto_init() }</span>
func file_feast_core_Feature_proto_init() <span class="cov8" title="1">{
        if File_feast_core_Feature_proto != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_feast_core_Feature_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*FeatureSpecV2); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_feast_core_Feature_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   2,
                        NumExtensions: 0,
                        NumServices:   0,
                },
                GoTypes:           file_feast_core_Feature_proto_goTypes,
                DependencyIndexes: file_feast_core_Feature_proto_depIdxs,
                MessageInfos:      file_feast_core_Feature_proto_msgTypes,
        }.Build()
        File_feast_core_Feature_proto = out.File
        file_feast_core_Feature_proto_rawDesc = nil
        file_feast_core_Feature_proto_goTypes = nil
        file_feast_core_Feature_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.31.0
//         protoc        v4.25.1
// source: feast/core/FeatureService.proto

package core

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type FeatureService struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // User-specified specifications of this feature service.
        Spec *FeatureServiceSpec `protobuf:"bytes,1,opt,name=spec,proto3" json:"spec,omitempty"`
        // System-populated metadata for this feature service.
        Meta *FeatureServiceMeta `protobuf:"bytes,2,opt,name=meta,proto3" json:"meta,omitempty"`
}

func (x *FeatureService) Reset() <span class="cov0" title="0">{
        *x = FeatureService{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_FeatureService_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *FeatureService) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FeatureService) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FeatureService) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_FeatureService_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use FeatureService.ProtoReflect.Descriptor instead.
func (*FeatureService) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_FeatureService_proto_rawDescGZIP(), []int{0}
}</span>

func (x *FeatureService) GetSpec() *FeatureServiceSpec <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.Spec
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FeatureService) GetMeta() *FeatureServiceMeta <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Meta
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type FeatureServiceSpec struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Name of the Feature Service. Must be unique. Not updated.
        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        // Name of Feast project that this Feature Service belongs to.
        Project string `protobuf:"bytes,2,opt,name=project,proto3" json:"project,omitempty"`
        // Represents a projection that's to be applied on top of the FeatureView.
        // Contains data such as the features to use from a FeatureView.
        Features []*FeatureViewProjection `protobuf:"bytes,3,rep,name=features,proto3" json:"features,omitempty"`
        // User defined metadata
        Tags map[string]string `protobuf:"bytes,4,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        // Description of the feature service.
        Description string `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
        // Owner of the feature service.
        Owner string `protobuf:"bytes,6,opt,name=owner,proto3" json:"owner,omitempty"`
        // (optional) if provided logging will be enabled for this feature service.
        LoggingConfig *LoggingConfig `protobuf:"bytes,7,opt,name=logging_config,json=loggingConfig,proto3" json:"logging_config,omitempty"`
}

func (x *FeatureServiceSpec) Reset() <span class="cov0" title="0">{
        *x = FeatureServiceSpec{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_FeatureService_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *FeatureServiceSpec) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FeatureServiceSpec) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FeatureServiceSpec) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_FeatureService_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use FeatureServiceSpec.ProtoReflect.Descriptor instead.
func (*FeatureServiceSpec) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_FeatureService_proto_rawDescGZIP(), []int{1}
}</span>

func (x *FeatureServiceSpec) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *FeatureServiceSpec) GetProject() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Project
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *FeatureServiceSpec) GetFeatures() []*FeatureViewProjection <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Features
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FeatureServiceSpec) GetTags() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tags
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FeatureServiceSpec) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *FeatureServiceSpec) GetOwner() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Owner
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *FeatureServiceSpec) GetLoggingConfig() *LoggingConfig <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.LoggingConfig
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type FeatureServiceMeta struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Time where this Feature Service is created
        CreatedTimestamp *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=created_timestamp,json=createdTimestamp,proto3" json:"created_timestamp,omitempty"`
        // Time where this Feature Service is last updated
        LastUpdatedTimestamp *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=last_updated_timestamp,json=lastUpdatedTimestamp,proto3" json:"last_updated_timestamp,omitempty"`
}

func (x *FeatureServiceMeta) Reset() <span class="cov0" title="0">{
        *x = FeatureServiceMeta{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_FeatureService_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *FeatureServiceMeta) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FeatureServiceMeta) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FeatureServiceMeta) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_FeatureService_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use FeatureServiceMeta.ProtoReflect.Descriptor instead.
func (*FeatureServiceMeta) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_FeatureService_proto_rawDescGZIP(), []int{2}
}</span>

func (x *FeatureServiceMeta) GetCreatedTimestamp() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedTimestamp
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FeatureServiceMeta) GetLastUpdatedTimestamp() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LastUpdatedTimestamp
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type LoggingConfig struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        SampleRate float32 `protobuf:"fixed32,1,opt,name=sample_rate,json=sampleRate,proto3" json:"sample_rate,omitempty"`
        // Types that are assignable to Destination:
        //
        //        *LoggingConfig_FileDestination_
        //        *LoggingConfig_BigqueryDestination
        //        *LoggingConfig_RedshiftDestination_
        //        *LoggingConfig_SnowflakeDestination_
        //        *LoggingConfig_CustomDestination_
        //        *LoggingConfig_AthenaDestination_
        Destination isLoggingConfig_Destination `protobuf_oneof:"destination"`
}

func (x *LoggingConfig) Reset() <span class="cov0" title="0">{
        *x = LoggingConfig{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_FeatureService_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *LoggingConfig) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LoggingConfig) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LoggingConfig) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_FeatureService_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use LoggingConfig.ProtoReflect.Descriptor instead.
func (*LoggingConfig) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_FeatureService_proto_rawDescGZIP(), []int{3}
}</span>

func (x *LoggingConfig) GetSampleRate() float32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SampleRate
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (m *LoggingConfig) GetDestination() isLoggingConfig_Destination <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Destination
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *LoggingConfig) GetFileDestination() *LoggingConfig_FileDestination <span class="cov0" title="0">{
        if x, ok := x.GetDestination().(*LoggingConfig_FileDestination_); ok </span><span class="cov0" title="0">{
                return x.FileDestination
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *LoggingConfig) GetBigqueryDestination() *LoggingConfig_BigQueryDestination <span class="cov0" title="0">{
        if x, ok := x.GetDestination().(*LoggingConfig_BigqueryDestination); ok </span><span class="cov0" title="0">{
                return x.BigqueryDestination
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *LoggingConfig) GetRedshiftDestination() *LoggingConfig_RedshiftDestination <span class="cov0" title="0">{
        if x, ok := x.GetDestination().(*LoggingConfig_RedshiftDestination_); ok </span><span class="cov0" title="0">{
                return x.RedshiftDestination
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *LoggingConfig) GetSnowflakeDestination() *LoggingConfig_SnowflakeDestination <span class="cov0" title="0">{
        if x, ok := x.GetDestination().(*LoggingConfig_SnowflakeDestination_); ok </span><span class="cov0" title="0">{
                return x.SnowflakeDestination
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *LoggingConfig) GetCustomDestination() *LoggingConfig_CustomDestination <span class="cov0" title="0">{
        if x, ok := x.GetDestination().(*LoggingConfig_CustomDestination_); ok </span><span class="cov0" title="0">{
                return x.CustomDestination
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *LoggingConfig) GetAthenaDestination() *LoggingConfig_AthenaDestination <span class="cov0" title="0">{
        if x, ok := x.GetDestination().(*LoggingConfig_AthenaDestination_); ok </span><span class="cov0" title="0">{
                return x.AthenaDestination
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type isLoggingConfig_Destination interface {
        isLoggingConfig_Destination()
}

type LoggingConfig_FileDestination_ struct {
        FileDestination *LoggingConfig_FileDestination `protobuf:"bytes,3,opt,name=file_destination,json=fileDestination,proto3,oneof"`
}

type LoggingConfig_BigqueryDestination struct {
        BigqueryDestination *LoggingConfig_BigQueryDestination `protobuf:"bytes,4,opt,name=bigquery_destination,json=bigqueryDestination,proto3,oneof"`
}

type LoggingConfig_RedshiftDestination_ struct {
        RedshiftDestination *LoggingConfig_RedshiftDestination `protobuf:"bytes,5,opt,name=redshift_destination,json=redshiftDestination,proto3,oneof"`
}

type LoggingConfig_SnowflakeDestination_ struct {
        SnowflakeDestination *LoggingConfig_SnowflakeDestination `protobuf:"bytes,6,opt,name=snowflake_destination,json=snowflakeDestination,proto3,oneof"`
}

type LoggingConfig_CustomDestination_ struct {
        CustomDestination *LoggingConfig_CustomDestination `protobuf:"bytes,7,opt,name=custom_destination,json=customDestination,proto3,oneof"`
}

type LoggingConfig_AthenaDestination_ struct {
        AthenaDestination *LoggingConfig_AthenaDestination `protobuf:"bytes,8,opt,name=athena_destination,json=athenaDestination,proto3,oneof"`
}

func (*LoggingConfig_FileDestination_) isLoggingConfig_Destination() {<span class="cov0" title="0">}</span>

func (*LoggingConfig_BigqueryDestination) isLoggingConfig_Destination() {<span class="cov0" title="0">}</span>

func (*LoggingConfig_RedshiftDestination_) isLoggingConfig_Destination() {<span class="cov0" title="0">}</span>

func (*LoggingConfig_SnowflakeDestination_) isLoggingConfig_Destination() {<span class="cov0" title="0">}</span>

func (*LoggingConfig_CustomDestination_) isLoggingConfig_Destination() {<span class="cov0" title="0">}</span>

func (*LoggingConfig_AthenaDestination_) isLoggingConfig_Destination() {<span class="cov0" title="0">}</span>

type FeatureServiceList struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Featureservices []*FeatureService `protobuf:"bytes,1,rep,name=featureservices,proto3" json:"featureservices,omitempty"`
}

func (x *FeatureServiceList) Reset() <span class="cov8" title="1">{
        *x = FeatureServiceList{}
        if protoimpl.UnsafeEnabled </span><span class="cov8" title="1">{
                mi := &amp;file_feast_core_FeatureService_proto_msgTypes[4]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *FeatureServiceList) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FeatureServiceList) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FeatureServiceList) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_FeatureService_proto_msgTypes[4]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov8" title="1">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov8" title="1">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov8" title="1">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use FeatureServiceList.ProtoReflect.Descriptor instead.
func (*FeatureServiceList) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_FeatureService_proto_rawDescGZIP(), []int{4}
}</span>

func (x *FeatureServiceList) GetFeatureservices() []*FeatureService <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.Featureservices
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type LoggingConfig_FileDestination struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Path               string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
        S3EndpointOverride string `protobuf:"bytes,2,opt,name=s3_endpoint_override,json=s3EndpointOverride,proto3" json:"s3_endpoint_override,omitempty"`
        // column names to use for partitioning
        PartitionBy []string `protobuf:"bytes,3,rep,name=partition_by,json=partitionBy,proto3" json:"partition_by,omitempty"`
}

func (x *LoggingConfig_FileDestination) Reset() <span class="cov0" title="0">{
        *x = LoggingConfig_FileDestination{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_FeatureService_proto_msgTypes[6]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *LoggingConfig_FileDestination) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LoggingConfig_FileDestination) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LoggingConfig_FileDestination) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_FeatureService_proto_msgTypes[6]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use LoggingConfig_FileDestination.ProtoReflect.Descriptor instead.
func (*LoggingConfig_FileDestination) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_FeatureService_proto_rawDescGZIP(), []int{3, 0}
}</span>

func (x *LoggingConfig_FileDestination) GetPath() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Path
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LoggingConfig_FileDestination) GetS3EndpointOverride() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.S3EndpointOverride
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LoggingConfig_FileDestination) GetPartitionBy() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.PartitionBy
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type LoggingConfig_BigQueryDestination struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Full table reference in the form of [project:dataset.table]
        TableRef string `protobuf:"bytes,1,opt,name=table_ref,json=tableRef,proto3" json:"table_ref,omitempty"`
}

func (x *LoggingConfig_BigQueryDestination) Reset() <span class="cov0" title="0">{
        *x = LoggingConfig_BigQueryDestination{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_FeatureService_proto_msgTypes[7]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *LoggingConfig_BigQueryDestination) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LoggingConfig_BigQueryDestination) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LoggingConfig_BigQueryDestination) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_FeatureService_proto_msgTypes[7]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use LoggingConfig_BigQueryDestination.ProtoReflect.Descriptor instead.
func (*LoggingConfig_BigQueryDestination) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_FeatureService_proto_rawDescGZIP(), []int{3, 1}
}</span>

func (x *LoggingConfig_BigQueryDestination) GetTableRef() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TableRef
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type LoggingConfig_RedshiftDestination struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Destination table name. ClusterId and database will be taken from an offline store config
        TableName string `protobuf:"bytes,1,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
}

func (x *LoggingConfig_RedshiftDestination) Reset() <span class="cov0" title="0">{
        *x = LoggingConfig_RedshiftDestination{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_FeatureService_proto_msgTypes[8]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *LoggingConfig_RedshiftDestination) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LoggingConfig_RedshiftDestination) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LoggingConfig_RedshiftDestination) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_FeatureService_proto_msgTypes[8]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use LoggingConfig_RedshiftDestination.ProtoReflect.Descriptor instead.
func (*LoggingConfig_RedshiftDestination) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_FeatureService_proto_rawDescGZIP(), []int{3, 2}
}</span>

func (x *LoggingConfig_RedshiftDestination) GetTableName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TableName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type LoggingConfig_AthenaDestination struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Destination table name. data_source and database will be taken from an offline store config
        TableName string `protobuf:"bytes,1,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
}

func (x *LoggingConfig_AthenaDestination) Reset() <span class="cov0" title="0">{
        *x = LoggingConfig_AthenaDestination{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_FeatureService_proto_msgTypes[9]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *LoggingConfig_AthenaDestination) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LoggingConfig_AthenaDestination) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LoggingConfig_AthenaDestination) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_FeatureService_proto_msgTypes[9]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use LoggingConfig_AthenaDestination.ProtoReflect.Descriptor instead.
func (*LoggingConfig_AthenaDestination) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_FeatureService_proto_rawDescGZIP(), []int{3, 3}
}</span>

func (x *LoggingConfig_AthenaDestination) GetTableName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TableName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type LoggingConfig_SnowflakeDestination struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Destination table name. Schema and database will be taken from an offline store config
        TableName string `protobuf:"bytes,1,opt,name=table_name,json=tableName,proto3" json:"table_name,omitempty"`
}

func (x *LoggingConfig_SnowflakeDestination) Reset() <span class="cov0" title="0">{
        *x = LoggingConfig_SnowflakeDestination{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_FeatureService_proto_msgTypes[10]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *LoggingConfig_SnowflakeDestination) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LoggingConfig_SnowflakeDestination) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LoggingConfig_SnowflakeDestination) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_FeatureService_proto_msgTypes[10]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use LoggingConfig_SnowflakeDestination.ProtoReflect.Descriptor instead.
func (*LoggingConfig_SnowflakeDestination) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_FeatureService_proto_rawDescGZIP(), []int{3, 4}
}</span>

func (x *LoggingConfig_SnowflakeDestination) GetTableName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TableName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type LoggingConfig_CustomDestination struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Kind   string            `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
        Config map[string]string `protobuf:"bytes,2,rep,name=config,proto3" json:"config,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (x *LoggingConfig_CustomDestination) Reset() <span class="cov0" title="0">{
        *x = LoggingConfig_CustomDestination{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_FeatureService_proto_msgTypes[11]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *LoggingConfig_CustomDestination) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*LoggingConfig_CustomDestination) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *LoggingConfig_CustomDestination) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_FeatureService_proto_msgTypes[11]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use LoggingConfig_CustomDestination.ProtoReflect.Descriptor instead.
func (*LoggingConfig_CustomDestination) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_FeatureService_proto_rawDescGZIP(), []int{3, 5}
}</span>

func (x *LoggingConfig_CustomDestination) GetKind() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Kind
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *LoggingConfig_CustomDestination) GetConfig() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Config
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_feast_core_FeatureService_proto protoreflect.FileDescriptor

var file_feast_core_FeatureService_proto_rawDesc = []byte{
        0x0a, 0x1f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x46, 0x65, 0x61,
        0x74, 0x75, 0x72, 0x65, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x12, 0x0a, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x1a, 0x1f, 0x67,
        0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x74,
        0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x26,
        0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x46, 0x65, 0x61, 0x74, 0x75,
        0x72, 0x65, 0x56, 0x69, 0x65, 0x77, 0x50, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e,
        0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x78, 0x0a, 0x0e, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72,
        0x65, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x32, 0x0a, 0x04, 0x73, 0x70, 0x65, 0x63,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63,
        0x6f, 0x72, 0x65, 0x2e, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x53, 0x65, 0x72, 0x76, 0x69,
        0x63, 0x65, 0x53, 0x70, 0x65, 0x63, 0x52, 0x04, 0x73, 0x70, 0x65, 0x63, 0x12, 0x32, 0x0a, 0x04,
        0x6d, 0x65, 0x74, 0x61, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x66, 0x65, 0x61,
        0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x53,
        0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x4d, 0x65, 0x74, 0x61, 0x52, 0x04, 0x6d, 0x65, 0x74, 0x61,
        0x22, 0xf2, 0x02, 0x0a, 0x12, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x53, 0x65, 0x72, 0x76,
        0x69, 0x63, 0x65, 0x53, 0x70, 0x65, 0x63, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x70,
        0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x70, 0x72,
        0x6f, 0x6a, 0x65, 0x63, 0x74, 0x12, 0x3d, 0x0a, 0x08, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65,
        0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e,
        0x63, 0x6f, 0x72, 0x65, 0x2e, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77,
        0x50, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x08, 0x66, 0x65, 0x61, 0x74,
        0x75, 0x72, 0x65, 0x73, 0x12, 0x3c, 0x0a, 0x04, 0x74, 0x61, 0x67, 0x73, 0x18, 0x04, 0x20, 0x03,
        0x28, 0x0b, 0x32, 0x28, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e,
        0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x53, 0x70,
        0x65, 0x63, 0x2e, 0x54, 0x61, 0x67, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x04, 0x74, 0x61,
        0x67, 0x73, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f,
        0x6e, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70,
        0x74, 0x69, 0x6f, 0x6e, 0x12, 0x14, 0x0a, 0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x18, 0x06, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x12, 0x40, 0x0a, 0x0e, 0x6c, 0x6f,
        0x67, 0x67, 0x69, 0x6e, 0x67, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x07, 0x20, 0x01,
        0x28, 0x0b, 0x32, 0x19, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e,
        0x4c, 0x6f, 0x67, 0x67, 0x69, 0x6e, 0x67, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x52, 0x0d, 0x6c,
        0x6f, 0x67, 0x67, 0x69, 0x6e, 0x67, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x1a, 0x37, 0x0a, 0x09,
        0x54, 0x61, 0x67, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76,
        0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75,
        0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0xaf, 0x01, 0x0a, 0x12, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72,
        0x65, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x4d, 0x65, 0x74, 0x61, 0x12, 0x47, 0x0a, 0x11,
        0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d,
        0x70, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
        0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74,
        0x61, 0x6d, 0x70, 0x52, 0x10, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x54, 0x69, 0x6d, 0x65,
        0x73, 0x74, 0x61, 0x6d, 0x70, 0x12, 0x50, 0x0a, 0x16, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x75, 0x70,
        0x64, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18,
        0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d,
        0x70, 0x52, 0x14, 0x6c, 0x61, 0x73, 0x74, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x54, 0x69,
        0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x22, 0x89, 0x09, 0x0a, 0x0d, 0x4c, 0x6f, 0x67, 0x67,
        0x69, 0x6e, 0x67, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x1f, 0x0a, 0x0b, 0x73, 0x61, 0x6d,
        0x70, 0x6c, 0x65, 0x5f, 0x72, 0x61, 0x74, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x02, 0x52, 0x0a,
        0x73, 0x61, 0x6d, 0x70, 0x6c, 0x65, 0x52, 0x61, 0x74, 0x65, 0x12, 0x56, 0x0a, 0x10, 0x66, 0x69,
        0x6c, 0x65, 0x5f, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03,
        0x20, 0x01, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72,
        0x65, 0x2e, 0x4c, 0x6f, 0x67, 0x67, 0x69, 0x6e, 0x67, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x2e,
        0x46, 0x69, 0x6c, 0x65, 0x44, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x48,
        0x00, 0x52, 0x0f, 0x66, 0x69, 0x6c, 0x65, 0x44, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69,
        0x6f, 0x6e, 0x12, 0x62, 0x0a, 0x14, 0x62, 0x69, 0x67, 0x71, 0x75, 0x65, 0x72, 0x79, 0x5f, 0x64,
        0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b,
        0x32, 0x2d, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x4c, 0x6f,
        0x67, 0x67, 0x69, 0x6e, 0x67, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x2e, 0x42, 0x69, 0x67, 0x51,
        0x75, 0x65, 0x72, 0x79, 0x44, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x48,
        0x00, 0x52, 0x13, 0x62, 0x69, 0x67, 0x71, 0x75, 0x65, 0x72, 0x79, 0x44, 0x65, 0x73, 0x74, 0x69,
        0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x62, 0x0a, 0x14, 0x72, 0x65, 0x64, 0x73, 0x68, 0x69,
        0x66, 0x74, 0x5f, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x05,
        0x20, 0x01, 0x28, 0x0b, 0x32, 0x2d, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72,
        0x65, 0x2e, 0x4c, 0x6f, 0x67, 0x67, 0x69, 0x6e, 0x67, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x2e,
        0x52, 0x65, 0x64, 0x73, 0x68, 0x69, 0x66, 0x74, 0x44, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74,
        0x69, 0x6f, 0x6e, 0x48, 0x00, 0x52, 0x13, 0x72, 0x65, 0x64, 0x73, 0x68, 0x69, 0x66, 0x74, 0x44,
        0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x65, 0x0a, 0x15, 0x73, 0x6e,
        0x6f, 0x77, 0x66, 0x6c, 0x61, 0x6b, 0x65, 0x5f, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74,
        0x69, 0x6f, 0x6e, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2e, 0x2e, 0x66, 0x65, 0x61, 0x73,
        0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x4c, 0x6f, 0x67, 0x67, 0x69, 0x6e, 0x67, 0x43, 0x6f,
        0x6e, 0x66, 0x69, 0x67, 0x2e, 0x53, 0x6e, 0x6f, 0x77, 0x66, 0x6c, 0x61, 0x6b, 0x65, 0x44, 0x65,
        0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x48, 0x00, 0x52, 0x14, 0x73, 0x6e, 0x6f,
        0x77, 0x66, 0x6c, 0x61, 0x6b, 0x65, 0x44, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f,
        0x6e, 0x12, 0x5c, 0x0a, 0x12, 0x63, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x5f, 0x64, 0x65, 0x73, 0x74,
        0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2b, 0x2e,
        0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x4c, 0x6f, 0x67, 0x67, 0x69,
        0x6e, 0x67, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x2e, 0x43, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x44,
        0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x48, 0x00, 0x52, 0x11, 0x63, 0x75,
        0x73, 0x74, 0x6f, 0x6d, 0x44, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12,
        0x5c, 0x0a, 0x12, 0x61, 0x74, 0x68, 0x65, 0x6e, 0x61, 0x5f, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e,
        0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2b, 0x2e, 0x66, 0x65,
        0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x4c, 0x6f, 0x67, 0x67, 0x69, 0x6e, 0x67,
        0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x2e, 0x41, 0x74, 0x68, 0x65, 0x6e, 0x61, 0x44, 0x65, 0x73,
        0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x48, 0x00, 0x52, 0x11, 0x61, 0x74, 0x68, 0x65,
        0x6e, 0x61, 0x44, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x1a, 0x7a, 0x0a,
        0x0f, 0x46, 0x69, 0x6c, 0x65, 0x44, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e,
        0x12, 0x12, 0x0a, 0x04, 0x70, 0x61, 0x74, 0x68, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04,
        0x70, 0x61, 0x74, 0x68, 0x12, 0x30, 0x0a, 0x14, 0x73, 0x33, 0x5f, 0x65, 0x6e, 0x64, 0x70, 0x6f,
        0x69, 0x6e, 0x74, 0x5f, 0x6f, 0x76, 0x65, 0x72, 0x72, 0x69, 0x64, 0x65, 0x18, 0x02, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x12, 0x73, 0x33, 0x45, 0x6e, 0x64, 0x70, 0x6f, 0x69, 0x6e, 0x74, 0x4f, 0x76,
        0x65, 0x72, 0x72, 0x69, 0x64, 0x65, 0x12, 0x21, 0x0a, 0x0c, 0x70, 0x61, 0x72, 0x74, 0x69, 0x74,
        0x69, 0x6f, 0x6e, 0x5f, 0x62, 0x79, 0x18, 0x03, 0x20, 0x03, 0x28, 0x09, 0x52, 0x0b, 0x70, 0x61,
        0x72, 0x74, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x42, 0x79, 0x1a, 0x32, 0x0a, 0x13, 0x42, 0x69, 0x67,
        0x51, 0x75, 0x65, 0x72, 0x79, 0x44, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e,
        0x12, 0x1b, 0x0a, 0x09, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x72, 0x65, 0x66, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x08, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x52, 0x65, 0x66, 0x1a, 0x34, 0x0a,
        0x13, 0x52, 0x65, 0x64, 0x73, 0x68, 0x69, 0x66, 0x74, 0x44, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61,
        0x74, 0x69, 0x6f, 0x6e, 0x12, 0x1d, 0x0a, 0x0a, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x6e, 0x61,
        0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x4e,
        0x61, 0x6d, 0x65, 0x1a, 0x32, 0x0a, 0x11, 0x41, 0x74, 0x68, 0x65, 0x6e, 0x61, 0x44, 0x65, 0x73,
        0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x1d, 0x0a, 0x0a, 0x74, 0x61, 0x62, 0x6c,
        0x65, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x74, 0x61,
        0x62, 0x6c, 0x65, 0x4e, 0x61, 0x6d, 0x65, 0x1a, 0x35, 0x0a, 0x14, 0x53, 0x6e, 0x6f, 0x77, 0x66,
        0x6c, 0x61, 0x6b, 0x65, 0x44, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12,
        0x1d, 0x0a, 0x0a, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x09, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x4e, 0x61, 0x6d, 0x65, 0x1a, 0xb3,
        0x01, 0x0a, 0x11, 0x43, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x44, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61,
        0x74, 0x69, 0x6f, 0x6e, 0x12, 0x12, 0x0a, 0x04, 0x6b, 0x69, 0x6e, 0x64, 0x18, 0x01, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x04, 0x6b, 0x69, 0x6e, 0x64, 0x12, 0x4f, 0x0a, 0x06, 0x63, 0x6f, 0x6e, 0x66,
        0x69, 0x67, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x37, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74,
        0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x4c, 0x6f, 0x67, 0x67, 0x69, 0x6e, 0x67, 0x43, 0x6f, 0x6e,
        0x66, 0x69, 0x67, 0x2e, 0x43, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x44, 0x65, 0x73, 0x74, 0x69, 0x6e,
        0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x45, 0x6e, 0x74, 0x72,
        0x79, 0x52, 0x06, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x1a, 0x39, 0x0a, 0x0b, 0x43, 0x6f, 0x6e,
        0x66, 0x69, 0x67, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61,
        0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65,
        0x3a, 0x02, 0x38, 0x01, 0x42, 0x0d, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x74, 0x69, 0x6e, 0x61, 0x74,
        0x69, 0x6f, 0x6e, 0x22, 0x5a, 0x0a, 0x12, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x53, 0x65,
        0x72, 0x76, 0x69, 0x63, 0x65, 0x4c, 0x69, 0x73, 0x74, 0x12, 0x44, 0x0a, 0x0f, 0x66, 0x65, 0x61,
        0x74, 0x75, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03,
        0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e,
        0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x52, 0x0f,
        0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x42,
        0x58, 0x0a, 0x10, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x63,
        0x6f, 0x72, 0x65, 0x42, 0x13, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x53, 0x65, 0x72, 0x76,
        0x69, 0x63, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x5a, 0x2f, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62,
        0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2d, 0x64, 0x65, 0x76, 0x2f, 0x66,
        0x65, 0x61, 0x73, 0x74, 0x2f, 0x67, 0x6f, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x73, 0x2f, 0x66,
        0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x33,
}

var (
        file_feast_core_FeatureService_proto_rawDescOnce sync.Once
        file_feast_core_FeatureService_proto_rawDescData = file_feast_core_FeatureService_proto_rawDesc
)

func file_feast_core_FeatureService_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_feast_core_FeatureService_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_feast_core_FeatureService_proto_rawDescData = protoimpl.X.CompressGZIP(file_feast_core_FeatureService_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_feast_core_FeatureService_proto_rawDescData</span>
}

var file_feast_core_FeatureService_proto_msgTypes = make([]protoimpl.MessageInfo, 13)
var file_feast_core_FeatureService_proto_goTypes = []interface{}{
        (*FeatureService)(nil),                     // 0: feast.core.FeatureService
        (*FeatureServiceSpec)(nil),                 // 1: feast.core.FeatureServiceSpec
        (*FeatureServiceMeta)(nil),                 // 2: feast.core.FeatureServiceMeta
        (*LoggingConfig)(nil),                      // 3: feast.core.LoggingConfig
        (*FeatureServiceList)(nil),                 // 4: feast.core.FeatureServiceList
        nil,                                        // 5: feast.core.FeatureServiceSpec.TagsEntry
        (*LoggingConfig_FileDestination)(nil),      // 6: feast.core.LoggingConfig.FileDestination
        (*LoggingConfig_BigQueryDestination)(nil),  // 7: feast.core.LoggingConfig.BigQueryDestination
        (*LoggingConfig_RedshiftDestination)(nil),  // 8: feast.core.LoggingConfig.RedshiftDestination
        (*LoggingConfig_AthenaDestination)(nil),    // 9: feast.core.LoggingConfig.AthenaDestination
        (*LoggingConfig_SnowflakeDestination)(nil), // 10: feast.core.LoggingConfig.SnowflakeDestination
        (*LoggingConfig_CustomDestination)(nil),    // 11: feast.core.LoggingConfig.CustomDestination
        nil,                                        // 12: feast.core.LoggingConfig.CustomDestination.ConfigEntry
        (*FeatureViewProjection)(nil),              // 13: feast.core.FeatureViewProjection
        (*timestamppb.Timestamp)(nil),              // 14: google.protobuf.Timestamp
}
var file_feast_core_FeatureService_proto_depIdxs = []int32{
        1,  // 0: feast.core.FeatureService.spec:type_name -&gt; feast.core.FeatureServiceSpec
        2,  // 1: feast.core.FeatureService.meta:type_name -&gt; feast.core.FeatureServiceMeta
        13, // 2: feast.core.FeatureServiceSpec.features:type_name -&gt; feast.core.FeatureViewProjection
        5,  // 3: feast.core.FeatureServiceSpec.tags:type_name -&gt; feast.core.FeatureServiceSpec.TagsEntry
        3,  // 4: feast.core.FeatureServiceSpec.logging_config:type_name -&gt; feast.core.LoggingConfig
        14, // 5: feast.core.FeatureServiceMeta.created_timestamp:type_name -&gt; google.protobuf.Timestamp
        14, // 6: feast.core.FeatureServiceMeta.last_updated_timestamp:type_name -&gt; google.protobuf.Timestamp
        6,  // 7: feast.core.LoggingConfig.file_destination:type_name -&gt; feast.core.LoggingConfig.FileDestination
        7,  // 8: feast.core.LoggingConfig.bigquery_destination:type_name -&gt; feast.core.LoggingConfig.BigQueryDestination
        8,  // 9: feast.core.LoggingConfig.redshift_destination:type_name -&gt; feast.core.LoggingConfig.RedshiftDestination
        10, // 10: feast.core.LoggingConfig.snowflake_destination:type_name -&gt; feast.core.LoggingConfig.SnowflakeDestination
        11, // 11: feast.core.LoggingConfig.custom_destination:type_name -&gt; feast.core.LoggingConfig.CustomDestination
        9,  // 12: feast.core.LoggingConfig.athena_destination:type_name -&gt; feast.core.LoggingConfig.AthenaDestination
        0,  // 13: feast.core.FeatureServiceList.featureservices:type_name -&gt; feast.core.FeatureService
        12, // 14: feast.core.LoggingConfig.CustomDestination.config:type_name -&gt; feast.core.LoggingConfig.CustomDestination.ConfigEntry
        15, // [15:15] is the sub-list for method output_type
        15, // [15:15] is the sub-list for method input_type
        15, // [15:15] is the sub-list for extension type_name
        15, // [15:15] is the sub-list for extension extendee
        0,  // [0:15] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_feast_core_FeatureService_proto_init() }</span>
func file_feast_core_FeatureService_proto_init() <span class="cov8" title="1">{
        if File_feast_core_FeatureService_proto != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">file_feast_core_FeatureViewProjection_proto_init()
        if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_feast_core_FeatureService_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*FeatureService); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_FeatureService_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*FeatureServiceSpec); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_FeatureService_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*FeatureServiceMeta); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_FeatureService_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*LoggingConfig); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_FeatureService_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*FeatureServiceList); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_FeatureService_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*LoggingConfig_FileDestination); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_FeatureService_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*LoggingConfig_BigQueryDestination); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_FeatureService_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*LoggingConfig_RedshiftDestination); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_FeatureService_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*LoggingConfig_AthenaDestination); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_FeatureService_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*LoggingConfig_SnowflakeDestination); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_FeatureService_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*LoggingConfig_CustomDestination); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">file_feast_core_FeatureService_proto_msgTypes[3].OneofWrappers = []interface{}{
                (*LoggingConfig_FileDestination_)(nil),
                (*LoggingConfig_BigqueryDestination)(nil),
                (*LoggingConfig_RedshiftDestination_)(nil),
                (*LoggingConfig_SnowflakeDestination_)(nil),
                (*LoggingConfig_CustomDestination_)(nil),
                (*LoggingConfig_AthenaDestination_)(nil),
        }
        type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_feast_core_FeatureService_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   13,
                        NumExtensions: 0,
                        NumServices:   0,
                },
                GoTypes:           file_feast_core_FeatureService_proto_goTypes,
                DependencyIndexes: file_feast_core_FeatureService_proto_depIdxs,
                MessageInfos:      file_feast_core_FeatureService_proto_msgTypes,
        }.Build()
        File_feast_core_FeatureService_proto = out.File
        file_feast_core_FeatureService_proto_rawDesc = nil
        file_feast_core_FeatureService_proto_goTypes = nil
        file_feast_core_FeatureService_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">//
// Copyright 2020 The Feast Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.31.0
//         protoc        v4.25.1
// source: feast/core/FeatureTable.proto

package core

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        durationpb "google.golang.org/protobuf/types/known/durationpb"
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type FeatureTable struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // User-specified specifications of this feature table.
        Spec *FeatureTableSpec `protobuf:"bytes,1,opt,name=spec,proto3" json:"spec,omitempty"`
        // System-populated metadata for this feature table.
        Meta *FeatureTableMeta `protobuf:"bytes,2,opt,name=meta,proto3" json:"meta,omitempty"`
}

func (x *FeatureTable) Reset() <span class="cov0" title="0">{
        *x = FeatureTable{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_FeatureTable_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *FeatureTable) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FeatureTable) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FeatureTable) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_FeatureTable_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use FeatureTable.ProtoReflect.Descriptor instead.
func (*FeatureTable) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_FeatureTable_proto_rawDescGZIP(), []int{0}
}</span>

func (x *FeatureTable) GetSpec() *FeatureTableSpec <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Spec
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FeatureTable) GetMeta() *FeatureTableMeta <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Meta
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type FeatureTableSpec struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Name of the feature table. Must be unique. Not updated.
        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        // Name of Feast project that this feature table belongs to.
        Project string `protobuf:"bytes,9,opt,name=project,proto3" json:"project,omitempty"`
        // List names of entities to associate with the Features defined in this
        // Feature Table. Not updatable.
        Entities []string `protobuf:"bytes,3,rep,name=entities,proto3" json:"entities,omitempty"`
        // List of features specifications for each feature defined with this feature table.
        Features []*FeatureSpecV2 `protobuf:"bytes,4,rep,name=features,proto3" json:"features,omitempty"`
        // User defined metadata
        Labels map[string]string `protobuf:"bytes,5,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        // Features in this feature table can only be retrieved from online serving
        // younger than max age. Age is measured as the duration of time between
        // the feature's event timestamp and when the feature is retrieved
        // Feature values outside max age will be returned as unset values and indicated to end user
        MaxAge *durationpb.Duration `protobuf:"bytes,6,opt,name=max_age,json=maxAge,proto3" json:"max_age,omitempty"`
        // Batch/Offline DataSource to source batch/offline feature data.
        // Only batch DataSource can be specified
        // (ie source type should start with 'BATCH_')
        BatchSource *DataSource `protobuf:"bytes,7,opt,name=batch_source,json=batchSource,proto3" json:"batch_source,omitempty"`
        // Stream/Online DataSource to source stream/online feature data.
        // Only stream DataSource can be specified
        // (ie source type should start with 'STREAM_')
        StreamSource *DataSource `protobuf:"bytes,8,opt,name=stream_source,json=streamSource,proto3" json:"stream_source,omitempty"`
}

func (x *FeatureTableSpec) Reset() <span class="cov0" title="0">{
        *x = FeatureTableSpec{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_FeatureTable_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *FeatureTableSpec) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FeatureTableSpec) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FeatureTableSpec) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_feast_core_FeatureTable_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use FeatureTableSpec.ProtoReflect.Descriptor instead.
func (*FeatureTableSpec) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_FeatureTable_proto_rawDescGZIP(), []int{1}
}</span>

func (x *FeatureTableSpec) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *FeatureTableSpec) GetProject() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Project
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *FeatureTableSpec) GetEntities() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Entities
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FeatureTableSpec) GetFeatures() []*FeatureSpecV2 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Features
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FeatureTableSpec) GetLabels() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Labels
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FeatureTableSpec) GetMaxAge() *durationpb.Duration <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MaxAge
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FeatureTableSpec) GetBatchSource() *DataSource <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.BatchSource
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FeatureTableSpec) GetStreamSource() *DataSource <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.StreamSource
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type FeatureTableMeta struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Time where this Feature Table is created
        CreatedTimestamp *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=created_timestamp,json=createdTimestamp,proto3" json:"created_timestamp,omitempty"`
        // Time where this Feature Table is last updated
        LastUpdatedTimestamp *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=last_updated_timestamp,json=lastUpdatedTimestamp,proto3" json:"last_updated_timestamp,omitempty"`
        // Auto incrementing revision no. of this Feature Table
        Revision int64 `protobuf:"varint,3,opt,name=revision,proto3" json:"revision,omitempty"`
        // Hash entities, features, batch_source and stream_source to inform JobService if
        // jobs should be restarted should hash change
        Hash string `protobuf:"bytes,4,opt,name=hash,proto3" json:"hash,omitempty"`
}

func (x *FeatureTableMeta) Reset() <span class="cov0" title="0">{
        *x = FeatureTableMeta{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_FeatureTable_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *FeatureTableMeta) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FeatureTableMeta) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FeatureTableMeta) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_feast_core_FeatureTable_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use FeatureTableMeta.ProtoReflect.Descriptor instead.
func (*FeatureTableMeta) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_FeatureTable_proto_rawDescGZIP(), []int{2}
}</span>

func (x *FeatureTableMeta) GetCreatedTimestamp() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedTimestamp
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FeatureTableMeta) GetLastUpdatedTimestamp() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LastUpdatedTimestamp
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FeatureTableMeta) GetRevision() int64 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Revision
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *FeatureTableMeta) GetHash() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Hash
        }</span>
        <span class="cov0" title="0">return ""</span>
}

var File_feast_core_FeatureTable_proto protoreflect.FileDescriptor

var file_feast_core_FeatureTable_proto_rawDesc = []byte{
        0x0a, 0x1d, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x46, 0x65, 0x61,
        0x74, 0x75, 0x72, 0x65, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12,
        0x0a, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x1a, 0x1e, 0x67, 0x6f, 0x6f,
        0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x64, 0x75, 0x72,
        0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1f, 0x67, 0x6f, 0x6f,
        0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x74, 0x69, 0x6d,
        0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1b, 0x66, 0x65,
        0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x44, 0x61, 0x74, 0x61, 0x53, 0x6f, 0x75,
        0x72, 0x63, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x18, 0x66, 0x65, 0x61, 0x73, 0x74,
        0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x22, 0x72, 0x0a, 0x0c, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x54, 0x61,
        0x62, 0x6c, 0x65, 0x12, 0x30, 0x0a, 0x04, 0x73, 0x70, 0x65, 0x63, 0x18, 0x01, 0x20, 0x01, 0x28,
        0x0b, 0x32, 0x1c, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x46,
        0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x53, 0x70, 0x65, 0x63, 0x52,
        0x04, 0x73, 0x70, 0x65, 0x63, 0x12, 0x30, 0x0a, 0x04, 0x6d, 0x65, 0x74, 0x61, 0x18, 0x02, 0x20,
        0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65,
        0x2e, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x4d, 0x65, 0x74,
        0x61, 0x52, 0x04, 0x6d, 0x65, 0x74, 0x61, 0x22, 0xbc, 0x03, 0x0a, 0x10, 0x46, 0x65, 0x61, 0x74,
        0x75, 0x72, 0x65, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x53, 0x70, 0x65, 0x63, 0x12, 0x12, 0x0a, 0x04,
        0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65,
        0x12, 0x18, 0x0a, 0x07, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x18, 0x09, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x07, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x12, 0x1a, 0x0a, 0x08, 0x65, 0x6e,
        0x74, 0x69, 0x74, 0x69, 0x65, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x09, 0x52, 0x08, 0x65, 0x6e,
        0x74, 0x69, 0x74, 0x69, 0x65, 0x73, 0x12, 0x35, 0x0a, 0x08, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72,
        0x65, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74,
        0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x53, 0x70, 0x65,
        0x63, 0x56, 0x32, 0x52, 0x08, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x12, 0x40, 0x0a,
        0x06, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x28, 0x2e,
        0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x46, 0x65, 0x61, 0x74, 0x75,
        0x72, 0x65, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x53, 0x70, 0x65, 0x63, 0x2e, 0x4c, 0x61, 0x62, 0x65,
        0x6c, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x06, 0x6c, 0x61, 0x62, 0x65, 0x6c, 0x73, 0x12,
        0x32, 0x0a, 0x07, 0x6d, 0x61, 0x78, 0x5f, 0x61, 0x67, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b,
        0x32, 0x19, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62,
        0x75, 0x66, 0x2e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x06, 0x6d, 0x61, 0x78,
        0x41, 0x67, 0x65, 0x12, 0x39, 0x0a, 0x0c, 0x62, 0x61, 0x74, 0x63, 0x68, 0x5f, 0x73, 0x6f, 0x75,
        0x72, 0x63, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x66, 0x65, 0x61, 0x73,
        0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x53, 0x6f, 0x75, 0x72, 0x63,
        0x65, 0x52, 0x0b, 0x62, 0x61, 0x74, 0x63, 0x68, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x12, 0x3b,
        0x0a, 0x0d, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x5f, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x18,
        0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f,
        0x72, 0x65, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x52, 0x0c, 0x73,
        0x74, 0x72, 0x65, 0x61, 0x6d, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x1a, 0x39, 0x0a, 0x0b, 0x4c,
        0x61, 0x62, 0x65, 0x6c, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65,
        0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05,
        0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c,
        0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0xdd, 0x01, 0x0a, 0x10, 0x46, 0x65, 0x61, 0x74, 0x75,
        0x72, 0x65, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x4d, 0x65, 0x74, 0x61, 0x12, 0x47, 0x0a, 0x11, 0x63,
        0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61,
        0x6d, 0x70, 0x52, 0x10, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x54, 0x69, 0x6d, 0x65, 0x73,
        0x74, 0x61, 0x6d, 0x70, 0x12, 0x50, 0x0a, 0x16, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x75, 0x70, 0x64,
        0x61, 0x74, 0x65, 0x64, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x02,
        0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70,
        0x52, 0x14, 0x6c, 0x61, 0x73, 0x74, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x54, 0x69, 0x6d,
        0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x12, 0x1a, 0x0a, 0x08, 0x72, 0x65, 0x76, 0x69, 0x73, 0x69,
        0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x03, 0x52, 0x08, 0x72, 0x65, 0x76, 0x69, 0x73, 0x69,
        0x6f, 0x6e, 0x12, 0x12, 0x0a, 0x04, 0x68, 0x61, 0x73, 0x68, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x04, 0x68, 0x61, 0x73, 0x68, 0x42, 0x56, 0x0a, 0x10, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x42, 0x11, 0x46, 0x65, 0x61, 0x74,
        0x75, 0x72, 0x65, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x5a, 0x2f, 0x67,
        0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2d,
        0x64, 0x65, 0x76, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x67, 0x6f, 0x2f, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x73, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x62, 0x06,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_feast_core_FeatureTable_proto_rawDescOnce sync.Once
        file_feast_core_FeatureTable_proto_rawDescData = file_feast_core_FeatureTable_proto_rawDesc
)

func file_feast_core_FeatureTable_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_feast_core_FeatureTable_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_feast_core_FeatureTable_proto_rawDescData = protoimpl.X.CompressGZIP(file_feast_core_FeatureTable_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_feast_core_FeatureTable_proto_rawDescData</span>
}

var file_feast_core_FeatureTable_proto_msgTypes = make([]protoimpl.MessageInfo, 4)
var file_feast_core_FeatureTable_proto_goTypes = []interface{}{
        (*FeatureTable)(nil),          // 0: feast.core.FeatureTable
        (*FeatureTableSpec)(nil),      // 1: feast.core.FeatureTableSpec
        (*FeatureTableMeta)(nil),      // 2: feast.core.FeatureTableMeta
        nil,                           // 3: feast.core.FeatureTableSpec.LabelsEntry
        (*FeatureSpecV2)(nil),         // 4: feast.core.FeatureSpecV2
        (*durationpb.Duration)(nil),   // 5: google.protobuf.Duration
        (*DataSource)(nil),            // 6: feast.core.DataSource
        (*timestamppb.Timestamp)(nil), // 7: google.protobuf.Timestamp
}
var file_feast_core_FeatureTable_proto_depIdxs = []int32{
        1, // 0: feast.core.FeatureTable.spec:type_name -&gt; feast.core.FeatureTableSpec
        2, // 1: feast.core.FeatureTable.meta:type_name -&gt; feast.core.FeatureTableMeta
        4, // 2: feast.core.FeatureTableSpec.features:type_name -&gt; feast.core.FeatureSpecV2
        3, // 3: feast.core.FeatureTableSpec.labels:type_name -&gt; feast.core.FeatureTableSpec.LabelsEntry
        5, // 4: feast.core.FeatureTableSpec.max_age:type_name -&gt; google.protobuf.Duration
        6, // 5: feast.core.FeatureTableSpec.batch_source:type_name -&gt; feast.core.DataSource
        6, // 6: feast.core.FeatureTableSpec.stream_source:type_name -&gt; feast.core.DataSource
        7, // 7: feast.core.FeatureTableMeta.created_timestamp:type_name -&gt; google.protobuf.Timestamp
        7, // 8: feast.core.FeatureTableMeta.last_updated_timestamp:type_name -&gt; google.protobuf.Timestamp
        9, // [9:9] is the sub-list for method output_type
        9, // [9:9] is the sub-list for method input_type
        9, // [9:9] is the sub-list for extension type_name
        9, // [9:9] is the sub-list for extension extendee
        0, // [0:9] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_feast_core_FeatureTable_proto_init() }</span>
func file_feast_core_FeatureTable_proto_init() <span class="cov8" title="1">{
        if File_feast_core_FeatureTable_proto != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">file_feast_core_DataSource_proto_init()
        file_feast_core_Feature_proto_init()
        if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_feast_core_FeatureTable_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*FeatureTable); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_FeatureTable_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*FeatureTableSpec); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_FeatureTable_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*FeatureTableMeta); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_feast_core_FeatureTable_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   4,
                        NumExtensions: 0,
                        NumServices:   0,
                },
                GoTypes:           file_feast_core_FeatureTable_proto_goTypes,
                DependencyIndexes: file_feast_core_FeatureTable_proto_depIdxs,
                MessageInfos:      file_feast_core_FeatureTable_proto_msgTypes,
        }.Build()
        File_feast_core_FeatureTable_proto = out.File
        file_feast_core_FeatureTable_proto_rawDesc = nil
        file_feast_core_FeatureTable_proto_goTypes = nil
        file_feast_core_FeatureTable_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">//
// Copyright 2020 The Feast Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.31.0
//         protoc        v4.25.1
// source: feast/core/FeatureView.proto

package core

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        durationpb "google.golang.org/protobuf/types/known/durationpb"
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type FeatureView struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // User-specified specifications of this feature view.
        Spec *FeatureViewSpec `protobuf:"bytes,1,opt,name=spec,proto3" json:"spec,omitempty"`
        // System-populated metadata for this feature view.
        Meta *FeatureViewMeta `protobuf:"bytes,2,opt,name=meta,proto3" json:"meta,omitempty"`
}

func (x *FeatureView) Reset() <span class="cov0" title="0">{
        *x = FeatureView{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_FeatureView_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *FeatureView) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FeatureView) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FeatureView) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_FeatureView_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use FeatureView.ProtoReflect.Descriptor instead.
func (*FeatureView) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_FeatureView_proto_rawDescGZIP(), []int{0}
}</span>

func (x *FeatureView) GetSpec() *FeatureViewSpec <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Spec
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FeatureView) GetMeta() *FeatureViewMeta <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Meta
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Next available id: 13
// TODO(adchia): refactor common fields from this and ODFV into separate metadata proto
type FeatureViewSpec struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Name of the feature view. Must be unique. Not updated.
        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        // Name of Feast project that this feature view belongs to.
        Project string `protobuf:"bytes,2,opt,name=project,proto3" json:"project,omitempty"`
        // List of names of entities associated with this feature view.
        Entities []string `protobuf:"bytes,3,rep,name=entities,proto3" json:"entities,omitempty"`
        // List of specifications for each feature defined as part of this feature view.
        Features []*FeatureSpecV2 `protobuf:"bytes,4,rep,name=features,proto3" json:"features,omitempty"`
        // List of specifications for each entity defined as part of this feature view.
        EntityColumns []*FeatureSpecV2 `protobuf:"bytes,12,rep,name=entity_columns,json=entityColumns,proto3" json:"entity_columns,omitempty"`
        // Description of the feature view.
        Description string `protobuf:"bytes,10,opt,name=description,proto3" json:"description,omitempty"`
        // User defined metadata
        Tags map[string]string `protobuf:"bytes,5,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        // Owner of the feature view.
        Owner string `protobuf:"bytes,11,opt,name=owner,proto3" json:"owner,omitempty"`
        // Features in this feature view can only be retrieved from online serving
        // younger than ttl. Ttl is measured as the duration of time between
        // the feature's event timestamp and when the feature is retrieved
        // Feature values outside ttl will be returned as unset values and indicated to end user
        Ttl *durationpb.Duration `protobuf:"bytes,6,opt,name=ttl,proto3" json:"ttl,omitempty"`
        // Batch/Offline DataSource where this view can retrieve offline feature data.
        BatchSource *DataSource `protobuf:"bytes,7,opt,name=batch_source,json=batchSource,proto3" json:"batch_source,omitempty"`
        // Streaming DataSource from where this view can consume "online" feature data.
        StreamSource *DataSource `protobuf:"bytes,9,opt,name=stream_source,json=streamSource,proto3" json:"stream_source,omitempty"`
        // Whether these features should be served online or not
        Online bool `protobuf:"varint,8,opt,name=online,proto3" json:"online,omitempty"`
        // User-specified specifications of this entity.
        // Adding higher index to avoid conflicts in future
        // if Feast adds more fields
        OriginalEntities []*Entity `protobuf:"bytes,30,rep,name=original_entities,json=originalEntities,proto3" json:"original_entities,omitempty"`
}

func (x *FeatureViewSpec) Reset() <span class="cov0" title="0">{
        *x = FeatureViewSpec{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_FeatureView_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *FeatureViewSpec) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FeatureViewSpec) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FeatureViewSpec) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_FeatureView_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use FeatureViewSpec.ProtoReflect.Descriptor instead.
func (*FeatureViewSpec) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_FeatureView_proto_rawDescGZIP(), []int{1}
}</span>

func (x *FeatureViewSpec) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *FeatureViewSpec) GetProject() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Project
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *FeatureViewSpec) GetEntities() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Entities
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FeatureViewSpec) GetFeatures() []*FeatureSpecV2 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Features
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FeatureViewSpec) GetEntityColumns() []*FeatureSpecV2 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.EntityColumns
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FeatureViewSpec) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *FeatureViewSpec) GetTags() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tags
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FeatureViewSpec) GetOwner() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Owner
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *FeatureViewSpec) GetTtl() *durationpb.Duration <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Ttl
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FeatureViewSpec) GetBatchSource() *DataSource <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.BatchSource
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FeatureViewSpec) GetStreamSource() *DataSource <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.StreamSource
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FeatureViewSpec) GetOnline() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Online
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *FeatureViewSpec) GetOriginalEntities() []*Entity <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OriginalEntities
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type FeatureViewMeta struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Time where this Feature View is created
        CreatedTimestamp *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=created_timestamp,json=createdTimestamp,proto3" json:"created_timestamp,omitempty"`
        // Time where this Feature View is last updated
        LastUpdatedTimestamp *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=last_updated_timestamp,json=lastUpdatedTimestamp,proto3" json:"last_updated_timestamp,omitempty"`
        // List of pairs (start_time, end_time) for which this feature view has been materialized.
        MaterializationIntervals []*MaterializationInterval `protobuf:"bytes,3,rep,name=materialization_intervals,json=materializationIntervals,proto3" json:"materialization_intervals,omitempty"`
}

func (x *FeatureViewMeta) Reset() <span class="cov0" title="0">{
        *x = FeatureViewMeta{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_FeatureView_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *FeatureViewMeta) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FeatureViewMeta) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FeatureViewMeta) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_FeatureView_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use FeatureViewMeta.ProtoReflect.Descriptor instead.
func (*FeatureViewMeta) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_FeatureView_proto_rawDescGZIP(), []int{2}
}</span>

func (x *FeatureViewMeta) GetCreatedTimestamp() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedTimestamp
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FeatureViewMeta) GetLastUpdatedTimestamp() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LastUpdatedTimestamp
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FeatureViewMeta) GetMaterializationIntervals() []*MaterializationInterval <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MaterializationIntervals
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type MaterializationInterval struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        StartTime *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
        EndTime   *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=end_time,json=endTime,proto3" json:"end_time,omitempty"`
}

func (x *MaterializationInterval) Reset() <span class="cov0" title="0">{
        *x = MaterializationInterval{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_FeatureView_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *MaterializationInterval) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*MaterializationInterval) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *MaterializationInterval) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_FeatureView_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use MaterializationInterval.ProtoReflect.Descriptor instead.
func (*MaterializationInterval) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_FeatureView_proto_rawDescGZIP(), []int{3}
}</span>

func (x *MaterializationInterval) GetStartTime() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.StartTime
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *MaterializationInterval) GetEndTime() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.EndTime
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type FeatureViewList struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Featureviews []*FeatureView `protobuf:"bytes,1,rep,name=featureviews,proto3" json:"featureviews,omitempty"`
}

func (x *FeatureViewList) Reset() <span class="cov8" title="1">{
        *x = FeatureViewList{}
        if protoimpl.UnsafeEnabled </span><span class="cov8" title="1">{
                mi := &amp;file_feast_core_FeatureView_proto_msgTypes[4]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *FeatureViewList) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FeatureViewList) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FeatureViewList) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_FeatureView_proto_msgTypes[4]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov8" title="1">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov8" title="1">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov8" title="1">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use FeatureViewList.ProtoReflect.Descriptor instead.
func (*FeatureViewList) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_FeatureView_proto_rawDescGZIP(), []int{4}
}</span>

func (x *FeatureViewList) GetFeatureviews() []*FeatureView <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.Featureviews
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_feast_core_FeatureView_proto protoreflect.FileDescriptor

var file_feast_core_FeatureView_proto_rawDesc = []byte{
        0x0a, 0x1c, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x46, 0x65, 0x61,
        0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0a,
        0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x1a, 0x1e, 0x67, 0x6f, 0x6f, 0x67,
        0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x64, 0x75, 0x72, 0x61,
        0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1f, 0x67, 0x6f, 0x6f, 0x67,
        0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x74, 0x69, 0x6d, 0x65,
        0x73, 0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1b, 0x66, 0x65, 0x61,
        0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x44, 0x61, 0x74, 0x61, 0x53, 0x6f, 0x75, 0x72,
        0x63, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x18, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f,
        0x63, 0x6f, 0x72, 0x65, 0x2f, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x1a, 0x17, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x45,
        0x6e, 0x74, 0x69, 0x74, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x6f, 0x0a, 0x0b, 0x46,
        0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77, 0x12, 0x2f, 0x0a, 0x04, 0x73, 0x70,
        0x65, 0x63, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74,
        0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65,
        0x77, 0x53, 0x70, 0x65, 0x63, 0x52, 0x04, 0x73, 0x70, 0x65, 0x63, 0x12, 0x2f, 0x0a, 0x04, 0x6d,
        0x65, 0x74, 0x61, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x66, 0x65, 0x61, 0x73,
        0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69,
        0x65, 0x77, 0x4d, 0x65, 0x74, 0x61, 0x52, 0x04, 0x6d, 0x65, 0x74, 0x61, 0x22, 0xfe, 0x04, 0x0a,
        0x0f, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77, 0x53, 0x70, 0x65, 0x63,
        0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04,
        0x6e, 0x61, 0x6d, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x18,
        0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x12, 0x1a,
        0x0a, 0x08, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x69, 0x65, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x09,
        0x52, 0x08, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x69, 0x65, 0x73, 0x12, 0x35, 0x0a, 0x08, 0x66, 0x65,
        0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x66,
        0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72,
        0x65, 0x53, 0x70, 0x65, 0x63, 0x56, 0x32, 0x52, 0x08, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65,
        0x73, 0x12, 0x40, 0x0a, 0x0e, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x5f, 0x63, 0x6f, 0x6c, 0x75,
        0x6d, 0x6e, 0x73, 0x18, 0x0c, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x66, 0x65, 0x61, 0x73,
        0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x53, 0x70,
        0x65, 0x63, 0x56, 0x32, 0x52, 0x0d, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x43, 0x6f, 0x6c, 0x75,
        0x6d, 0x6e, 0x73, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69,
        0x6f, 0x6e, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69,
        0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x39, 0x0a, 0x04, 0x74, 0x61, 0x67, 0x73, 0x18, 0x05, 0x20,
        0x03, 0x28, 0x0b, 0x32, 0x25, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65,
        0x2e, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77, 0x53, 0x70, 0x65, 0x63,
        0x2e, 0x54, 0x61, 0x67, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x04, 0x74, 0x61, 0x67, 0x73,
        0x12, 0x14, 0x0a, 0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x12, 0x2b, 0x0a, 0x03, 0x74, 0x74, 0x6c, 0x18, 0x06, 0x20,
        0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x03,
        0x74, 0x74, 0x6c, 0x12, 0x39, 0x0a, 0x0c, 0x62, 0x61, 0x74, 0x63, 0x68, 0x5f, 0x73, 0x6f, 0x75,
        0x72, 0x63, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x66, 0x65, 0x61, 0x73,
        0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x53, 0x6f, 0x75, 0x72, 0x63,
        0x65, 0x52, 0x0b, 0x62, 0x61, 0x74, 0x63, 0x68, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x12, 0x3b,
        0x0a, 0x0d, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x5f, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x18,
        0x09, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f,
        0x72, 0x65, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x52, 0x0c, 0x73,
        0x74, 0x72, 0x65, 0x61, 0x6d, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x6f,
        0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x18, 0x08, 0x20, 0x01, 0x28, 0x08, 0x52, 0x06, 0x6f, 0x6e, 0x6c,
        0x69, 0x6e, 0x65, 0x12, 0x3f, 0x0a, 0x11, 0x6f, 0x72, 0x69, 0x67, 0x69, 0x6e, 0x61, 0x6c, 0x5f,
        0x65, 0x6e, 0x74, 0x69, 0x74, 0x69, 0x65, 0x73, 0x18, 0x1e, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x12,
        0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x45, 0x6e, 0x74, 0x69,
        0x74, 0x79, 0x52, 0x10, 0x6f, 0x72, 0x69, 0x67, 0x69, 0x6e, 0x61, 0x6c, 0x45, 0x6e, 0x74, 0x69,
        0x74, 0x69, 0x65, 0x73, 0x1a, 0x37, 0x0a, 0x09, 0x54, 0x61, 0x67, 0x73, 0x45, 0x6e, 0x74, 0x72,
        0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03,
        0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0x8e, 0x02,
        0x0a, 0x0f, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77, 0x4d, 0x65, 0x74,
        0x61, 0x12, 0x47, 0x0a, 0x11, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x74, 0x69, 0x6d,
        0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67,
        0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54,
        0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x10, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65,
        0x64, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x12, 0x50, 0x0a, 0x16, 0x6c, 0x61,
        0x73, 0x74, 0x5f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x73,
        0x74, 0x61, 0x6d, 0x70, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f,
        0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d,
        0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x14, 0x6c, 0x61, 0x73, 0x74, 0x55, 0x70, 0x64, 0x61,
        0x74, 0x65, 0x64, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x12, 0x60, 0x0a, 0x19,
        0x6d, 0x61, 0x74, 0x65, 0x72, 0x69, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f,
        0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32,
        0x23, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x4d, 0x61, 0x74,
        0x65, 0x72, 0x69, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x6e, 0x74, 0x65,
        0x72, 0x76, 0x61, 0x6c, 0x52, 0x18, 0x6d, 0x61, 0x74, 0x65, 0x72, 0x69, 0x61, 0x6c, 0x69, 0x7a,
        0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x73, 0x22, 0x8b,
        0x01, 0x0a, 0x17, 0x4d, 0x61, 0x74, 0x65, 0x72, 0x69, 0x61, 0x6c, 0x69, 0x7a, 0x61, 0x74, 0x69,
        0x6f, 0x6e, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x12, 0x39, 0x0a, 0x0a, 0x73, 0x74,
        0x61, 0x72, 0x74, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a,
        0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66,
        0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x09, 0x73, 0x74, 0x61, 0x72,
        0x74, 0x54, 0x69, 0x6d, 0x65, 0x12, 0x35, 0x0a, 0x08, 0x65, 0x6e, 0x64, 0x5f, 0x74, 0x69, 0x6d,
        0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
        0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74,
        0x61, 0x6d, 0x70, 0x52, 0x07, 0x65, 0x6e, 0x64, 0x54, 0x69, 0x6d, 0x65, 0x22, 0x4e, 0x0a, 0x0f,
        0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77, 0x4c, 0x69, 0x73, 0x74, 0x12,
        0x3b, 0x0a, 0x0c, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x76, 0x69, 0x65, 0x77, 0x73, 0x18,
        0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f,
        0x72, 0x65, 0x2e, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77, 0x52, 0x0c,
        0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x76, 0x69, 0x65, 0x77, 0x73, 0x42, 0x55, 0x0a, 0x10,
        0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x63, 0x6f, 0x72, 0x65,
        0x42, 0x10, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77, 0x50, 0x72, 0x6f,
        0x74, 0x6f, 0x5a, 0x2f, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x66,
        0x65, 0x61, 0x73, 0x74, 0x2d, 0x64, 0x65, 0x76, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x67,
        0x6f, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x73, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63,
        0x6f, 0x72, 0x65, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_feast_core_FeatureView_proto_rawDescOnce sync.Once
        file_feast_core_FeatureView_proto_rawDescData = file_feast_core_FeatureView_proto_rawDesc
)

func file_feast_core_FeatureView_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_feast_core_FeatureView_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_feast_core_FeatureView_proto_rawDescData = protoimpl.X.CompressGZIP(file_feast_core_FeatureView_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_feast_core_FeatureView_proto_rawDescData</span>
}

var file_feast_core_FeatureView_proto_msgTypes = make([]protoimpl.MessageInfo, 6)
var file_feast_core_FeatureView_proto_goTypes = []interface{}{
        (*FeatureView)(nil),             // 0: feast.core.FeatureView
        (*FeatureViewSpec)(nil),         // 1: feast.core.FeatureViewSpec
        (*FeatureViewMeta)(nil),         // 2: feast.core.FeatureViewMeta
        (*MaterializationInterval)(nil), // 3: feast.core.MaterializationInterval
        (*FeatureViewList)(nil),         // 4: feast.core.FeatureViewList
        nil,                             // 5: feast.core.FeatureViewSpec.TagsEntry
        (*FeatureSpecV2)(nil),           // 6: feast.core.FeatureSpecV2
        (*durationpb.Duration)(nil),     // 7: google.protobuf.Duration
        (*DataSource)(nil),              // 8: feast.core.DataSource
        (*Entity)(nil),                  // 9: feast.core.Entity
        (*timestamppb.Timestamp)(nil),   // 10: google.protobuf.Timestamp
}
var file_feast_core_FeatureView_proto_depIdxs = []int32{
        1,  // 0: feast.core.FeatureView.spec:type_name -&gt; feast.core.FeatureViewSpec
        2,  // 1: feast.core.FeatureView.meta:type_name -&gt; feast.core.FeatureViewMeta
        6,  // 2: feast.core.FeatureViewSpec.features:type_name -&gt; feast.core.FeatureSpecV2
        6,  // 3: feast.core.FeatureViewSpec.entity_columns:type_name -&gt; feast.core.FeatureSpecV2
        5,  // 4: feast.core.FeatureViewSpec.tags:type_name -&gt; feast.core.FeatureViewSpec.TagsEntry
        7,  // 5: feast.core.FeatureViewSpec.ttl:type_name -&gt; google.protobuf.Duration
        8,  // 6: feast.core.FeatureViewSpec.batch_source:type_name -&gt; feast.core.DataSource
        8,  // 7: feast.core.FeatureViewSpec.stream_source:type_name -&gt; feast.core.DataSource
        9,  // 8: feast.core.FeatureViewSpec.original_entities:type_name -&gt; feast.core.Entity
        10, // 9: feast.core.FeatureViewMeta.created_timestamp:type_name -&gt; google.protobuf.Timestamp
        10, // 10: feast.core.FeatureViewMeta.last_updated_timestamp:type_name -&gt; google.protobuf.Timestamp
        3,  // 11: feast.core.FeatureViewMeta.materialization_intervals:type_name -&gt; feast.core.MaterializationInterval
        10, // 12: feast.core.MaterializationInterval.start_time:type_name -&gt; google.protobuf.Timestamp
        10, // 13: feast.core.MaterializationInterval.end_time:type_name -&gt; google.protobuf.Timestamp
        0,  // 14: feast.core.FeatureViewList.featureviews:type_name -&gt; feast.core.FeatureView
        15, // [15:15] is the sub-list for method output_type
        15, // [15:15] is the sub-list for method input_type
        15, // [15:15] is the sub-list for extension type_name
        15, // [15:15] is the sub-list for extension extendee
        0,  // [0:15] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_feast_core_FeatureView_proto_init() }</span>
func file_feast_core_FeatureView_proto_init() <span class="cov8" title="1">{
        if File_feast_core_FeatureView_proto != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">file_feast_core_DataSource_proto_init()
        file_feast_core_Feature_proto_init()
        file_feast_core_Entity_proto_init()
        if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_feast_core_FeatureView_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*FeatureView); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_FeatureView_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*FeatureViewSpec); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_FeatureView_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*FeatureViewMeta); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_FeatureView_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*MaterializationInterval); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_FeatureView_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*FeatureViewList); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_feast_core_FeatureView_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   6,
                        NumExtensions: 0,
                        NumServices:   0,
                },
                GoTypes:           file_feast_core_FeatureView_proto_goTypes,
                DependencyIndexes: file_feast_core_FeatureView_proto_depIdxs,
                MessageInfos:      file_feast_core_FeatureView_proto_msgTypes,
        }.Build()
        File_feast_core_FeatureView_proto = out.File
        file_feast_core_FeatureView_proto_rawDesc = nil
        file_feast_core_FeatureView_proto_goTypes = nil
        file_feast_core_FeatureView_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.31.0
//         protoc        v4.25.1
// source: feast/core/FeatureViewProjection.proto

package core

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// A projection to be applied on top of a FeatureView.
// Contains the modifications to a FeatureView such as the features subset to use.
type FeatureViewProjection struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // The feature view name
        FeatureViewName string `protobuf:"bytes,1,opt,name=feature_view_name,json=featureViewName,proto3" json:"feature_view_name,omitempty"`
        // Alias for feature view name
        FeatureViewNameAlias string `protobuf:"bytes,3,opt,name=feature_view_name_alias,json=featureViewNameAlias,proto3" json:"feature_view_name_alias,omitempty"`
        // The features of the feature view that are a part of the feature reference.
        FeatureColumns []*FeatureSpecV2 `protobuf:"bytes,2,rep,name=feature_columns,json=featureColumns,proto3" json:"feature_columns,omitempty"`
        // Map for entity join_key overrides of feature data entity join_key to entity data join_key
        JoinKeyMap map[string]string `protobuf:"bytes,4,rep,name=join_key_map,json=joinKeyMap,proto3" json:"join_key_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (x *FeatureViewProjection) Reset() <span class="cov0" title="0">{
        *x = FeatureViewProjection{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_FeatureViewProjection_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *FeatureViewProjection) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FeatureViewProjection) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FeatureViewProjection) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_FeatureViewProjection_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use FeatureViewProjection.ProtoReflect.Descriptor instead.
func (*FeatureViewProjection) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_FeatureViewProjection_proto_rawDescGZIP(), []int{0}
}</span>

func (x *FeatureViewProjection) GetFeatureViewName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FeatureViewName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *FeatureViewProjection) GetFeatureViewNameAlias() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FeatureViewNameAlias
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *FeatureViewProjection) GetFeatureColumns() []*FeatureSpecV2 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FeatureColumns
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FeatureViewProjection) GetJoinKeyMap() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.JoinKeyMap
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_feast_core_FeatureViewProjection_proto protoreflect.FileDescriptor

var file_feast_core_FeatureViewProjection_proto_rawDesc = []byte{
        0x0a, 0x26, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x46, 0x65, 0x61,
        0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77, 0x50, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x69,
        0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0a, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e,
        0x63, 0x6f, 0x72, 0x65, 0x1a, 0x18, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65,
        0x2f, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xd2,
        0x02, 0x0a, 0x15, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77, 0x50, 0x72,
        0x6f, 0x6a, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x2a, 0x0a, 0x11, 0x66, 0x65, 0x61, 0x74,
        0x75, 0x72, 0x65, 0x5f, 0x76, 0x69, 0x65, 0x77, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x0f, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77,
        0x4e, 0x61, 0x6d, 0x65, 0x12, 0x35, 0x0a, 0x17, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x5f,
        0x76, 0x69, 0x65, 0x77, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x5f, 0x61, 0x6c, 0x69, 0x61, 0x73, 0x18,
        0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x14, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69,
        0x65, 0x77, 0x4e, 0x61, 0x6d, 0x65, 0x41, 0x6c, 0x69, 0x61, 0x73, 0x12, 0x42, 0x0a, 0x0f, 0x66,
        0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x5f, 0x63, 0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x73, 0x18, 0x02,
        0x20, 0x03, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72,
        0x65, 0x2e, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x53, 0x70, 0x65, 0x63, 0x56, 0x32, 0x52,
        0x0e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x43, 0x6f, 0x6c, 0x75, 0x6d, 0x6e, 0x73, 0x12,
        0x53, 0x0a, 0x0c, 0x6a, 0x6f, 0x69, 0x6e, 0x5f, 0x6b, 0x65, 0x79, 0x5f, 0x6d, 0x61, 0x70, 0x18,
        0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x31, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f,
        0x72, 0x65, 0x2e, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77, 0x50, 0x72,
        0x6f, 0x6a, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x4a, 0x6f, 0x69, 0x6e, 0x4b, 0x65, 0x79,
        0x4d, 0x61, 0x70, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x0a, 0x6a, 0x6f, 0x69, 0x6e, 0x4b, 0x65,
        0x79, 0x4d, 0x61, 0x70, 0x1a, 0x3d, 0x0a, 0x0f, 0x4a, 0x6f, 0x69, 0x6e, 0x4b, 0x65, 0x79, 0x4d,
        0x61, 0x70, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c,
        0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a,
        0x02, 0x38, 0x01, 0x42, 0x5a, 0x0a, 0x10, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x42, 0x15, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65,
        0x52, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x63, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x5a, 0x2f,
        0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74,
        0x2d, 0x64, 0x65, 0x76, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x67, 0x6f, 0x2f, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x73, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x62,
        0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_feast_core_FeatureViewProjection_proto_rawDescOnce sync.Once
        file_feast_core_FeatureViewProjection_proto_rawDescData = file_feast_core_FeatureViewProjection_proto_rawDesc
)

func file_feast_core_FeatureViewProjection_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_feast_core_FeatureViewProjection_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_feast_core_FeatureViewProjection_proto_rawDescData = protoimpl.X.CompressGZIP(file_feast_core_FeatureViewProjection_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_feast_core_FeatureViewProjection_proto_rawDescData</span>
}

var file_feast_core_FeatureViewProjection_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_feast_core_FeatureViewProjection_proto_goTypes = []interface{}{
        (*FeatureViewProjection)(nil), // 0: feast.core.FeatureViewProjection
        nil,                           // 1: feast.core.FeatureViewProjection.JoinKeyMapEntry
        (*FeatureSpecV2)(nil),         // 2: feast.core.FeatureSpecV2
}
var file_feast_core_FeatureViewProjection_proto_depIdxs = []int32{
        2, // 0: feast.core.FeatureViewProjection.feature_columns:type_name -&gt; feast.core.FeatureSpecV2
        1, // 1: feast.core.FeatureViewProjection.join_key_map:type_name -&gt; feast.core.FeatureViewProjection.JoinKeyMapEntry
        2, // [2:2] is the sub-list for method output_type
        2, // [2:2] is the sub-list for method input_type
        2, // [2:2] is the sub-list for extension type_name
        2, // [2:2] is the sub-list for extension extendee
        0, // [0:2] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_feast_core_FeatureViewProjection_proto_init() }</span>
func file_feast_core_FeatureViewProjection_proto_init() <span class="cov8" title="1">{
        if File_feast_core_FeatureViewProjection_proto != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">file_feast_core_Feature_proto_init()
        if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_feast_core_FeatureViewProjection_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*FeatureViewProjection); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_feast_core_FeatureViewProjection_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   2,
                        NumExtensions: 0,
                        NumServices:   0,
                },
                GoTypes:           file_feast_core_FeatureViewProjection_proto_goTypes,
                DependencyIndexes: file_feast_core_FeatureViewProjection_proto_depIdxs,
                MessageInfos:      file_feast_core_FeatureViewProjection_proto_msgTypes,
        }.Build()
        File_feast_core_FeatureViewProjection_proto = out.File
        file_feast_core_FeatureViewProjection_proto_rawDesc = nil
        file_feast_core_FeatureViewProjection_proto_goTypes = nil
        file_feast_core_FeatureViewProjection_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">//
// * Copyright 2021 The Feast Authors
// *
// * Licensed under the Apache License, Version 2.0 (the "License");
// * you may not use this file except in compliance with the License.
// * You may obtain a copy of the License at
// *
// *     https://www.apache.org/licenses/LICENSE-2.0
// *
// * Unless required by applicable law or agreed to in writing, software
// * distributed under the License is distributed on an "AS IS" BASIS,
// * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// * See the License for the specific language governing permissions and
// * limitations under the License.
//

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.31.0
//         protoc        v4.25.1
// source: feast/core/InfraObject.proto

package core

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Represents a set of infrastructure objects managed by Feast
type Infra struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // List of infrastructure objects managed by Feast
        InfraObjects []*InfraObject `protobuf:"bytes,1,rep,name=infra_objects,json=infraObjects,proto3" json:"infra_objects,omitempty"`
}

func (x *Infra) Reset() <span class="cov0" title="0">{
        *x = Infra{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_InfraObject_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Infra) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Infra) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Infra) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_InfraObject_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use Infra.ProtoReflect.Descriptor instead.
func (*Infra) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_InfraObject_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Infra) GetInfraObjects() []*InfraObject <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.InfraObjects
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Represents a single infrastructure object managed by Feast
type InfraObject struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Represents the Python class for the infrastructure object
        InfraObjectClassType string `protobuf:"bytes,1,opt,name=infra_object_class_type,json=infraObjectClassType,proto3" json:"infra_object_class_type,omitempty"`
        // The infrastructure object
        //
        // Types that are assignable to InfraObject:
        //
        //        *InfraObject_DynamodbTable
        //        *InfraObject_DatastoreTable
        //        *InfraObject_SqliteTable
        //        *InfraObject_CustomInfra_
        InfraObject isInfraObject_InfraObject `protobuf_oneof:"infra_object"`
}

func (x *InfraObject) Reset() <span class="cov0" title="0">{
        *x = InfraObject{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_InfraObject_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *InfraObject) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*InfraObject) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *InfraObject) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_InfraObject_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use InfraObject.ProtoReflect.Descriptor instead.
func (*InfraObject) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_InfraObject_proto_rawDescGZIP(), []int{1}
}</span>

func (x *InfraObject) GetInfraObjectClassType() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.InfraObjectClassType
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *InfraObject) GetInfraObject() isInfraObject_InfraObject <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.InfraObject
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *InfraObject) GetDynamodbTable() *DynamoDBTable <span class="cov0" title="0">{
        if x, ok := x.GetInfraObject().(*InfraObject_DynamodbTable); ok </span><span class="cov0" title="0">{
                return x.DynamodbTable
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *InfraObject) GetDatastoreTable() *DatastoreTable <span class="cov0" title="0">{
        if x, ok := x.GetInfraObject().(*InfraObject_DatastoreTable); ok </span><span class="cov0" title="0">{
                return x.DatastoreTable
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *InfraObject) GetSqliteTable() *SqliteTable <span class="cov0" title="0">{
        if x, ok := x.GetInfraObject().(*InfraObject_SqliteTable); ok </span><span class="cov0" title="0">{
                return x.SqliteTable
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *InfraObject) GetCustomInfra() *InfraObject_CustomInfra <span class="cov0" title="0">{
        if x, ok := x.GetInfraObject().(*InfraObject_CustomInfra_); ok </span><span class="cov0" title="0">{
                return x.CustomInfra
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type isInfraObject_InfraObject interface {
        isInfraObject_InfraObject()
}

type InfraObject_DynamodbTable struct {
        DynamodbTable *DynamoDBTable `protobuf:"bytes,2,opt,name=dynamodb_table,json=dynamodbTable,proto3,oneof"`
}

type InfraObject_DatastoreTable struct {
        DatastoreTable *DatastoreTable `protobuf:"bytes,3,opt,name=datastore_table,json=datastoreTable,proto3,oneof"`
}

type InfraObject_SqliteTable struct {
        SqliteTable *SqliteTable `protobuf:"bytes,4,opt,name=sqlite_table,json=sqliteTable,proto3,oneof"`
}

type InfraObject_CustomInfra_ struct {
        CustomInfra *InfraObject_CustomInfra `protobuf:"bytes,100,opt,name=custom_infra,json=customInfra,proto3,oneof"`
}

func (*InfraObject_DynamodbTable) isInfraObject_InfraObject() {<span class="cov0" title="0">}</span>

func (*InfraObject_DatastoreTable) isInfraObject_InfraObject() {<span class="cov0" title="0">}</span>

func (*InfraObject_SqliteTable) isInfraObject_InfraObject() {<span class="cov0" title="0">}</span>

func (*InfraObject_CustomInfra_) isInfraObject_InfraObject() {<span class="cov0" title="0">}</span>

// Allows for custom infra objects to be added
type InfraObject_CustomInfra struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Field []byte `protobuf:"bytes,1,opt,name=field,proto3" json:"field,omitempty"`
}

func (x *InfraObject_CustomInfra) Reset() <span class="cov0" title="0">{
        *x = InfraObject_CustomInfra{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_InfraObject_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *InfraObject_CustomInfra) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*InfraObject_CustomInfra) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *InfraObject_CustomInfra) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_InfraObject_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use InfraObject_CustomInfra.ProtoReflect.Descriptor instead.
func (*InfraObject_CustomInfra) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_InfraObject_proto_rawDescGZIP(), []int{1, 0}
}</span>

func (x *InfraObject_CustomInfra) GetField() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Field
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_feast_core_InfraObject_proto protoreflect.FileDescriptor

var file_feast_core_InfraObject_proto_rawDesc = []byte{
        0x0a, 0x1c, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x49, 0x6e, 0x66,
        0x72, 0x61, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0a,
        0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x1a, 0x1f, 0x66, 0x65, 0x61, 0x73,
        0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x44, 0x61, 0x74, 0x61, 0x73, 0x74, 0x6f, 0x72, 0x65,
        0x54, 0x61, 0x62, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1e, 0x66, 0x65, 0x61,
        0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x44, 0x79, 0x6e, 0x61, 0x6d, 0x6f, 0x44, 0x42,
        0x54, 0x61, 0x62, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1c, 0x66, 0x65, 0x61,
        0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x53, 0x71, 0x6c, 0x69, 0x74, 0x65, 0x54, 0x61,
        0x62, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x45, 0x0a, 0x05, 0x49, 0x6e, 0x66,
        0x72, 0x61, 0x12, 0x3c, 0x0a, 0x0d, 0x69, 0x6e, 0x66, 0x72, 0x61, 0x5f, 0x6f, 0x62, 0x6a, 0x65,
        0x63, 0x74, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x66, 0x65, 0x61, 0x73,
        0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x49, 0x6e, 0x66, 0x72, 0x61, 0x4f, 0x62, 0x6a, 0x65,
        0x63, 0x74, 0x52, 0x0c, 0x69, 0x6e, 0x66, 0x72, 0x61, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x73,
        0x22, 0x8c, 0x03, 0x0a, 0x0b, 0x49, 0x6e, 0x66, 0x72, 0x61, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74,
        0x12, 0x35, 0x0a, 0x17, 0x69, 0x6e, 0x66, 0x72, 0x61, 0x5f, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74,
        0x5f, 0x63, 0x6c, 0x61, 0x73, 0x73, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x14, 0x69, 0x6e, 0x66, 0x72, 0x61, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x43, 0x6c,
        0x61, 0x73, 0x73, 0x54, 0x79, 0x70, 0x65, 0x12, 0x42, 0x0a, 0x0e, 0x64, 0x79, 0x6e, 0x61, 0x6d,
        0x6f, 0x64, 0x62, 0x5f, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32,
        0x19, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x44, 0x79, 0x6e,
        0x61, 0x6d, 0x6f, 0x44, 0x42, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x48, 0x00, 0x52, 0x0d, 0x64, 0x79,
        0x6e, 0x61, 0x6d, 0x6f, 0x64, 0x62, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x12, 0x45, 0x0a, 0x0f, 0x64,
        0x61, 0x74, 0x61, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x5f, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x18, 0x03,
        0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72,
        0x65, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x54, 0x61, 0x62, 0x6c, 0x65,
        0x48, 0x00, 0x52, 0x0e, 0x64, 0x61, 0x74, 0x61, 0x73, 0x74, 0x6f, 0x72, 0x65, 0x54, 0x61, 0x62,
        0x6c, 0x65, 0x12, 0x3c, 0x0a, 0x0c, 0x73, 0x71, 0x6c, 0x69, 0x74, 0x65, 0x5f, 0x74, 0x61, 0x62,
        0x6c, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74,
        0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x53, 0x71, 0x6c, 0x69, 0x74, 0x65, 0x54, 0x61, 0x62, 0x6c,
        0x65, 0x48, 0x00, 0x52, 0x0b, 0x73, 0x71, 0x6c, 0x69, 0x74, 0x65, 0x54, 0x61, 0x62, 0x6c, 0x65,
        0x12, 0x48, 0x0a, 0x0c, 0x63, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x5f, 0x69, 0x6e, 0x66, 0x72, 0x61,
        0x18, 0x64, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63,
        0x6f, 0x72, 0x65, 0x2e, 0x49, 0x6e, 0x66, 0x72, 0x61, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x2e,
        0x43, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x49, 0x6e, 0x66, 0x72, 0x61, 0x48, 0x00, 0x52, 0x0b, 0x63,
        0x75, 0x73, 0x74, 0x6f, 0x6d, 0x49, 0x6e, 0x66, 0x72, 0x61, 0x1a, 0x23, 0x0a, 0x0b, 0x43, 0x75,
        0x73, 0x74, 0x6f, 0x6d, 0x49, 0x6e, 0x66, 0x72, 0x61, 0x12, 0x14, 0x0a, 0x05, 0x66, 0x69, 0x65,
        0x6c, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x05, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x42,
        0x0e, 0x0a, 0x0c, 0x69, 0x6e, 0x66, 0x72, 0x61, 0x5f, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x42,
        0x55, 0x0a, 0x10, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x63,
        0x6f, 0x72, 0x65, 0x42, 0x10, 0x49, 0x6e, 0x66, 0x72, 0x61, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74,
        0x50, 0x72, 0x6f, 0x74, 0x6f, 0x5a, 0x2f, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f,
        0x6d, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2d, 0x64, 0x65, 0x76, 0x2f, 0x66, 0x65, 0x61, 0x73,
        0x74, 0x2f, 0x67, 0x6f, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x73, 0x2f, 0x66, 0x65, 0x61, 0x73,
        0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_feast_core_InfraObject_proto_rawDescOnce sync.Once
        file_feast_core_InfraObject_proto_rawDescData = file_feast_core_InfraObject_proto_rawDesc
)

func file_feast_core_InfraObject_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_feast_core_InfraObject_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_feast_core_InfraObject_proto_rawDescData = protoimpl.X.CompressGZIP(file_feast_core_InfraObject_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_feast_core_InfraObject_proto_rawDescData</span>
}

var file_feast_core_InfraObject_proto_msgTypes = make([]protoimpl.MessageInfo, 3)
var file_feast_core_InfraObject_proto_goTypes = []interface{}{
        (*Infra)(nil),                   // 0: feast.core.Infra
        (*InfraObject)(nil),             // 1: feast.core.InfraObject
        (*InfraObject_CustomInfra)(nil), // 2: feast.core.InfraObject.CustomInfra
        (*DynamoDBTable)(nil),           // 3: feast.core.DynamoDBTable
        (*DatastoreTable)(nil),          // 4: feast.core.DatastoreTable
        (*SqliteTable)(nil),             // 5: feast.core.SqliteTable
}
var file_feast_core_InfraObject_proto_depIdxs = []int32{
        1, // 0: feast.core.Infra.infra_objects:type_name -&gt; feast.core.InfraObject
        3, // 1: feast.core.InfraObject.dynamodb_table:type_name -&gt; feast.core.DynamoDBTable
        4, // 2: feast.core.InfraObject.datastore_table:type_name -&gt; feast.core.DatastoreTable
        5, // 3: feast.core.InfraObject.sqlite_table:type_name -&gt; feast.core.SqliteTable
        2, // 4: feast.core.InfraObject.custom_infra:type_name -&gt; feast.core.InfraObject.CustomInfra
        5, // [5:5] is the sub-list for method output_type
        5, // [5:5] is the sub-list for method input_type
        5, // [5:5] is the sub-list for extension type_name
        5, // [5:5] is the sub-list for extension extendee
        0, // [0:5] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_feast_core_InfraObject_proto_init() }</span>
func file_feast_core_InfraObject_proto_init() <span class="cov8" title="1">{
        if File_feast_core_InfraObject_proto != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">file_feast_core_DatastoreTable_proto_init()
        file_feast_core_DynamoDBTable_proto_init()
        file_feast_core_SqliteTable_proto_init()
        if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_feast_core_InfraObject_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Infra); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_InfraObject_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*InfraObject); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_InfraObject_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*InfraObject_CustomInfra); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">file_feast_core_InfraObject_proto_msgTypes[1].OneofWrappers = []interface{}{
                (*InfraObject_DynamodbTable)(nil),
                (*InfraObject_DatastoreTable)(nil),
                (*InfraObject_SqliteTable)(nil),
                (*InfraObject_CustomInfra_)(nil),
        }
        type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_feast_core_InfraObject_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   3,
                        NumExtensions: 0,
                        NumServices:   0,
                },
                GoTypes:           file_feast_core_InfraObject_proto_goTypes,
                DependencyIndexes: file_feast_core_InfraObject_proto_depIdxs,
                MessageInfos:      file_feast_core_InfraObject_proto_msgTypes,
        }.Build()
        File_feast_core_InfraObject_proto = out.File
        file_feast_core_InfraObject_proto_rawDesc = nil
        file_feast_core_InfraObject_proto_goTypes = nil
        file_feast_core_InfraObject_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">//
// Copyright 2020 The Feast Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.31.0
//         protoc        v4.25.1
// source: feast/core/OnDemandFeatureView.proto

package core

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type OnDemandFeatureView struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // User-specified specifications of this feature view.
        Spec *OnDemandFeatureViewSpec `protobuf:"bytes,1,opt,name=spec,proto3" json:"spec,omitempty"`
        Meta *OnDemandFeatureViewMeta `protobuf:"bytes,2,opt,name=meta,proto3" json:"meta,omitempty"`
}

func (x *OnDemandFeatureView) Reset() <span class="cov0" title="0">{
        *x = OnDemandFeatureView{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_OnDemandFeatureView_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *OnDemandFeatureView) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*OnDemandFeatureView) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *OnDemandFeatureView) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_OnDemandFeatureView_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use OnDemandFeatureView.ProtoReflect.Descriptor instead.
func (*OnDemandFeatureView) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_OnDemandFeatureView_proto_rawDescGZIP(), []int{0}
}</span>

func (x *OnDemandFeatureView) GetSpec() *OnDemandFeatureViewSpec <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Spec
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *OnDemandFeatureView) GetMeta() *OnDemandFeatureViewMeta <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Meta
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Next available id: 9
type OnDemandFeatureViewSpec struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Name of the feature view. Must be unique. Not updated.
        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        // Name of Feast project that this feature view belongs to.
        Project string `protobuf:"bytes,2,opt,name=project,proto3" json:"project,omitempty"`
        // List of features specifications for each feature defined with this feature view.
        Features []*FeatureSpecV2 `protobuf:"bytes,3,rep,name=features,proto3" json:"features,omitempty"`
        // Map of sources for this feature view.
        Sources map[string]*OnDemandSource `protobuf:"bytes,4,rep,name=sources,proto3" json:"sources,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        // Deprecated: Marked as deprecated in feast/core/OnDemandFeatureView.proto.
        UserDefinedFunction *UserDefinedFunction `protobuf:"bytes,5,opt,name=user_defined_function,json=userDefinedFunction,proto3" json:"user_defined_function,omitempty"`
        // Oneof with {user_defined_function, on_demand_substrait_transformation}
        FeatureTransformation *FeatureTransformationV2 `protobuf:"bytes,10,opt,name=feature_transformation,json=featureTransformation,proto3" json:"feature_transformation,omitempty"`
        // Description of the on demand feature view.
        Description string `protobuf:"bytes,6,opt,name=description,proto3" json:"description,omitempty"`
        // User defined metadata.
        Tags map[string]string `protobuf:"bytes,7,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        // Owner of the on demand feature view.
        Owner string `protobuf:"bytes,8,opt,name=owner,proto3" json:"owner,omitempty"`
        Mode  string `protobuf:"bytes,11,opt,name=mode,proto3" json:"mode,omitempty"`
}

func (x *OnDemandFeatureViewSpec) Reset() <span class="cov0" title="0">{
        *x = OnDemandFeatureViewSpec{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_OnDemandFeatureView_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *OnDemandFeatureViewSpec) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*OnDemandFeatureViewSpec) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *OnDemandFeatureViewSpec) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_OnDemandFeatureView_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use OnDemandFeatureViewSpec.ProtoReflect.Descriptor instead.
func (*OnDemandFeatureViewSpec) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_OnDemandFeatureView_proto_rawDescGZIP(), []int{1}
}</span>

func (x *OnDemandFeatureViewSpec) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *OnDemandFeatureViewSpec) GetProject() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Project
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *OnDemandFeatureViewSpec) GetFeatures() []*FeatureSpecV2 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Features
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *OnDemandFeatureViewSpec) GetSources() map[string]*OnDemandSource <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Sources
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Deprecated: Marked as deprecated in feast/core/OnDemandFeatureView.proto.
func (x *OnDemandFeatureViewSpec) GetUserDefinedFunction() *UserDefinedFunction <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserDefinedFunction
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *OnDemandFeatureViewSpec) GetFeatureTransformation() *FeatureTransformationV2 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FeatureTransformation
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *OnDemandFeatureViewSpec) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *OnDemandFeatureViewSpec) GetTags() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tags
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *OnDemandFeatureViewSpec) GetOwner() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Owner
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *OnDemandFeatureViewSpec) GetMode() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Mode
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type OnDemandFeatureViewMeta struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Time where this Feature View is created
        CreatedTimestamp *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=created_timestamp,json=createdTimestamp,proto3" json:"created_timestamp,omitempty"`
        // Time where this Feature View is last updated
        LastUpdatedTimestamp *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=last_updated_timestamp,json=lastUpdatedTimestamp,proto3" json:"last_updated_timestamp,omitempty"`
}

func (x *OnDemandFeatureViewMeta) Reset() <span class="cov0" title="0">{
        *x = OnDemandFeatureViewMeta{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_OnDemandFeatureView_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *OnDemandFeatureViewMeta) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*OnDemandFeatureViewMeta) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *OnDemandFeatureViewMeta) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_OnDemandFeatureView_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use OnDemandFeatureViewMeta.ProtoReflect.Descriptor instead.
func (*OnDemandFeatureViewMeta) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_OnDemandFeatureView_proto_rawDescGZIP(), []int{2}
}</span>

func (x *OnDemandFeatureViewMeta) GetCreatedTimestamp() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedTimestamp
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *OnDemandFeatureViewMeta) GetLastUpdatedTimestamp() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LastUpdatedTimestamp
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type OnDemandSource struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Types that are assignable to Source:
        //
        //        *OnDemandSource_FeatureView
        //        *OnDemandSource_FeatureViewProjection
        //        *OnDemandSource_RequestDataSource
        Source isOnDemandSource_Source `protobuf_oneof:"source"`
}

func (x *OnDemandSource) Reset() <span class="cov0" title="0">{
        *x = OnDemandSource{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_OnDemandFeatureView_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *OnDemandSource) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*OnDemandSource) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *OnDemandSource) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_OnDemandFeatureView_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use OnDemandSource.ProtoReflect.Descriptor instead.
func (*OnDemandSource) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_OnDemandFeatureView_proto_rawDescGZIP(), []int{3}
}</span>

func (m *OnDemandSource) GetSource() isOnDemandSource_Source <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Source
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *OnDemandSource) GetFeatureView() *FeatureView <span class="cov0" title="0">{
        if x, ok := x.GetSource().(*OnDemandSource_FeatureView); ok </span><span class="cov0" title="0">{
                return x.FeatureView
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *OnDemandSource) GetFeatureViewProjection() *FeatureViewProjection <span class="cov0" title="0">{
        if x, ok := x.GetSource().(*OnDemandSource_FeatureViewProjection); ok </span><span class="cov0" title="0">{
                return x.FeatureViewProjection
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *OnDemandSource) GetRequestDataSource() *DataSource <span class="cov0" title="0">{
        if x, ok := x.GetSource().(*OnDemandSource_RequestDataSource); ok </span><span class="cov0" title="0">{
                return x.RequestDataSource
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type isOnDemandSource_Source interface {
        isOnDemandSource_Source()
}

type OnDemandSource_FeatureView struct {
        FeatureView *FeatureView `protobuf:"bytes,1,opt,name=feature_view,json=featureView,proto3,oneof"`
}

type OnDemandSource_FeatureViewProjection struct {
        FeatureViewProjection *FeatureViewProjection `protobuf:"bytes,3,opt,name=feature_view_projection,json=featureViewProjection,proto3,oneof"`
}

type OnDemandSource_RequestDataSource struct {
        RequestDataSource *DataSource `protobuf:"bytes,2,opt,name=request_data_source,json=requestDataSource,proto3,oneof"`
}

func (*OnDemandSource_FeatureView) isOnDemandSource_Source() {<span class="cov0" title="0">}</span>

func (*OnDemandSource_FeatureViewProjection) isOnDemandSource_Source() {<span class="cov0" title="0">}</span>

func (*OnDemandSource_RequestDataSource) isOnDemandSource_Source() {<span class="cov0" title="0">}</span>

// Serialized representation of python function.
//
// Deprecated: Marked as deprecated in feast/core/OnDemandFeatureView.proto.
type UserDefinedFunction struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // The function name
        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        // The python-syntax function body (serialized by dill)
        Body []byte `protobuf:"bytes,2,opt,name=body,proto3" json:"body,omitempty"`
        // The string representation of the udf
        BodyText string `protobuf:"bytes,3,opt,name=body_text,json=bodyText,proto3" json:"body_text,omitempty"`
}

func (x *UserDefinedFunction) Reset() <span class="cov0" title="0">{
        *x = UserDefinedFunction{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_OnDemandFeatureView_proto_msgTypes[4]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *UserDefinedFunction) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UserDefinedFunction) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UserDefinedFunction) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_OnDemandFeatureView_proto_msgTypes[4]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use UserDefinedFunction.ProtoReflect.Descriptor instead.
func (*UserDefinedFunction) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_OnDemandFeatureView_proto_rawDescGZIP(), []int{4}
}</span>

func (x *UserDefinedFunction) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UserDefinedFunction) GetBody() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Body
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *UserDefinedFunction) GetBodyText() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.BodyText
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type OnDemandFeatureViewList struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Ondemandfeatureviews []*OnDemandFeatureView `protobuf:"bytes,1,rep,name=ondemandfeatureviews,proto3" json:"ondemandfeatureviews,omitempty"`
}

func (x *OnDemandFeatureViewList) Reset() <span class="cov8" title="1">{
        *x = OnDemandFeatureViewList{}
        if protoimpl.UnsafeEnabled </span><span class="cov8" title="1">{
                mi := &amp;file_feast_core_OnDemandFeatureView_proto_msgTypes[5]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *OnDemandFeatureViewList) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*OnDemandFeatureViewList) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *OnDemandFeatureViewList) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_OnDemandFeatureView_proto_msgTypes[5]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov8" title="1">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov8" title="1">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov8" title="1">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use OnDemandFeatureViewList.ProtoReflect.Descriptor instead.
func (*OnDemandFeatureViewList) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_OnDemandFeatureView_proto_rawDescGZIP(), []int{5}
}</span>

func (x *OnDemandFeatureViewList) GetOndemandfeatureviews() []*OnDemandFeatureView <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.Ondemandfeatureviews
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_feast_core_OnDemandFeatureView_proto protoreflect.FileDescriptor

var file_feast_core_OnDemandFeatureView_proto_rawDesc = []byte{
        0x0a, 0x24, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x4f, 0x6e, 0x44,
        0x65, 0x6d, 0x61, 0x6e, 0x64, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77,
        0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0a, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f,
        0x72, 0x65, 0x1a, 0x1f, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x62, 0x75, 0x66, 0x2f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x1a, 0x1c, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f,
        0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x1a, 0x26, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x46, 0x65,
        0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77, 0x50, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74,
        0x69, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x18, 0x66, 0x65, 0x61, 0x73, 0x74,
        0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x1a, 0x1b, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f,
        0x44, 0x61, 0x74, 0x61, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x1a, 0x1f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x54, 0x72, 0x61,
        0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x22, 0x87, 0x01, 0x0a, 0x13, 0x4f, 0x6e, 0x44, 0x65, 0x6d, 0x61, 0x6e, 0x64, 0x46, 0x65,
        0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77, 0x12, 0x37, 0x0a, 0x04, 0x73, 0x70, 0x65,
        0x63, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e,
        0x63, 0x6f, 0x72, 0x65, 0x2e, 0x4f, 0x6e, 0x44, 0x65, 0x6d, 0x61, 0x6e, 0x64, 0x46, 0x65, 0x61,
        0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77, 0x53, 0x70, 0x65, 0x63, 0x52, 0x04, 0x73, 0x70,
        0x65, 0x63, 0x12, 0x37, 0x0a, 0x04, 0x6d, 0x65, 0x74, 0x61, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b,
        0x32, 0x23, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x4f, 0x6e,
        0x44, 0x65, 0x6d, 0x61, 0x6e, 0x64, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65,
        0x77, 0x4d, 0x65, 0x74, 0x61, 0x52, 0x04, 0x6d, 0x65, 0x74, 0x61, 0x22, 0x9f, 0x05, 0x0a, 0x17,
        0x4f, 0x6e, 0x44, 0x65, 0x6d, 0x61, 0x6e, 0x64, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56,
        0x69, 0x65, 0x77, 0x53, 0x70, 0x65, 0x63, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x70,
        0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x70, 0x72,
        0x6f, 0x6a, 0x65, 0x63, 0x74, 0x12, 0x35, 0x0a, 0x08, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65,
        0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e,
        0x63, 0x6f, 0x72, 0x65, 0x2e, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x53, 0x70, 0x65, 0x63,
        0x56, 0x32, 0x52, 0x08, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x12, 0x4a, 0x0a, 0x07,
        0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x30, 0x2e,
        0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x4f, 0x6e, 0x44, 0x65, 0x6d,
        0x61, 0x6e, 0x64, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77, 0x53, 0x70,
        0x65, 0x63, 0x2e, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52,
        0x07, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x12, 0x57, 0x0a, 0x15, 0x75, 0x73, 0x65, 0x72,
        0x5f, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x65, 0x64, 0x5f, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f,
        0x6e, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e,
        0x63, 0x6f, 0x72, 0x65, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x44, 0x65, 0x66, 0x69, 0x6e, 0x65, 0x64,
        0x46, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x42, 0x02, 0x18, 0x01, 0x52, 0x13, 0x75, 0x73,
        0x65, 0x72, 0x44, 0x65, 0x66, 0x69, 0x6e, 0x65, 0x64, 0x46, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f,
        0x6e, 0x12, 0x5a, 0x0a, 0x16, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x5f, 0x74, 0x72, 0x61,
        0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x0a, 0x20, 0x01, 0x28,
        0x0b, 0x32, 0x23, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x46,
        0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x61,
        0x74, 0x69, 0x6f, 0x6e, 0x56, 0x32, 0x52, 0x15, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x54,
        0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x20, 0x0a,
        0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x06, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12,
        0x41, 0x0a, 0x04, 0x74, 0x61, 0x67, 0x73, 0x18, 0x07, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x2d, 0x2e,
        0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x4f, 0x6e, 0x44, 0x65, 0x6d,
        0x61, 0x6e, 0x64, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77, 0x53, 0x70,
        0x65, 0x63, 0x2e, 0x54, 0x61, 0x67, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x04, 0x74, 0x61,
        0x67, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x18, 0x08, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x12, 0x12, 0x0a, 0x04, 0x6d, 0x6f, 0x64, 0x65,
        0x18, 0x0b, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6d, 0x6f, 0x64, 0x65, 0x1a, 0x56, 0x0a, 0x0c,
        0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03,
        0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x30,
        0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e,
        0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x4f, 0x6e, 0x44, 0x65, 0x6d,
        0x61, 0x6e, 0x64, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65,
        0x3a, 0x02, 0x38, 0x01, 0x1a, 0x37, 0x0a, 0x09, 0x54, 0x61, 0x67, 0x73, 0x45, 0x6e, 0x74, 0x72,
        0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03,
        0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0xb4, 0x01,
        0x0a, 0x17, 0x4f, 0x6e, 0x44, 0x65, 0x6d, 0x61, 0x6e, 0x64, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72,
        0x65, 0x56, 0x69, 0x65, 0x77, 0x4d, 0x65, 0x74, 0x61, 0x12, 0x47, 0x0a, 0x11, 0x63, 0x72, 0x65,
        0x61, 0x74, 0x65, 0x64, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70,
        0x52, 0x10, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61,
        0x6d, 0x70, 0x12, 0x50, 0x0a, 0x16, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x75, 0x70, 0x64, 0x61, 0x74,
        0x65, 0x64, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x02, 0x20, 0x01,
        0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x14,
        0x6c, 0x61, 0x73, 0x74, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x54, 0x69, 0x6d, 0x65, 0x73,
        0x74, 0x61, 0x6d, 0x70, 0x22, 0xff, 0x01, 0x0a, 0x0e, 0x4f, 0x6e, 0x44, 0x65, 0x6d, 0x61, 0x6e,
        0x64, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x12, 0x3c, 0x0a, 0x0c, 0x66, 0x65, 0x61, 0x74, 0x75,
        0x72, 0x65, 0x5f, 0x76, 0x69, 0x65, 0x77, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e,
        0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x46, 0x65, 0x61, 0x74, 0x75,
        0x72, 0x65, 0x56, 0x69, 0x65, 0x77, 0x48, 0x00, 0x52, 0x0b, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72,
        0x65, 0x56, 0x69, 0x65, 0x77, 0x12, 0x5b, 0x0a, 0x17, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65,
        0x5f, 0x76, 0x69, 0x65, 0x77, 0x5f, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e,
        0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63,
        0x6f, 0x72, 0x65, 0x2e, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77, 0x50,
        0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x48, 0x00, 0x52, 0x15, 0x66, 0x65, 0x61,
        0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77, 0x50, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x69,
        0x6f, 0x6e, 0x12, 0x48, 0x0a, 0x13, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x5f, 0x64, 0x61,
        0x74, 0x61, 0x5f, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32,
        0x16, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x44, 0x61, 0x74,
        0x61, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x48, 0x00, 0x52, 0x11, 0x72, 0x65, 0x71, 0x75, 0x65,
        0x73, 0x74, 0x44, 0x61, 0x74, 0x61, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x42, 0x08, 0x0a, 0x06,
        0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x22, 0x5e, 0x0a, 0x13, 0x55, 0x73, 0x65, 0x72, 0x44, 0x65,
        0x66, 0x69, 0x6e, 0x65, 0x64, 0x46, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x12, 0x0a,
        0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d,
        0x65, 0x12, 0x12, 0x0a, 0x04, 0x62, 0x6f, 0x64, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x52,
        0x04, 0x62, 0x6f, 0x64, 0x79, 0x12, 0x1b, 0x0a, 0x09, 0x62, 0x6f, 0x64, 0x79, 0x5f, 0x74, 0x65,
        0x78, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x62, 0x6f, 0x64, 0x79, 0x54, 0x65,
        0x78, 0x74, 0x3a, 0x02, 0x18, 0x01, 0x22, 0x6e, 0x0a, 0x17, 0x4f, 0x6e, 0x44, 0x65, 0x6d, 0x61,
        0x6e, 0x64, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77, 0x4c, 0x69, 0x73,
        0x74, 0x12, 0x53, 0x0a, 0x14, 0x6f, 0x6e, 0x64, 0x65, 0x6d, 0x61, 0x6e, 0x64, 0x66, 0x65, 0x61,
        0x74, 0x75, 0x72, 0x65, 0x76, 0x69, 0x65, 0x77, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32,
        0x1f, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x4f, 0x6e, 0x44,
        0x65, 0x6d, 0x61, 0x6e, 0x64, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77,
        0x52, 0x14, 0x6f, 0x6e, 0x64, 0x65, 0x6d, 0x61, 0x6e, 0x64, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72,
        0x65, 0x76, 0x69, 0x65, 0x77, 0x73, 0x42, 0x5d, 0x0a, 0x10, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x42, 0x18, 0x4f, 0x6e, 0x44, 0x65,
        0x6d, 0x61, 0x6e, 0x64, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77, 0x50,
        0x72, 0x6f, 0x74, 0x6f, 0x5a, 0x2f, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d,
        0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2d, 0x64, 0x65, 0x76, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74,
        0x2f, 0x67, 0x6f, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x73, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74,
        0x2f, 0x63, 0x6f, 0x72, 0x65, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_feast_core_OnDemandFeatureView_proto_rawDescOnce sync.Once
        file_feast_core_OnDemandFeatureView_proto_rawDescData = file_feast_core_OnDemandFeatureView_proto_rawDesc
)

func file_feast_core_OnDemandFeatureView_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_feast_core_OnDemandFeatureView_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_feast_core_OnDemandFeatureView_proto_rawDescData = protoimpl.X.CompressGZIP(file_feast_core_OnDemandFeatureView_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_feast_core_OnDemandFeatureView_proto_rawDescData</span>
}

var file_feast_core_OnDemandFeatureView_proto_msgTypes = make([]protoimpl.MessageInfo, 8)
var file_feast_core_OnDemandFeatureView_proto_goTypes = []interface{}{
        (*OnDemandFeatureView)(nil),     // 0: feast.core.OnDemandFeatureView
        (*OnDemandFeatureViewSpec)(nil), // 1: feast.core.OnDemandFeatureViewSpec
        (*OnDemandFeatureViewMeta)(nil), // 2: feast.core.OnDemandFeatureViewMeta
        (*OnDemandSource)(nil),          // 3: feast.core.OnDemandSource
        (*UserDefinedFunction)(nil),     // 4: feast.core.UserDefinedFunction
        (*OnDemandFeatureViewList)(nil), // 5: feast.core.OnDemandFeatureViewList
        nil,                             // 6: feast.core.OnDemandFeatureViewSpec.SourcesEntry
        nil,                             // 7: feast.core.OnDemandFeatureViewSpec.TagsEntry
        (*FeatureSpecV2)(nil),           // 8: feast.core.FeatureSpecV2
        (*FeatureTransformationV2)(nil), // 9: feast.core.FeatureTransformationV2
        (*timestamppb.Timestamp)(nil),   // 10: google.protobuf.Timestamp
        (*FeatureView)(nil),             // 11: feast.core.FeatureView
        (*FeatureViewProjection)(nil),   // 12: feast.core.FeatureViewProjection
        (*DataSource)(nil),              // 13: feast.core.DataSource
}
var file_feast_core_OnDemandFeatureView_proto_depIdxs = []int32{
        1,  // 0: feast.core.OnDemandFeatureView.spec:type_name -&gt; feast.core.OnDemandFeatureViewSpec
        2,  // 1: feast.core.OnDemandFeatureView.meta:type_name -&gt; feast.core.OnDemandFeatureViewMeta
        8,  // 2: feast.core.OnDemandFeatureViewSpec.features:type_name -&gt; feast.core.FeatureSpecV2
        6,  // 3: feast.core.OnDemandFeatureViewSpec.sources:type_name -&gt; feast.core.OnDemandFeatureViewSpec.SourcesEntry
        4,  // 4: feast.core.OnDemandFeatureViewSpec.user_defined_function:type_name -&gt; feast.core.UserDefinedFunction
        9,  // 5: feast.core.OnDemandFeatureViewSpec.feature_transformation:type_name -&gt; feast.core.FeatureTransformationV2
        7,  // 6: feast.core.OnDemandFeatureViewSpec.tags:type_name -&gt; feast.core.OnDemandFeatureViewSpec.TagsEntry
        10, // 7: feast.core.OnDemandFeatureViewMeta.created_timestamp:type_name -&gt; google.protobuf.Timestamp
        10, // 8: feast.core.OnDemandFeatureViewMeta.last_updated_timestamp:type_name -&gt; google.protobuf.Timestamp
        11, // 9: feast.core.OnDemandSource.feature_view:type_name -&gt; feast.core.FeatureView
        12, // 10: feast.core.OnDemandSource.feature_view_projection:type_name -&gt; feast.core.FeatureViewProjection
        13, // 11: feast.core.OnDemandSource.request_data_source:type_name -&gt; feast.core.DataSource
        0,  // 12: feast.core.OnDemandFeatureViewList.ondemandfeatureviews:type_name -&gt; feast.core.OnDemandFeatureView
        3,  // 13: feast.core.OnDemandFeatureViewSpec.SourcesEntry.value:type_name -&gt; feast.core.OnDemandSource
        14, // [14:14] is the sub-list for method output_type
        14, // [14:14] is the sub-list for method input_type
        14, // [14:14] is the sub-list for extension type_name
        14, // [14:14] is the sub-list for extension extendee
        0,  // [0:14] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_feast_core_OnDemandFeatureView_proto_init() }</span>
func file_feast_core_OnDemandFeatureView_proto_init() <span class="cov8" title="1">{
        if File_feast_core_OnDemandFeatureView_proto != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">file_feast_core_FeatureView_proto_init()
        file_feast_core_FeatureViewProjection_proto_init()
        file_feast_core_Feature_proto_init()
        file_feast_core_DataSource_proto_init()
        file_feast_core_Transformation_proto_init()
        if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_feast_core_OnDemandFeatureView_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*OnDemandFeatureView); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_OnDemandFeatureView_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*OnDemandFeatureViewSpec); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_OnDemandFeatureView_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*OnDemandFeatureViewMeta); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_OnDemandFeatureView_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*OnDemandSource); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_OnDemandFeatureView_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*UserDefinedFunction); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_OnDemandFeatureView_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*OnDemandFeatureViewList); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">file_feast_core_OnDemandFeatureView_proto_msgTypes[3].OneofWrappers = []interface{}{
                (*OnDemandSource_FeatureView)(nil),
                (*OnDemandSource_FeatureViewProjection)(nil),
                (*OnDemandSource_RequestDataSource)(nil),
        }
        type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_feast_core_OnDemandFeatureView_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   8,
                        NumExtensions: 0,
                        NumServices:   0,
                },
                GoTypes:           file_feast_core_OnDemandFeatureView_proto_goTypes,
                DependencyIndexes: file_feast_core_OnDemandFeatureView_proto_depIdxs,
                MessageInfos:      file_feast_core_OnDemandFeatureView_proto_msgTypes,
        }.Build()
        File_feast_core_OnDemandFeatureView_proto = out.File
        file_feast_core_OnDemandFeatureView_proto_rawDesc = nil
        file_feast_core_OnDemandFeatureView_proto_goTypes = nil
        file_feast_core_OnDemandFeatureView_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.31.0
//         protoc        v4.25.1
// source: feast/core/Permission.proto

package core

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type PermissionSpec_AuthzedAction int32

const (
        PermissionSpec_CREATE        PermissionSpec_AuthzedAction = 0
        PermissionSpec_DESCRIBE      PermissionSpec_AuthzedAction = 1
        PermissionSpec_UPDATE        PermissionSpec_AuthzedAction = 2
        PermissionSpec_DELETE        PermissionSpec_AuthzedAction = 3
        PermissionSpec_READ_ONLINE   PermissionSpec_AuthzedAction = 4
        PermissionSpec_READ_OFFLINE  PermissionSpec_AuthzedAction = 5
        PermissionSpec_WRITE_ONLINE  PermissionSpec_AuthzedAction = 6
        PermissionSpec_WRITE_OFFLINE PermissionSpec_AuthzedAction = 7
)

// Enum value maps for PermissionSpec_AuthzedAction.
var (
        PermissionSpec_AuthzedAction_name = map[int32]string{
                0: "CREATE",
                1: "DESCRIBE",
                2: "UPDATE",
                3: "DELETE",
                4: "READ_ONLINE",
                5: "READ_OFFLINE",
                6: "WRITE_ONLINE",
                7: "WRITE_OFFLINE",
        }
        PermissionSpec_AuthzedAction_value = map[string]int32{
                "CREATE":        0,
                "DESCRIBE":      1,
                "UPDATE":        2,
                "DELETE":        3,
                "READ_ONLINE":   4,
                "READ_OFFLINE":  5,
                "WRITE_ONLINE":  6,
                "WRITE_OFFLINE": 7,
        }
)

func (x PermissionSpec_AuthzedAction) Enum() *PermissionSpec_AuthzedAction <span class="cov0" title="0">{
        p := new(PermissionSpec_AuthzedAction)
        *p = x
        return p
}</span>

func (x PermissionSpec_AuthzedAction) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (PermissionSpec_AuthzedAction) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_feast_core_Permission_proto_enumTypes[0].Descriptor()
}</span>

func (PermissionSpec_AuthzedAction) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_feast_core_Permission_proto_enumTypes[0]
}</span>

func (x PermissionSpec_AuthzedAction) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use PermissionSpec_AuthzedAction.Descriptor instead.
func (PermissionSpec_AuthzedAction) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_Permission_proto_rawDescGZIP(), []int{1, 0}
}</span>

type PermissionSpec_Type int32

const (
        PermissionSpec_FEATURE_VIEW           PermissionSpec_Type = 0
        PermissionSpec_ON_DEMAND_FEATURE_VIEW PermissionSpec_Type = 1
        PermissionSpec_BATCH_FEATURE_VIEW     PermissionSpec_Type = 2
        PermissionSpec_STREAM_FEATURE_VIEW    PermissionSpec_Type = 3
        PermissionSpec_ENTITY                 PermissionSpec_Type = 4
        PermissionSpec_FEATURE_SERVICE        PermissionSpec_Type = 5
        PermissionSpec_DATA_SOURCE            PermissionSpec_Type = 6
        PermissionSpec_VALIDATION_REFERENCE   PermissionSpec_Type = 7
        PermissionSpec_SAVED_DATASET          PermissionSpec_Type = 8
        PermissionSpec_PERMISSION             PermissionSpec_Type = 9
        PermissionSpec_PROJECT                PermissionSpec_Type = 10
)

// Enum value maps for PermissionSpec_Type.
var (
        PermissionSpec_Type_name = map[int32]string{
                0:  "FEATURE_VIEW",
                1:  "ON_DEMAND_FEATURE_VIEW",
                2:  "BATCH_FEATURE_VIEW",
                3:  "STREAM_FEATURE_VIEW",
                4:  "ENTITY",
                5:  "FEATURE_SERVICE",
                6:  "DATA_SOURCE",
                7:  "VALIDATION_REFERENCE",
                8:  "SAVED_DATASET",
                9:  "PERMISSION",
                10: "PROJECT",
        }
        PermissionSpec_Type_value = map[string]int32{
                "FEATURE_VIEW":           0,
                "ON_DEMAND_FEATURE_VIEW": 1,
                "BATCH_FEATURE_VIEW":     2,
                "STREAM_FEATURE_VIEW":    3,
                "ENTITY":                 4,
                "FEATURE_SERVICE":        5,
                "DATA_SOURCE":            6,
                "VALIDATION_REFERENCE":   7,
                "SAVED_DATASET":          8,
                "PERMISSION":             9,
                "PROJECT":                10,
        }
)

func (x PermissionSpec_Type) Enum() *PermissionSpec_Type <span class="cov0" title="0">{
        p := new(PermissionSpec_Type)
        *p = x
        return p
}</span>

func (x PermissionSpec_Type) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (PermissionSpec_Type) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_feast_core_Permission_proto_enumTypes[1].Descriptor()
}</span>

func (PermissionSpec_Type) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_feast_core_Permission_proto_enumTypes[1]
}</span>

func (x PermissionSpec_Type) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use PermissionSpec_Type.Descriptor instead.
func (PermissionSpec_Type) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_Permission_proto_rawDescGZIP(), []int{1, 1}
}</span>

type Permission struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // User-specified specifications of this permission.
        Spec *PermissionSpec `protobuf:"bytes,1,opt,name=spec,proto3" json:"spec,omitempty"`
        // System-populated metadata for this permission.
        Meta *PermissionMeta `protobuf:"bytes,2,opt,name=meta,proto3" json:"meta,omitempty"`
}

func (x *Permission) Reset() <span class="cov0" title="0">{
        *x = Permission{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_Permission_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Permission) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Permission) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Permission) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_Permission_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use Permission.ProtoReflect.Descriptor instead.
func (*Permission) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_Permission_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Permission) GetSpec() *PermissionSpec <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Spec
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Permission) GetMeta() *PermissionMeta <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Meta
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type PermissionSpec struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Name of the permission. Must be unique. Not updated.
        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        // Name of Feast project.
        Project      string                `protobuf:"bytes,2,opt,name=project,proto3" json:"project,omitempty"`
        Types        []PermissionSpec_Type `protobuf:"varint,3,rep,packed,name=types,proto3,enum=feast.core.PermissionSpec_Type" json:"types,omitempty"`
        NamePattern  string                `protobuf:"bytes,4,opt,name=name_pattern,json=namePattern,proto3" json:"name_pattern,omitempty"`
        RequiredTags map[string]string     `protobuf:"bytes,5,rep,name=required_tags,json=requiredTags,proto3" json:"required_tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        // List of actions.
        Actions []PermissionSpec_AuthzedAction `protobuf:"varint,6,rep,packed,name=actions,proto3,enum=feast.core.PermissionSpec_AuthzedAction" json:"actions,omitempty"`
        // the policy.
        Policy *Policy `protobuf:"bytes,7,opt,name=policy,proto3" json:"policy,omitempty"`
        // User defined metadata
        Tags map[string]string `protobuf:"bytes,8,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (x *PermissionSpec) Reset() <span class="cov0" title="0">{
        *x = PermissionSpec{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_Permission_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *PermissionSpec) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*PermissionSpec) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *PermissionSpec) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_feast_core_Permission_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use PermissionSpec.ProtoReflect.Descriptor instead.
func (*PermissionSpec) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_Permission_proto_rawDescGZIP(), []int{1}
}</span>

func (x *PermissionSpec) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *PermissionSpec) GetProject() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Project
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *PermissionSpec) GetTypes() []PermissionSpec_Type <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Types
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *PermissionSpec) GetNamePattern() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.NamePattern
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *PermissionSpec) GetRequiredTags() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RequiredTags
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *PermissionSpec) GetActions() []PermissionSpec_AuthzedAction <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Actions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *PermissionSpec) GetPolicy() *Policy <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Policy
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *PermissionSpec) GetTags() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tags
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type PermissionMeta struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        CreatedTimestamp     *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=created_timestamp,json=createdTimestamp,proto3" json:"created_timestamp,omitempty"`
        LastUpdatedTimestamp *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=last_updated_timestamp,json=lastUpdatedTimestamp,proto3" json:"last_updated_timestamp,omitempty"`
}

func (x *PermissionMeta) Reset() <span class="cov0" title="0">{
        *x = PermissionMeta{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_Permission_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *PermissionMeta) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*PermissionMeta) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *PermissionMeta) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_feast_core_Permission_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use PermissionMeta.ProtoReflect.Descriptor instead.
func (*PermissionMeta) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_Permission_proto_rawDescGZIP(), []int{2}
}</span>

func (x *PermissionMeta) GetCreatedTimestamp() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedTimestamp
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *PermissionMeta) GetLastUpdatedTimestamp() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LastUpdatedTimestamp
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_feast_core_Permission_proto protoreflect.FileDescriptor

var file_feast_core_Permission_proto_rawDesc = []byte{
        0x0a, 0x1b, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x50, 0x65, 0x72,
        0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0a, 0x66,
        0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x1a, 0x17, 0x66, 0x65, 0x61, 0x73, 0x74,
        0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x1a, 0x1f, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x62, 0x75, 0x66, 0x2f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x22, 0x6c, 0x0a, 0x0a, 0x50, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f,
        0x6e, 0x12, 0x2e, 0x0a, 0x04, 0x73, 0x70, 0x65, 0x63, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32,
        0x1a, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x50, 0x65, 0x72,
        0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x53, 0x70, 0x65, 0x63, 0x52, 0x04, 0x73, 0x70, 0x65,
        0x63, 0x12, 0x2e, 0x0a, 0x04, 0x6d, 0x65, 0x74, 0x61, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32,
        0x1a, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x50, 0x65, 0x72,
        0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x4d, 0x65, 0x74, 0x61, 0x52, 0x04, 0x6d, 0x65, 0x74,
        0x61, 0x22, 0xff, 0x06, 0x0a, 0x0e, 0x50, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e,
        0x53, 0x70, 0x65, 0x63, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x70, 0x72, 0x6f, 0x6a,
        0x65, 0x63, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x70, 0x72, 0x6f, 0x6a, 0x65,
        0x63, 0x74, 0x12, 0x35, 0x0a, 0x05, 0x74, 0x79, 0x70, 0x65, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28,
        0x0e, 0x32, 0x1f, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x50,
        0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x53, 0x70, 0x65, 0x63, 0x2e, 0x54, 0x79,
        0x70, 0x65, 0x52, 0x05, 0x74, 0x79, 0x70, 0x65, 0x73, 0x12, 0x21, 0x0a, 0x0c, 0x6e, 0x61, 0x6d,
        0x65, 0x5f, 0x70, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x0b, 0x6e, 0x61, 0x6d, 0x65, 0x50, 0x61, 0x74, 0x74, 0x65, 0x72, 0x6e, 0x12, 0x51, 0x0a, 0x0d,
        0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x5f, 0x74, 0x61, 0x67, 0x73, 0x18, 0x05, 0x20,
        0x03, 0x28, 0x0b, 0x32, 0x2c, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65,
        0x2e, 0x50, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x53, 0x70, 0x65, 0x63, 0x2e,
        0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x54, 0x61, 0x67, 0x73, 0x45, 0x6e, 0x74, 0x72,
        0x79, 0x52, 0x0c, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x54, 0x61, 0x67, 0x73, 0x12,
        0x42, 0x0a, 0x07, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x06, 0x20, 0x03, 0x28, 0x0e,
        0x32, 0x28, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x50, 0x65,
        0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x53, 0x70, 0x65, 0x63, 0x2e, 0x41, 0x75, 0x74,
        0x68, 0x7a, 0x65, 0x64, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x07, 0x61, 0x63, 0x74, 0x69,
        0x6f, 0x6e, 0x73, 0x12, 0x2a, 0x0a, 0x06, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x18, 0x07, 0x20,
        0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65,
        0x2e, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x52, 0x06, 0x70, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x12,
        0x38, 0x0a, 0x04, 0x74, 0x61, 0x67, 0x73, 0x18, 0x08, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x24, 0x2e,
        0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x50, 0x65, 0x72, 0x6d, 0x69,
        0x73, 0x73, 0x69, 0x6f, 0x6e, 0x53, 0x70, 0x65, 0x63, 0x2e, 0x54, 0x61, 0x67, 0x73, 0x45, 0x6e,
        0x74, 0x72, 0x79, 0x52, 0x04, 0x74, 0x61, 0x67, 0x73, 0x1a, 0x3f, 0x0a, 0x11, 0x52, 0x65, 0x71,
        0x75, 0x69, 0x72, 0x65, 0x64, 0x54, 0x61, 0x67, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10,
        0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79,
        0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x1a, 0x37, 0x0a, 0x09, 0x54, 0x61,
        0x67, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c,
        0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a,
        0x02, 0x38, 0x01, 0x22, 0x89, 0x01, 0x0a, 0x0d, 0x41, 0x75, 0x74, 0x68, 0x7a, 0x65, 0x64, 0x41,
        0x63, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x0a, 0x0a, 0x06, 0x43, 0x52, 0x45, 0x41, 0x54, 0x45, 0x10,
        0x00, 0x12, 0x0c, 0x0a, 0x08, 0x44, 0x45, 0x53, 0x43, 0x52, 0x49, 0x42, 0x45, 0x10, 0x01, 0x12,
        0x0a, 0x0a, 0x06, 0x55, 0x50, 0x44, 0x41, 0x54, 0x45, 0x10, 0x02, 0x12, 0x0a, 0x0a, 0x06, 0x44,
        0x45, 0x4c, 0x45, 0x54, 0x45, 0x10, 0x03, 0x12, 0x0f, 0x0a, 0x0b, 0x52, 0x45, 0x41, 0x44, 0x5f,
        0x4f, 0x4e, 0x4c, 0x49, 0x4e, 0x45, 0x10, 0x04, 0x12, 0x10, 0x0a, 0x0c, 0x52, 0x45, 0x41, 0x44,
        0x5f, 0x4f, 0x46, 0x46, 0x4c, 0x49, 0x4e, 0x45, 0x10, 0x05, 0x12, 0x10, 0x0a, 0x0c, 0x57, 0x52,
        0x49, 0x54, 0x45, 0x5f, 0x4f, 0x4e, 0x4c, 0x49, 0x4e, 0x45, 0x10, 0x06, 0x12, 0x11, 0x0a, 0x0d,
        0x57, 0x52, 0x49, 0x54, 0x45, 0x5f, 0x4f, 0x46, 0x46, 0x4c, 0x49, 0x4e, 0x45, 0x10, 0x07, 0x22,
        0xe1, 0x01, 0x0a, 0x04, 0x54, 0x79, 0x70, 0x65, 0x12, 0x10, 0x0a, 0x0c, 0x46, 0x45, 0x41, 0x54,
        0x55, 0x52, 0x45, 0x5f, 0x56, 0x49, 0x45, 0x57, 0x10, 0x00, 0x12, 0x1a, 0x0a, 0x16, 0x4f, 0x4e,
        0x5f, 0x44, 0x45, 0x4d, 0x41, 0x4e, 0x44, 0x5f, 0x46, 0x45, 0x41, 0x54, 0x55, 0x52, 0x45, 0x5f,
        0x56, 0x49, 0x45, 0x57, 0x10, 0x01, 0x12, 0x16, 0x0a, 0x12, 0x42, 0x41, 0x54, 0x43, 0x48, 0x5f,
        0x46, 0x45, 0x41, 0x54, 0x55, 0x52, 0x45, 0x5f, 0x56, 0x49, 0x45, 0x57, 0x10, 0x02, 0x12, 0x17,
        0x0a, 0x13, 0x53, 0x54, 0x52, 0x45, 0x41, 0x4d, 0x5f, 0x46, 0x45, 0x41, 0x54, 0x55, 0x52, 0x45,
        0x5f, 0x56, 0x49, 0x45, 0x57, 0x10, 0x03, 0x12, 0x0a, 0x0a, 0x06, 0x45, 0x4e, 0x54, 0x49, 0x54,
        0x59, 0x10, 0x04, 0x12, 0x13, 0x0a, 0x0f, 0x46, 0x45, 0x41, 0x54, 0x55, 0x52, 0x45, 0x5f, 0x53,
        0x45, 0x52, 0x56, 0x49, 0x43, 0x45, 0x10, 0x05, 0x12, 0x0f, 0x0a, 0x0b, 0x44, 0x41, 0x54, 0x41,
        0x5f, 0x53, 0x4f, 0x55, 0x52, 0x43, 0x45, 0x10, 0x06, 0x12, 0x18, 0x0a, 0x14, 0x56, 0x41, 0x4c,
        0x49, 0x44, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x52, 0x45, 0x46, 0x45, 0x52, 0x45, 0x4e, 0x43,
        0x45, 0x10, 0x07, 0x12, 0x11, 0x0a, 0x0d, 0x53, 0x41, 0x56, 0x45, 0x44, 0x5f, 0x44, 0x41, 0x54,
        0x41, 0x53, 0x45, 0x54, 0x10, 0x08, 0x12, 0x0e, 0x0a, 0x0a, 0x50, 0x45, 0x52, 0x4d, 0x49, 0x53,
        0x53, 0x49, 0x4f, 0x4e, 0x10, 0x09, 0x12, 0x0b, 0x0a, 0x07, 0x50, 0x52, 0x4f, 0x4a, 0x45, 0x43,
        0x54, 0x10, 0x0a, 0x22, 0xab, 0x01, 0x0a, 0x0e, 0x50, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69,
        0x6f, 0x6e, 0x4d, 0x65, 0x74, 0x61, 0x12, 0x47, 0x0a, 0x11, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65,
        0x64, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x01, 0x20, 0x01, 0x28,
        0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x10, 0x63,
        0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x12,
        0x50, 0x0a, 0x16, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x5f,
        0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32,
        0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75,
        0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x14, 0x6c, 0x61, 0x73,
        0x74, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d,
        0x70, 0x42, 0x54, 0x0a, 0x10, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x2e, 0x63, 0x6f, 0x72, 0x65, 0x42, 0x0f, 0x50, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f,
        0x6e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x5a, 0x2f, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63,
        0x6f, 0x6d, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2d, 0x64, 0x65, 0x76, 0x2f, 0x66, 0x65, 0x61,
        0x73, 0x74, 0x2f, 0x67, 0x6f, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x73, 0x2f, 0x66, 0x65, 0x61,
        0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_feast_core_Permission_proto_rawDescOnce sync.Once
        file_feast_core_Permission_proto_rawDescData = file_feast_core_Permission_proto_rawDesc
)

func file_feast_core_Permission_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_feast_core_Permission_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_feast_core_Permission_proto_rawDescData = protoimpl.X.CompressGZIP(file_feast_core_Permission_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_feast_core_Permission_proto_rawDescData</span>
}

var file_feast_core_Permission_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_feast_core_Permission_proto_msgTypes = make([]protoimpl.MessageInfo, 5)
var file_feast_core_Permission_proto_goTypes = []interface{}{
        (PermissionSpec_AuthzedAction)(0), // 0: feast.core.PermissionSpec.AuthzedAction
        (PermissionSpec_Type)(0),          // 1: feast.core.PermissionSpec.Type
        (*Permission)(nil),                // 2: feast.core.Permission
        (*PermissionSpec)(nil),            // 3: feast.core.PermissionSpec
        (*PermissionMeta)(nil),            // 4: feast.core.PermissionMeta
        nil,                               // 5: feast.core.PermissionSpec.RequiredTagsEntry
        nil,                               // 6: feast.core.PermissionSpec.TagsEntry
        (*Policy)(nil),                    // 7: feast.core.Policy
        (*timestamppb.Timestamp)(nil),     // 8: google.protobuf.Timestamp
}
var file_feast_core_Permission_proto_depIdxs = []int32{
        3, // 0: feast.core.Permission.spec:type_name -&gt; feast.core.PermissionSpec
        4, // 1: feast.core.Permission.meta:type_name -&gt; feast.core.PermissionMeta
        1, // 2: feast.core.PermissionSpec.types:type_name -&gt; feast.core.PermissionSpec.Type
        5, // 3: feast.core.PermissionSpec.required_tags:type_name -&gt; feast.core.PermissionSpec.RequiredTagsEntry
        0, // 4: feast.core.PermissionSpec.actions:type_name -&gt; feast.core.PermissionSpec.AuthzedAction
        7, // 5: feast.core.PermissionSpec.policy:type_name -&gt; feast.core.Policy
        6, // 6: feast.core.PermissionSpec.tags:type_name -&gt; feast.core.PermissionSpec.TagsEntry
        8, // 7: feast.core.PermissionMeta.created_timestamp:type_name -&gt; google.protobuf.Timestamp
        8, // 8: feast.core.PermissionMeta.last_updated_timestamp:type_name -&gt; google.protobuf.Timestamp
        9, // [9:9] is the sub-list for method output_type
        9, // [9:9] is the sub-list for method input_type
        9, // [9:9] is the sub-list for extension type_name
        9, // [9:9] is the sub-list for extension extendee
        0, // [0:9] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_feast_core_Permission_proto_init() }</span>
func file_feast_core_Permission_proto_init() <span class="cov8" title="1">{
        if File_feast_core_Permission_proto != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">file_feast_core_Policy_proto_init()
        if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_feast_core_Permission_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Permission); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_Permission_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*PermissionSpec); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_Permission_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*PermissionMeta); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_feast_core_Permission_proto_rawDesc,
                        NumEnums:      2,
                        NumMessages:   5,
                        NumExtensions: 0,
                        NumServices:   0,
                },
                GoTypes:           file_feast_core_Permission_proto_goTypes,
                DependencyIndexes: file_feast_core_Permission_proto_depIdxs,
                EnumInfos:         file_feast_core_Permission_proto_enumTypes,
                MessageInfos:      file_feast_core_Permission_proto_msgTypes,
        }.Build()
        File_feast_core_Permission_proto = out.File
        file_feast_core_Permission_proto_rawDesc = nil
        file_feast_core_Permission_proto_goTypes = nil
        file_feast_core_Permission_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.31.0
//         protoc        v4.25.1
// source: feast/core/Policy.proto

package core

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Policy struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Name of the policy.
        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        // Name of Feast project.
        Project string `protobuf:"bytes,2,opt,name=project,proto3" json:"project,omitempty"`
        // Types that are assignable to PolicyType:
        //
        //        *Policy_RoleBasedPolicy
        PolicyType isPolicy_PolicyType `protobuf_oneof:"policy_type"`
}

func (x *Policy) Reset() <span class="cov0" title="0">{
        *x = Policy{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_Policy_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Policy) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Policy) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Policy) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_Policy_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use Policy.ProtoReflect.Descriptor instead.
func (*Policy) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_Policy_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Policy) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Policy) GetProject() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Project
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (m *Policy) GetPolicyType() isPolicy_PolicyType <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.PolicyType
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Policy) GetRoleBasedPolicy() *RoleBasedPolicy <span class="cov0" title="0">{
        if x, ok := x.GetPolicyType().(*Policy_RoleBasedPolicy); ok </span><span class="cov0" title="0">{
                return x.RoleBasedPolicy
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type isPolicy_PolicyType interface {
        isPolicy_PolicyType()
}

type Policy_RoleBasedPolicy struct {
        RoleBasedPolicy *RoleBasedPolicy `protobuf:"bytes,3,opt,name=role_based_policy,json=roleBasedPolicy,proto3,oneof"`
}

func (*Policy_RoleBasedPolicy) isPolicy_PolicyType() {<span class="cov0" title="0">}</span>

type RoleBasedPolicy struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // List of roles in this policy.
        Roles []string `protobuf:"bytes,1,rep,name=roles,proto3" json:"roles,omitempty"`
}

func (x *RoleBasedPolicy) Reset() <span class="cov0" title="0">{
        *x = RoleBasedPolicy{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_Policy_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *RoleBasedPolicy) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RoleBasedPolicy) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RoleBasedPolicy) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_feast_core_Policy_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RoleBasedPolicy.ProtoReflect.Descriptor instead.
func (*RoleBasedPolicy) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_Policy_proto_rawDescGZIP(), []int{1}
}</span>

func (x *RoleBasedPolicy) GetRoles() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Roles
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_feast_core_Policy_proto protoreflect.FileDescriptor

var file_feast_core_Policy_proto_rawDesc = []byte{
        0x0a, 0x17, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x50, 0x6f, 0x6c,
        0x69, 0x63, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0a, 0x66, 0x65, 0x61, 0x73, 0x74,
        0x2e, 0x63, 0x6f, 0x72, 0x65, 0x22, 0x90, 0x01, 0x0a, 0x06, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79,
        0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04,
        0x6e, 0x61, 0x6d, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x18,
        0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x12, 0x49,
        0x0a, 0x11, 0x72, 0x6f, 0x6c, 0x65, 0x5f, 0x62, 0x61, 0x73, 0x65, 0x64, 0x5f, 0x70, 0x6f, 0x6c,
        0x69, 0x63, 0x79, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x66, 0x65, 0x61, 0x73,
        0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x52, 0x6f, 0x6c, 0x65, 0x42, 0x61, 0x73, 0x65, 0x64,
        0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x48, 0x00, 0x52, 0x0f, 0x72, 0x6f, 0x6c, 0x65, 0x42, 0x61,
        0x73, 0x65, 0x64, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x42, 0x0d, 0x0a, 0x0b, 0x70, 0x6f, 0x6c,
        0x69, 0x63, 0x79, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x22, 0x27, 0x0a, 0x0f, 0x52, 0x6f, 0x6c, 0x65,
        0x42, 0x61, 0x73, 0x65, 0x64, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x72,
        0x6f, 0x6c, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x05, 0x72, 0x6f, 0x6c, 0x65,
        0x73, 0x42, 0x50, 0x0a, 0x10, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x2e, 0x63, 0x6f, 0x72, 0x65, 0x42, 0x0b, 0x50, 0x6f, 0x6c, 0x69, 0x63, 0x79, 0x50, 0x72, 0x6f,
        0x74, 0x6f, 0x5a, 0x2f, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x66,
        0x65, 0x61, 0x73, 0x74, 0x2d, 0x64, 0x65, 0x76, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x67,
        0x6f, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x73, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63,
        0x6f, 0x72, 0x65, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_feast_core_Policy_proto_rawDescOnce sync.Once
        file_feast_core_Policy_proto_rawDescData = file_feast_core_Policy_proto_rawDesc
)

func file_feast_core_Policy_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_feast_core_Policy_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_feast_core_Policy_proto_rawDescData = protoimpl.X.CompressGZIP(file_feast_core_Policy_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_feast_core_Policy_proto_rawDescData</span>
}

var file_feast_core_Policy_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_feast_core_Policy_proto_goTypes = []interface{}{
        (*Policy)(nil),          // 0: feast.core.Policy
        (*RoleBasedPolicy)(nil), // 1: feast.core.RoleBasedPolicy
}
var file_feast_core_Policy_proto_depIdxs = []int32{
        1, // 0: feast.core.Policy.role_based_policy:type_name -&gt; feast.core.RoleBasedPolicy
        1, // [1:1] is the sub-list for method output_type
        1, // [1:1] is the sub-list for method input_type
        1, // [1:1] is the sub-list for extension type_name
        1, // [1:1] is the sub-list for extension extendee
        0, // [0:1] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_feast_core_Policy_proto_init() }</span>
func file_feast_core_Policy_proto_init() <span class="cov8" title="1">{
        if File_feast_core_Policy_proto != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_feast_core_Policy_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Policy); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_Policy_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*RoleBasedPolicy); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">file_feast_core_Policy_proto_msgTypes[0].OneofWrappers = []interface{}{
                (*Policy_RoleBasedPolicy)(nil),
        }
        type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_feast_core_Policy_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   2,
                        NumExtensions: 0,
                        NumServices:   0,
                },
                GoTypes:           file_feast_core_Policy_proto_goTypes,
                DependencyIndexes: file_feast_core_Policy_proto_depIdxs,
                MessageInfos:      file_feast_core_Policy_proto_msgTypes,
        }.Build()
        File_feast_core_Policy_proto = out.File
        file_feast_core_Policy_proto_rawDesc = nil
        file_feast_core_Policy_proto_goTypes = nil
        file_feast_core_Policy_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file47" style="display: none">//
// * Copyright 2020 The Feast Authors
// *
// * Licensed under the Apache License, Version 2.0 (the "License");
// * you may not use this file except in compliance with the License.
// * You may obtain a copy of the License at
// *
// *     https://www.apache.org/licenses/LICENSE-2.0
// *
// * Unless required by applicable law or agreed to in writing, software
// * distributed under the License is distributed on an "AS IS" BASIS,
// * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// * See the License for the specific language governing permissions and
// * limitations under the License.
//

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.31.0
//         protoc        v4.25.1
// source: feast/core/Project.proto

package core

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Project struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // User-specified specifications of this entity.
        Spec *ProjectSpec `protobuf:"bytes,1,opt,name=spec,proto3" json:"spec,omitempty"`
        // System-populated metadata for this entity.
        Meta *ProjectMeta `protobuf:"bytes,2,opt,name=meta,proto3" json:"meta,omitempty"`
}

func (x *Project) Reset() <span class="cov0" title="0">{
        *x = Project{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_Project_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Project) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Project) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Project) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_Project_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use Project.ProtoReflect.Descriptor instead.
func (*Project) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_Project_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Project) GetSpec() *ProjectSpec <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Spec
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Project) GetMeta() *ProjectMeta <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Meta
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ProjectSpec struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Name of the Project
        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        // Description of the Project
        Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
        // User defined metadata
        Tags map[string]string `protobuf:"bytes,3,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        // Owner of the Project
        Owner string `protobuf:"bytes,4,opt,name=owner,proto3" json:"owner,omitempty"`
}

func (x *ProjectSpec) Reset() <span class="cov0" title="0">{
        *x = ProjectSpec{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_Project_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ProjectSpec) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ProjectSpec) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ProjectSpec) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_Project_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use ProjectSpec.ProtoReflect.Descriptor instead.
func (*ProjectSpec) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_Project_proto_rawDescGZIP(), []int{1}
}</span>

func (x *ProjectSpec) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ProjectSpec) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ProjectSpec) GetTags() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tags
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ProjectSpec) GetOwner() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Owner
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type ProjectMeta struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Time when the Project is created
        CreatedTimestamp *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=created_timestamp,json=createdTimestamp,proto3" json:"created_timestamp,omitempty"`
        // Time when the Project is last updated with registry changes (Apply stage)
        LastUpdatedTimestamp *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=last_updated_timestamp,json=lastUpdatedTimestamp,proto3" json:"last_updated_timestamp,omitempty"`
}

func (x *ProjectMeta) Reset() <span class="cov0" title="0">{
        *x = ProjectMeta{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_Project_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ProjectMeta) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ProjectMeta) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ProjectMeta) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_Project_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use ProjectMeta.ProtoReflect.Descriptor instead.
func (*ProjectMeta) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_Project_proto_rawDescGZIP(), []int{2}
}</span>

func (x *ProjectMeta) GetCreatedTimestamp() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedTimestamp
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ProjectMeta) GetLastUpdatedTimestamp() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LastUpdatedTimestamp
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_feast_core_Project_proto protoreflect.FileDescriptor

var file_feast_core_Project_proto_rawDesc = []byte{
        0x0a, 0x18, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x50, 0x72, 0x6f,
        0x6a, 0x65, 0x63, 0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0a, 0x66, 0x65, 0x61, 0x73,
        0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x1a, 0x1f, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d,
        0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x63, 0x0a, 0x07, 0x50, 0x72, 0x6f, 0x6a, 0x65,
        0x63, 0x74, 0x12, 0x2b, 0x0a, 0x04, 0x73, 0x70, 0x65, 0x63, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b,
        0x32, 0x17, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x50, 0x72,
        0x6f, 0x6a, 0x65, 0x63, 0x74, 0x53, 0x70, 0x65, 0x63, 0x52, 0x04, 0x73, 0x70, 0x65, 0x63, 0x12,
        0x2b, 0x0a, 0x04, 0x6d, 0x65, 0x74, 0x61, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e,
        0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x50, 0x72, 0x6f, 0x6a, 0x65,
        0x63, 0x74, 0x4d, 0x65, 0x74, 0x61, 0x52, 0x04, 0x6d, 0x65, 0x74, 0x61, 0x22, 0xc9, 0x01, 0x0a,
        0x0b, 0x50, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x53, 0x70, 0x65, 0x63, 0x12, 0x12, 0x0a, 0x04,
        0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65,
        0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18,
        0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69,
        0x6f, 0x6e, 0x12, 0x35, 0x0a, 0x04, 0x74, 0x61, 0x67, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b,
        0x32, 0x21, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x50, 0x72,
        0x6f, 0x6a, 0x65, 0x63, 0x74, 0x53, 0x70, 0x65, 0x63, 0x2e, 0x54, 0x61, 0x67, 0x73, 0x45, 0x6e,
        0x74, 0x72, 0x79, 0x52, 0x04, 0x74, 0x61, 0x67, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x6f, 0x77, 0x6e,
        0x65, 0x72, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x1a,
        0x37, 0x0a, 0x09, 0x54, 0x61, 0x67, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03,
        0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14,
        0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76,
        0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0xa8, 0x01, 0x0a, 0x0b, 0x50, 0x72, 0x6f,
        0x6a, 0x65, 0x63, 0x74, 0x4d, 0x65, 0x74, 0x61, 0x12, 0x47, 0x0a, 0x11, 0x63, 0x72, 0x65, 0x61,
        0x74, 0x65, 0x64, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52,
        0x10, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d,
        0x70, 0x12, 0x50, 0x0a, 0x16, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65,
        0x64, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x02, 0x20, 0x01, 0x28,
        0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x14, 0x6c,
        0x61, 0x73, 0x74, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74,
        0x61, 0x6d, 0x70, 0x42, 0x51, 0x0a, 0x10, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x42, 0x0c, 0x50, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74,
        0x50, 0x72, 0x6f, 0x74, 0x6f, 0x5a, 0x2f, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f,
        0x6d, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2d, 0x64, 0x65, 0x76, 0x2f, 0x66, 0x65, 0x61, 0x73,
        0x74, 0x2f, 0x67, 0x6f, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x73, 0x2f, 0x66, 0x65, 0x61, 0x73,
        0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_feast_core_Project_proto_rawDescOnce sync.Once
        file_feast_core_Project_proto_rawDescData = file_feast_core_Project_proto_rawDesc
)

func file_feast_core_Project_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_feast_core_Project_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_feast_core_Project_proto_rawDescData = protoimpl.X.CompressGZIP(file_feast_core_Project_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_feast_core_Project_proto_rawDescData</span>
}

var file_feast_core_Project_proto_msgTypes = make([]protoimpl.MessageInfo, 4)
var file_feast_core_Project_proto_goTypes = []interface{}{
        (*Project)(nil),               // 0: feast.core.Project
        (*ProjectSpec)(nil),           // 1: feast.core.ProjectSpec
        (*ProjectMeta)(nil),           // 2: feast.core.ProjectMeta
        nil,                           // 3: feast.core.ProjectSpec.TagsEntry
        (*timestamppb.Timestamp)(nil), // 4: google.protobuf.Timestamp
}
var file_feast_core_Project_proto_depIdxs = []int32{
        1, // 0: feast.core.Project.spec:type_name -&gt; feast.core.ProjectSpec
        2, // 1: feast.core.Project.meta:type_name -&gt; feast.core.ProjectMeta
        3, // 2: feast.core.ProjectSpec.tags:type_name -&gt; feast.core.ProjectSpec.TagsEntry
        4, // 3: feast.core.ProjectMeta.created_timestamp:type_name -&gt; google.protobuf.Timestamp
        4, // 4: feast.core.ProjectMeta.last_updated_timestamp:type_name -&gt; google.protobuf.Timestamp
        5, // [5:5] is the sub-list for method output_type
        5, // [5:5] is the sub-list for method input_type
        5, // [5:5] is the sub-list for extension type_name
        5, // [5:5] is the sub-list for extension extendee
        0, // [0:5] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_feast_core_Project_proto_init() }</span>
func file_feast_core_Project_proto_init() <span class="cov8" title="1">{
        if File_feast_core_Project_proto != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_feast_core_Project_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Project); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_Project_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ProjectSpec); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_Project_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ProjectMeta); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_feast_core_Project_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   4,
                        NumExtensions: 0,
                        NumServices:   0,
                },
                GoTypes:           file_feast_core_Project_proto_goTypes,
                DependencyIndexes: file_feast_core_Project_proto_depIdxs,
                MessageInfos:      file_feast_core_Project_proto_msgTypes,
        }.Build()
        File_feast_core_Project_proto = out.File
        file_feast_core_Project_proto_rawDesc = nil
        file_feast_core_Project_proto_goTypes = nil
        file_feast_core_Project_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">//
// * Copyright 2020 The Feast Authors
// *
// * Licensed under the Apache License, Version 2.0 (the "License");
// * you may not use this file except in compliance with the License.
// * You may obtain a copy of the License at
// *
// *     https://www.apache.org/licenses/LICENSE-2.0
// *
// * Unless required by applicable law or agreed to in writing, software
// * distributed under the License is distributed on an "AS IS" BASIS,
// * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// * See the License for the specific language governing permissions and
// * limitations under the License.
//

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.31.0
//         protoc        v4.25.1
// source: feast/core/Registry.proto

package core

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Next id: 18
type Registry struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Entities             []*Entity              `protobuf:"bytes,1,rep,name=entities,proto3" json:"entities,omitempty"`
        FeatureTables        []*FeatureTable        `protobuf:"bytes,2,rep,name=feature_tables,json=featureTables,proto3" json:"feature_tables,omitempty"`
        FeatureViews         []*FeatureView         `protobuf:"bytes,6,rep,name=feature_views,json=featureViews,proto3" json:"feature_views,omitempty"`
        DataSources          []*DataSource          `protobuf:"bytes,12,rep,name=data_sources,json=dataSources,proto3" json:"data_sources,omitempty"`
        OnDemandFeatureViews []*OnDemandFeatureView `protobuf:"bytes,8,rep,name=on_demand_feature_views,json=onDemandFeatureViews,proto3" json:"on_demand_feature_views,omitempty"`
        StreamFeatureViews   []*StreamFeatureView   `protobuf:"bytes,14,rep,name=stream_feature_views,json=streamFeatureViews,proto3" json:"stream_feature_views,omitempty"`
        SortedFeatureViews   []*SortedFeatureView   `protobuf:"bytes,30,rep,name=sorted_feature_views,json=sortedFeatureViews,proto3" json:"sorted_feature_views,omitempty"`
        FeatureServices      []*FeatureService      `protobuf:"bytes,7,rep,name=feature_services,json=featureServices,proto3" json:"feature_services,omitempty"`
        SavedDatasets        []*SavedDataset        `protobuf:"bytes,11,rep,name=saved_datasets,json=savedDatasets,proto3" json:"saved_datasets,omitempty"`
        ValidationReferences []*ValidationReference `protobuf:"bytes,13,rep,name=validation_references,json=validationReferences,proto3" json:"validation_references,omitempty"`
        Infra                *Infra                 `protobuf:"bytes,10,opt,name=infra,proto3" json:"infra,omitempty"`
        // Tracking metadata of Feast by project
        //
        // Deprecated: Marked as deprecated in feast/core/Registry.proto.
        ProjectMetadata       []*ProjectMetadata     `protobuf:"bytes,15,rep,name=project_metadata,json=projectMetadata,proto3" json:"project_metadata,omitempty"`
        RegistrySchemaVersion string                 `protobuf:"bytes,3,opt,name=registry_schema_version,json=registrySchemaVersion,proto3" json:"registry_schema_version,omitempty"` // to support migrations; incremented when schema is changed
        VersionId             string                 `protobuf:"bytes,4,opt,name=version_id,json=versionId,proto3" json:"version_id,omitempty"`                                       // version id, random string generated on each update of the data; now used only for debugging purposes
        LastUpdated           *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=last_updated,json=lastUpdated,proto3" json:"last_updated,omitempty"`
        Permissions           []*Permission          `protobuf:"bytes,16,rep,name=permissions,proto3" json:"permissions,omitempty"`
        Projects              []*Project             `protobuf:"bytes,17,rep,name=projects,proto3" json:"projects,omitempty"`
}

func (x *Registry) Reset() <span class="cov8" title="1">{
        *x = Registry{}
        if protoimpl.UnsafeEnabled </span><span class="cov8" title="1">{
                mi := &amp;file_feast_core_Registry_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Registry) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Registry) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Registry) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_Registry_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov8" title="1">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov8" title="1">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov8" title="1">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Registry.ProtoReflect.Descriptor instead.
func (*Registry) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_Registry_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Registry) GetEntities() []*Entity <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Entities
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Registry) GetFeatureTables() []*FeatureTable <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FeatureTables
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Registry) GetFeatureViews() []*FeatureView <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FeatureViews
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Registry) GetDataSources() []*DataSource <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DataSources
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Registry) GetOnDemandFeatureViews() []*OnDemandFeatureView <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OnDemandFeatureViews
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Registry) GetStreamFeatureViews() []*StreamFeatureView <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.StreamFeatureViews
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Registry) GetSortedFeatureViews() []*SortedFeatureView <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SortedFeatureViews
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Registry) GetFeatureServices() []*FeatureService <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FeatureServices
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Registry) GetSavedDatasets() []*SavedDataset <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SavedDatasets
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Registry) GetValidationReferences() []*ValidationReference <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ValidationReferences
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Registry) GetInfra() *Infra <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Infra
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Deprecated: Marked as deprecated in feast/core/Registry.proto.
func (x *Registry) GetProjectMetadata() []*ProjectMetadata <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ProjectMetadata
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Registry) GetRegistrySchemaVersion() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.RegistrySchemaVersion
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Registry) GetVersionId() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.VersionId
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Registry) GetLastUpdated() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LastUpdated
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Registry) GetPermissions() []*Permission <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Permissions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Registry) GetProjects() []*Project <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Projects
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ProjectMetadata struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Project              string                 `protobuf:"bytes,1,opt,name=project,proto3" json:"project,omitempty"`
        ProjectUuid          string                 `protobuf:"bytes,2,opt,name=project_uuid,json=projectUuid,proto3" json:"project_uuid,omitempty"`
        LastUpdatedTimestamp *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=last_updated_timestamp,json=lastUpdatedTimestamp,proto3" json:"last_updated_timestamp,omitempty"`
}

func (x *ProjectMetadata) Reset() <span class="cov0" title="0">{
        *x = ProjectMetadata{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_Registry_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ProjectMetadata) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ProjectMetadata) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ProjectMetadata) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_Registry_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use ProjectMetadata.ProtoReflect.Descriptor instead.
func (*ProjectMetadata) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_Registry_proto_rawDescGZIP(), []int{1}
}</span>

func (x *ProjectMetadata) GetProject() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Project
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ProjectMetadata) GetProjectUuid() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ProjectUuid
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ProjectMetadata) GetLastUpdatedTimestamp() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LastUpdatedTimestamp
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_feast_core_Registry_proto protoreflect.FileDescriptor

var file_feast_core_Registry_proto_rawDesc = []byte{
        0x0a, 0x19, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x52, 0x65, 0x67,
        0x69, 0x73, 0x74, 0x72, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0a, 0x66, 0x65, 0x61,
        0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x1a, 0x17, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63,
        0x6f, 0x72, 0x65, 0x2f, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x1a, 0x1f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x46, 0x65, 0x61,
        0x74, 0x75, 0x72, 0x65, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x1a, 0x1d, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x46, 0x65,
        0x61, 0x74, 0x75, 0x72, 0x65, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x1a, 0x1c, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x46, 0x65, 0x61,
        0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1c,
        0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x49, 0x6e, 0x66, 0x72, 0x61,
        0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x24, 0x66, 0x65,
        0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x4f, 0x6e, 0x44, 0x65, 0x6d, 0x61, 0x6e,
        0x64, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x1a, 0x22, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x53,
        0x74, 0x72, 0x65, 0x61, 0x6d, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77,
        0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1b, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f,
        0x72, 0x65, 0x2f, 0x44, 0x61, 0x74, 0x61, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x1a, 0x1d, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f,
        0x53, 0x61, 0x76, 0x65, 0x64, 0x44, 0x61, 0x74, 0x61, 0x73, 0x65, 0x74, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x1a, 0x22, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x53,
        0x6f, 0x72, 0x74, 0x65, 0x64, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77,
        0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x22, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f,
        0x72, 0x65, 0x2f, 0x56, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x72, 0x6f,
        0x66, 0x69, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1f, 0x67, 0x6f, 0x6f, 0x67,
        0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x74, 0x69, 0x6d, 0x65,
        0x73, 0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1b, 0x66, 0x65, 0x61,
        0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x50, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69,
        0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x18, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f,
        0x63, 0x6f, 0x72, 0x65, 0x2f, 0x50, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x22, 0xc2, 0x08, 0x0a, 0x08, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x72, 0x79, 0x12,
        0x2e, 0x0a, 0x08, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x69, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28,
        0x0b, 0x32, 0x12, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x45,
        0x6e, 0x74, 0x69, 0x74, 0x79, 0x52, 0x08, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x69, 0x65, 0x73, 0x12,
        0x3f, 0x0a, 0x0e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x5f, 0x74, 0x61, 0x62, 0x6c, 0x65,
        0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e,
        0x63, 0x6f, 0x72, 0x65, 0x2e, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x54, 0x61, 0x62, 0x6c,
        0x65, 0x52, 0x0d, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x73,
        0x12, 0x3c, 0x0a, 0x0d, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x5f, 0x76, 0x69, 0x65, 0x77,
        0x73, 0x18, 0x06, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e,
        0x63, 0x6f, 0x72, 0x65, 0x2e, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77,
        0x52, 0x0c, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77, 0x73, 0x12, 0x39,
        0x0a, 0x0c, 0x64, 0x61, 0x74, 0x61, 0x5f, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x18, 0x0c,
        0x20, 0x03, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72,
        0x65, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x52, 0x0b, 0x64, 0x61,
        0x74, 0x61, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x73, 0x12, 0x56, 0x0a, 0x17, 0x6f, 0x6e, 0x5f,
        0x64, 0x65, 0x6d, 0x61, 0x6e, 0x64, 0x5f, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x5f, 0x76,
        0x69, 0x65, 0x77, 0x73, 0x18, 0x08, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x66, 0x65, 0x61,
        0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x4f, 0x6e, 0x44, 0x65, 0x6d, 0x61, 0x6e, 0x64,
        0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77, 0x52, 0x14, 0x6f, 0x6e, 0x44,
        0x65, 0x6d, 0x61, 0x6e, 0x64, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77,
        0x73, 0x12, 0x4f, 0x0a, 0x14, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x5f, 0x66, 0x65, 0x61, 0x74,
        0x75, 0x72, 0x65, 0x5f, 0x76, 0x69, 0x65, 0x77, 0x73, 0x18, 0x0e, 0x20, 0x03, 0x28, 0x0b, 0x32,
        0x1d, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x53, 0x74, 0x72,
        0x65, 0x61, 0x6d, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77, 0x52, 0x12,
        0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65,
        0x77, 0x73, 0x12, 0x4f, 0x0a, 0x14, 0x73, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x5f, 0x66, 0x65, 0x61,
        0x74, 0x75, 0x72, 0x65, 0x5f, 0x76, 0x69, 0x65, 0x77, 0x73, 0x18, 0x1e, 0x20, 0x03, 0x28, 0x0b,
        0x32, 0x1d, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x53, 0x6f,
        0x72, 0x74, 0x65, 0x64, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77, 0x52,
        0x12, 0x73, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69,
        0x65, 0x77, 0x73, 0x12, 0x45, 0x0a, 0x10, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x5f, 0x73,
        0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x18, 0x07, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1a, 0x2e,
        0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x46, 0x65, 0x61, 0x74, 0x75,
        0x72, 0x65, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x52, 0x0f, 0x66, 0x65, 0x61, 0x74, 0x75,
        0x72, 0x65, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x73, 0x12, 0x3f, 0x0a, 0x0e, 0x73, 0x61,
        0x76, 0x65, 0x64, 0x5f, 0x64, 0x61, 0x74, 0x61, 0x73, 0x65, 0x74, 0x73, 0x18, 0x0b, 0x20, 0x03,
        0x28, 0x0b, 0x32, 0x18, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e,
        0x53, 0x61, 0x76, 0x65, 0x64, 0x44, 0x61, 0x74, 0x61, 0x73, 0x65, 0x74, 0x52, 0x0d, 0x73, 0x61,
        0x76, 0x65, 0x64, 0x44, 0x61, 0x74, 0x61, 0x73, 0x65, 0x74, 0x73, 0x12, 0x54, 0x0a, 0x15, 0x76,
        0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65,
        0x6e, 0x63, 0x65, 0x73, 0x18, 0x0d, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x66, 0x65, 0x61,
        0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x56, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x69,
        0x6f, 0x6e, 0x52, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x63, 0x65, 0x52, 0x14, 0x76, 0x61, 0x6c,
        0x69, 0x64, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x63, 0x65,
        0x73, 0x12, 0x27, 0x0a, 0x05, 0x69, 0x6e, 0x66, 0x72, 0x61, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0b,
        0x32, 0x11, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x49, 0x6e,
        0x66, 0x72, 0x61, 0x52, 0x05, 0x69, 0x6e, 0x66, 0x72, 0x61, 0x12, 0x4a, 0x0a, 0x10, 0x70, 0x72,
        0x6f, 0x6a, 0x65, 0x63, 0x74, 0x5f, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x18, 0x0f,
        0x20, 0x03, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72,
        0x65, 0x2e, 0x50, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74,
        0x61, 0x42, 0x02, 0x18, 0x01, 0x52, 0x0f, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x4d, 0x65,
        0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x12, 0x36, 0x0a, 0x17, 0x72, 0x65, 0x67, 0x69, 0x73, 0x74,
        0x72, 0x79, 0x5f, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x5f, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f,
        0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x15, 0x72, 0x65, 0x67, 0x69, 0x73, 0x74, 0x72,
        0x79, 0x53, 0x63, 0x68, 0x65, 0x6d, 0x61, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x1d,
        0x0a, 0x0a, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x69, 0x64, 0x18, 0x04, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x09, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x49, 0x64, 0x12, 0x3d, 0x0a,
        0x0c, 0x6c, 0x61, 0x73, 0x74, 0x5f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x18, 0x05, 0x20,
        0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52,
        0x0b, 0x6c, 0x61, 0x73, 0x74, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x12, 0x38, 0x0a, 0x0b,
        0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x10, 0x20, 0x03, 0x28,
        0x0b, 0x32, 0x16, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x50,
        0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x52, 0x0b, 0x70, 0x65, 0x72, 0x6d, 0x69,
        0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x2f, 0x0a, 0x08, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63,
        0x74, 0x73, 0x18, 0x11, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x13, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74,
        0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x50, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x52, 0x08, 0x70,
        0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x73, 0x22, 0xa0, 0x01, 0x0a, 0x0f, 0x50, 0x72, 0x6f, 0x6a,
        0x65, 0x63, 0x74, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x12, 0x18, 0x0a, 0x07, 0x70,
        0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x70, 0x72,
        0x6f, 0x6a, 0x65, 0x63, 0x74, 0x12, 0x21, 0x0a, 0x0c, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74,
        0x5f, 0x75, 0x75, 0x69, 0x64, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x70, 0x72, 0x6f,
        0x6a, 0x65, 0x63, 0x74, 0x55, 0x75, 0x69, 0x64, 0x12, 0x50, 0x0a, 0x16, 0x6c, 0x61, 0x73, 0x74,
        0x5f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61,
        0x6d, 0x70, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
        0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73,
        0x74, 0x61, 0x6d, 0x70, 0x52, 0x14, 0x6c, 0x61, 0x73, 0x74, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65,
        0x64, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x42, 0x52, 0x0a, 0x10, 0x66, 0x65,
        0x61, 0x73, 0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x42, 0x0d,
        0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x72, 0x79, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x5a, 0x2f, 0x67,
        0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2d,
        0x64, 0x65, 0x76, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x67, 0x6f, 0x2f, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x73, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x62, 0x06,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_feast_core_Registry_proto_rawDescOnce sync.Once
        file_feast_core_Registry_proto_rawDescData = file_feast_core_Registry_proto_rawDesc
)

func file_feast_core_Registry_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_feast_core_Registry_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_feast_core_Registry_proto_rawDescData = protoimpl.X.CompressGZIP(file_feast_core_Registry_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_feast_core_Registry_proto_rawDescData</span>
}

var file_feast_core_Registry_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_feast_core_Registry_proto_goTypes = []interface{}{
        (*Registry)(nil),              // 0: feast.core.Registry
        (*ProjectMetadata)(nil),       // 1: feast.core.ProjectMetadata
        (*Entity)(nil),                // 2: feast.core.Entity
        (*FeatureTable)(nil),          // 3: feast.core.FeatureTable
        (*FeatureView)(nil),           // 4: feast.core.FeatureView
        (*DataSource)(nil),            // 5: feast.core.DataSource
        (*OnDemandFeatureView)(nil),   // 6: feast.core.OnDemandFeatureView
        (*StreamFeatureView)(nil),     // 7: feast.core.StreamFeatureView
        (*SortedFeatureView)(nil),     // 8: feast.core.SortedFeatureView
        (*FeatureService)(nil),        // 9: feast.core.FeatureService
        (*SavedDataset)(nil),          // 10: feast.core.SavedDataset
        (*ValidationReference)(nil),   // 11: feast.core.ValidationReference
        (*Infra)(nil),                 // 12: feast.core.Infra
        (*timestamppb.Timestamp)(nil), // 13: google.protobuf.Timestamp
        (*Permission)(nil),            // 14: feast.core.Permission
        (*Project)(nil),               // 15: feast.core.Project
}
var file_feast_core_Registry_proto_depIdxs = []int32{
        2,  // 0: feast.core.Registry.entities:type_name -&gt; feast.core.Entity
        3,  // 1: feast.core.Registry.feature_tables:type_name -&gt; feast.core.FeatureTable
        4,  // 2: feast.core.Registry.feature_views:type_name -&gt; feast.core.FeatureView
        5,  // 3: feast.core.Registry.data_sources:type_name -&gt; feast.core.DataSource
        6,  // 4: feast.core.Registry.on_demand_feature_views:type_name -&gt; feast.core.OnDemandFeatureView
        7,  // 5: feast.core.Registry.stream_feature_views:type_name -&gt; feast.core.StreamFeatureView
        8,  // 6: feast.core.Registry.sorted_feature_views:type_name -&gt; feast.core.SortedFeatureView
        9,  // 7: feast.core.Registry.feature_services:type_name -&gt; feast.core.FeatureService
        10, // 8: feast.core.Registry.saved_datasets:type_name -&gt; feast.core.SavedDataset
        11, // 9: feast.core.Registry.validation_references:type_name -&gt; feast.core.ValidationReference
        12, // 10: feast.core.Registry.infra:type_name -&gt; feast.core.Infra
        1,  // 11: feast.core.Registry.project_metadata:type_name -&gt; feast.core.ProjectMetadata
        13, // 12: feast.core.Registry.last_updated:type_name -&gt; google.protobuf.Timestamp
        14, // 13: feast.core.Registry.permissions:type_name -&gt; feast.core.Permission
        15, // 14: feast.core.Registry.projects:type_name -&gt; feast.core.Project
        13, // 15: feast.core.ProjectMetadata.last_updated_timestamp:type_name -&gt; google.protobuf.Timestamp
        16, // [16:16] is the sub-list for method output_type
        16, // [16:16] is the sub-list for method input_type
        16, // [16:16] is the sub-list for extension type_name
        16, // [16:16] is the sub-list for extension extendee
        0,  // [0:16] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_feast_core_Registry_proto_init() }</span>
func file_feast_core_Registry_proto_init() <span class="cov8" title="1">{
        if File_feast_core_Registry_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">file_feast_core_Entity_proto_init()
        file_feast_core_FeatureService_proto_init()
        file_feast_core_FeatureTable_proto_init()
        file_feast_core_FeatureView_proto_init()
        file_feast_core_InfraObject_proto_init()
        file_feast_core_OnDemandFeatureView_proto_init()
        file_feast_core_StreamFeatureView_proto_init()
        file_feast_core_DataSource_proto_init()
        file_feast_core_SavedDataset_proto_init()
        file_feast_core_SortedFeatureView_proto_init()
        file_feast_core_ValidationProfile_proto_init()
        file_feast_core_Permission_proto_init()
        file_feast_core_Project_proto_init()
        if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_feast_core_Registry_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Registry); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_Registry_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ProjectMetadata); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_feast_core_Registry_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   2,
                        NumExtensions: 0,
                        NumServices:   0,
                },
                GoTypes:           file_feast_core_Registry_proto_goTypes,
                DependencyIndexes: file_feast_core_Registry_proto_depIdxs,
                MessageInfos:      file_feast_core_Registry_proto_msgTypes,
        }.Build()
        File_feast_core_Registry_proto = out.File
        file_feast_core_Registry_proto_rawDesc = nil
        file_feast_core_Registry_proto_goTypes = nil
        file_feast_core_Registry_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">//
// Copyright 2021 The Feast Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.31.0
//         protoc        v4.25.1
// source: feast/core/SavedDataset.proto

package core

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type SavedDatasetSpec struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Name of the dataset. Must be unique since it's possible to overwrite dataset by name
        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        // Name of Feast project that this Dataset belongs to.
        Project string `protobuf:"bytes,2,opt,name=project,proto3" json:"project,omitempty"`
        // list of feature references with format "&lt;view name&gt;:&lt;feature name&gt;"
        Features []string `protobuf:"bytes,3,rep,name=features,proto3" json:"features,omitempty"`
        // entity columns + request columns from all feature views used during retrieval
        JoinKeys []string `protobuf:"bytes,4,rep,name=join_keys,json=joinKeys,proto3" json:"join_keys,omitempty"`
        // Whether full feature names are used in stored data
        FullFeatureNames bool                 `protobuf:"varint,5,opt,name=full_feature_names,json=fullFeatureNames,proto3" json:"full_feature_names,omitempty"`
        Storage          *SavedDatasetStorage `protobuf:"bytes,6,opt,name=storage,proto3" json:"storage,omitempty"`
        // Optional and only populated if generated from a feature service fetch
        FeatureServiceName string `protobuf:"bytes,8,opt,name=feature_service_name,json=featureServiceName,proto3" json:"feature_service_name,omitempty"`
        // User defined metadata
        Tags map[string]string `protobuf:"bytes,7,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (x *SavedDatasetSpec) Reset() <span class="cov0" title="0">{
        *x = SavedDatasetSpec{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_SavedDataset_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *SavedDatasetSpec) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SavedDatasetSpec) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SavedDatasetSpec) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_feast_core_SavedDataset_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SavedDatasetSpec.ProtoReflect.Descriptor instead.
func (*SavedDatasetSpec) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_SavedDataset_proto_rawDescGZIP(), []int{0}
}</span>

func (x *SavedDatasetSpec) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SavedDatasetSpec) GetProject() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Project
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SavedDatasetSpec) GetFeatures() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Features
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SavedDatasetSpec) GetJoinKeys() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.JoinKeys
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SavedDatasetSpec) GetFullFeatureNames() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FullFeatureNames
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *SavedDatasetSpec) GetStorage() *SavedDatasetStorage <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Storage
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SavedDatasetSpec) GetFeatureServiceName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FeatureServiceName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SavedDatasetSpec) GetTags() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tags
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type SavedDatasetStorage struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Types that are assignable to Kind:
        //
        //        *SavedDatasetStorage_FileStorage
        //        *SavedDatasetStorage_BigqueryStorage
        //        *SavedDatasetStorage_RedshiftStorage
        //        *SavedDatasetStorage_SnowflakeStorage
        //        *SavedDatasetStorage_TrinoStorage
        //        *SavedDatasetStorage_SparkStorage
        //        *SavedDatasetStorage_CustomStorage
        //        *SavedDatasetStorage_AthenaStorage
        Kind isSavedDatasetStorage_Kind `protobuf_oneof:"kind"`
}

func (x *SavedDatasetStorage) Reset() <span class="cov0" title="0">{
        *x = SavedDatasetStorage{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_SavedDataset_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *SavedDatasetStorage) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SavedDatasetStorage) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SavedDatasetStorage) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_feast_core_SavedDataset_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SavedDatasetStorage.ProtoReflect.Descriptor instead.
func (*SavedDatasetStorage) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_SavedDataset_proto_rawDescGZIP(), []int{1}
}</span>

func (m *SavedDatasetStorage) GetKind() isSavedDatasetStorage_Kind <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Kind
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SavedDatasetStorage) GetFileStorage() *DataSource_FileOptions <span class="cov0" title="0">{
        if x, ok := x.GetKind().(*SavedDatasetStorage_FileStorage); ok </span><span class="cov0" title="0">{
                return x.FileStorage
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SavedDatasetStorage) GetBigqueryStorage() *DataSource_BigQueryOptions <span class="cov0" title="0">{
        if x, ok := x.GetKind().(*SavedDatasetStorage_BigqueryStorage); ok </span><span class="cov0" title="0">{
                return x.BigqueryStorage
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SavedDatasetStorage) GetRedshiftStorage() *DataSource_RedshiftOptions <span class="cov0" title="0">{
        if x, ok := x.GetKind().(*SavedDatasetStorage_RedshiftStorage); ok </span><span class="cov0" title="0">{
                return x.RedshiftStorage
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SavedDatasetStorage) GetSnowflakeStorage() *DataSource_SnowflakeOptions <span class="cov0" title="0">{
        if x, ok := x.GetKind().(*SavedDatasetStorage_SnowflakeStorage); ok </span><span class="cov0" title="0">{
                return x.SnowflakeStorage
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SavedDatasetStorage) GetTrinoStorage() *DataSource_TrinoOptions <span class="cov0" title="0">{
        if x, ok := x.GetKind().(*SavedDatasetStorage_TrinoStorage); ok </span><span class="cov0" title="0">{
                return x.TrinoStorage
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SavedDatasetStorage) GetSparkStorage() *DataSource_SparkOptions <span class="cov0" title="0">{
        if x, ok := x.GetKind().(*SavedDatasetStorage_SparkStorage); ok </span><span class="cov0" title="0">{
                return x.SparkStorage
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SavedDatasetStorage) GetCustomStorage() *DataSource_CustomSourceOptions <span class="cov0" title="0">{
        if x, ok := x.GetKind().(*SavedDatasetStorage_CustomStorage); ok </span><span class="cov0" title="0">{
                return x.CustomStorage
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SavedDatasetStorage) GetAthenaStorage() *DataSource_AthenaOptions <span class="cov0" title="0">{
        if x, ok := x.GetKind().(*SavedDatasetStorage_AthenaStorage); ok </span><span class="cov0" title="0">{
                return x.AthenaStorage
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type isSavedDatasetStorage_Kind interface {
        isSavedDatasetStorage_Kind()
}

type SavedDatasetStorage_FileStorage struct {
        FileStorage *DataSource_FileOptions `protobuf:"bytes,4,opt,name=file_storage,json=fileStorage,proto3,oneof"`
}

type SavedDatasetStorage_BigqueryStorage struct {
        BigqueryStorage *DataSource_BigQueryOptions `protobuf:"bytes,5,opt,name=bigquery_storage,json=bigqueryStorage,proto3,oneof"`
}

type SavedDatasetStorage_RedshiftStorage struct {
        RedshiftStorage *DataSource_RedshiftOptions `protobuf:"bytes,6,opt,name=redshift_storage,json=redshiftStorage,proto3,oneof"`
}

type SavedDatasetStorage_SnowflakeStorage struct {
        SnowflakeStorage *DataSource_SnowflakeOptions `protobuf:"bytes,7,opt,name=snowflake_storage,json=snowflakeStorage,proto3,oneof"`
}

type SavedDatasetStorage_TrinoStorage struct {
        TrinoStorage *DataSource_TrinoOptions `protobuf:"bytes,8,opt,name=trino_storage,json=trinoStorage,proto3,oneof"`
}

type SavedDatasetStorage_SparkStorage struct {
        SparkStorage *DataSource_SparkOptions `protobuf:"bytes,9,opt,name=spark_storage,json=sparkStorage,proto3,oneof"`
}

type SavedDatasetStorage_CustomStorage struct {
        CustomStorage *DataSource_CustomSourceOptions `protobuf:"bytes,10,opt,name=custom_storage,json=customStorage,proto3,oneof"`
}

type SavedDatasetStorage_AthenaStorage struct {
        AthenaStorage *DataSource_AthenaOptions `protobuf:"bytes,11,opt,name=athena_storage,json=athenaStorage,proto3,oneof"`
}

func (*SavedDatasetStorage_FileStorage) isSavedDatasetStorage_Kind() {<span class="cov0" title="0">}</span>

func (*SavedDatasetStorage_BigqueryStorage) isSavedDatasetStorage_Kind() {<span class="cov0" title="0">}</span>

func (*SavedDatasetStorage_RedshiftStorage) isSavedDatasetStorage_Kind() {<span class="cov0" title="0">}</span>

func (*SavedDatasetStorage_SnowflakeStorage) isSavedDatasetStorage_Kind() {<span class="cov0" title="0">}</span>

func (*SavedDatasetStorage_TrinoStorage) isSavedDatasetStorage_Kind() {<span class="cov0" title="0">}</span>

func (*SavedDatasetStorage_SparkStorage) isSavedDatasetStorage_Kind() {<span class="cov0" title="0">}</span>

func (*SavedDatasetStorage_CustomStorage) isSavedDatasetStorage_Kind() {<span class="cov0" title="0">}</span>

func (*SavedDatasetStorage_AthenaStorage) isSavedDatasetStorage_Kind() {<span class="cov0" title="0">}</span>

type SavedDatasetMeta struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Time when this saved dataset is created
        CreatedTimestamp *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=created_timestamp,json=createdTimestamp,proto3" json:"created_timestamp,omitempty"`
        // Time when this saved dataset is last updated
        LastUpdatedTimestamp *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=last_updated_timestamp,json=lastUpdatedTimestamp,proto3" json:"last_updated_timestamp,omitempty"`
        // Min timestamp in the dataset (needed for retrieval)
        MinEventTimestamp *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=min_event_timestamp,json=minEventTimestamp,proto3" json:"min_event_timestamp,omitempty"`
        // Max timestamp in the dataset (needed for retrieval)
        MaxEventTimestamp *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=max_event_timestamp,json=maxEventTimestamp,proto3" json:"max_event_timestamp,omitempty"`
}

func (x *SavedDatasetMeta) Reset() <span class="cov0" title="0">{
        *x = SavedDatasetMeta{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_SavedDataset_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *SavedDatasetMeta) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SavedDatasetMeta) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SavedDatasetMeta) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_feast_core_SavedDataset_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SavedDatasetMeta.ProtoReflect.Descriptor instead.
func (*SavedDatasetMeta) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_SavedDataset_proto_rawDescGZIP(), []int{2}
}</span>

func (x *SavedDatasetMeta) GetCreatedTimestamp() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.CreatedTimestamp
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SavedDatasetMeta) GetLastUpdatedTimestamp() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.LastUpdatedTimestamp
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SavedDatasetMeta) GetMinEventTimestamp() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MinEventTimestamp
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SavedDatasetMeta) GetMaxEventTimestamp() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MaxEventTimestamp
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type SavedDataset struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Spec *SavedDatasetSpec `protobuf:"bytes,1,opt,name=spec,proto3" json:"spec,omitempty"`
        Meta *SavedDatasetMeta `protobuf:"bytes,2,opt,name=meta,proto3" json:"meta,omitempty"`
}

func (x *SavedDataset) Reset() <span class="cov0" title="0">{
        *x = SavedDataset{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_SavedDataset_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *SavedDataset) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SavedDataset) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SavedDataset) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_SavedDataset_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use SavedDataset.ProtoReflect.Descriptor instead.
func (*SavedDataset) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_SavedDataset_proto_rawDescGZIP(), []int{3}
}</span>

func (x *SavedDataset) GetSpec() *SavedDatasetSpec <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Spec
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SavedDataset) GetMeta() *SavedDatasetMeta <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Meta
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_feast_core_SavedDataset_proto protoreflect.FileDescriptor

var file_feast_core_SavedDataset_proto_rawDesc = []byte{
        0x0a, 0x1d, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x53, 0x61, 0x76,
        0x65, 0x64, 0x44, 0x61, 0x74, 0x61, 0x73, 0x65, 0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12,
        0x0a, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x1a, 0x1f, 0x67, 0x6f, 0x6f,
        0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x74, 0x69, 0x6d,
        0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1b, 0x66, 0x65,
        0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x44, 0x61, 0x74, 0x61, 0x53, 0x6f, 0x75,
        0x72, 0x63, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x89, 0x03, 0x0a, 0x10, 0x53, 0x61,
        0x76, 0x65, 0x64, 0x44, 0x61, 0x74, 0x61, 0x73, 0x65, 0x74, 0x53, 0x70, 0x65, 0x63, 0x12, 0x12,
        0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61,
        0x6d, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x18, 0x02, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x07, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x12, 0x1a, 0x0a, 0x08,
        0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x09, 0x52, 0x08,
        0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x12, 0x1b, 0x0a, 0x09, 0x6a, 0x6f, 0x69, 0x6e,
        0x5f, 0x6b, 0x65, 0x79, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x09, 0x52, 0x08, 0x6a, 0x6f, 0x69,
        0x6e, 0x4b, 0x65, 0x79, 0x73, 0x12, 0x2c, 0x0a, 0x12, 0x66, 0x75, 0x6c, 0x6c, 0x5f, 0x66, 0x65,
        0x61, 0x74, 0x75, 0x72, 0x65, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28,
        0x08, 0x52, 0x10, 0x66, 0x75, 0x6c, 0x6c, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x4e, 0x61,
        0x6d, 0x65, 0x73, 0x12, 0x39, 0x0a, 0x07, 0x73, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x18, 0x06,
        0x20, 0x01, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72,
        0x65, 0x2e, 0x53, 0x61, 0x76, 0x65, 0x64, 0x44, 0x61, 0x74, 0x61, 0x73, 0x65, 0x74, 0x53, 0x74,
        0x6f, 0x72, 0x61, 0x67, 0x65, 0x52, 0x07, 0x73, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x12, 0x30,
        0x0a, 0x14, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x5f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63,
        0x65, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x08, 0x20, 0x01, 0x28, 0x09, 0x52, 0x12, 0x66, 0x65,
        0x61, 0x74, 0x75, 0x72, 0x65, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x4e, 0x61, 0x6d, 0x65,
        0x12, 0x3a, 0x0a, 0x04, 0x74, 0x61, 0x67, 0x73, 0x18, 0x07, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x26,
        0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x53, 0x61, 0x76, 0x65,
        0x64, 0x44, 0x61, 0x74, 0x61, 0x73, 0x65, 0x74, 0x53, 0x70, 0x65, 0x63, 0x2e, 0x54, 0x61, 0x67,
        0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x04, 0x74, 0x61, 0x67, 0x73, 0x1a, 0x37, 0x0a, 0x09,
        0x54, 0x61, 0x67, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76,
        0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75,
        0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0xa4, 0x05, 0x0a, 0x13, 0x53, 0x61, 0x76, 0x65, 0x64, 0x44,
        0x61, 0x74, 0x61, 0x73, 0x65, 0x74, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x12, 0x47, 0x0a,
        0x0c, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x73, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x18, 0x04, 0x20,
        0x01, 0x28, 0x0b, 0x32, 0x22, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65,
        0x2e, 0x44, 0x61, 0x74, 0x61, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x46, 0x69, 0x6c, 0x65,
        0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x48, 0x00, 0x52, 0x0b, 0x66, 0x69, 0x6c, 0x65, 0x53,
        0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x12, 0x53, 0x0a, 0x10, 0x62, 0x69, 0x67, 0x71, 0x75, 0x65,
        0x72, 0x79, 0x5f, 0x73, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b,
        0x32, 0x26, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x44, 0x61,
        0x74, 0x61, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x42, 0x69, 0x67, 0x51, 0x75, 0x65, 0x72,
        0x79, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x48, 0x00, 0x52, 0x0f, 0x62, 0x69, 0x67, 0x71,
        0x75, 0x65, 0x72, 0x79, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x12, 0x53, 0x0a, 0x10, 0x72,
        0x65, 0x64, 0x73, 0x68, 0x69, 0x66, 0x74, 0x5f, 0x73, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x18,
        0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f,
        0x72, 0x65, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x52, 0x65,
        0x64, 0x73, 0x68, 0x69, 0x66, 0x74, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x48, 0x00, 0x52,
        0x0f, 0x72, 0x65, 0x64, 0x73, 0x68, 0x69, 0x66, 0x74, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65,
        0x12, 0x56, 0x0a, 0x11, 0x73, 0x6e, 0x6f, 0x77, 0x66, 0x6c, 0x61, 0x6b, 0x65, 0x5f, 0x73, 0x74,
        0x6f, 0x72, 0x61, 0x67, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x27, 0x2e, 0x66, 0x65,
        0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x53, 0x6f, 0x75,
        0x72, 0x63, 0x65, 0x2e, 0x53, 0x6e, 0x6f, 0x77, 0x66, 0x6c, 0x61, 0x6b, 0x65, 0x4f, 0x70, 0x74,
        0x69, 0x6f, 0x6e, 0x73, 0x48, 0x00, 0x52, 0x10, 0x73, 0x6e, 0x6f, 0x77, 0x66, 0x6c, 0x61, 0x6b,
        0x65, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x12, 0x4a, 0x0a, 0x0d, 0x74, 0x72, 0x69, 0x6e,
        0x6f, 0x5f, 0x73, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32,
        0x23, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x44, 0x61, 0x74,
        0x61, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x54, 0x72, 0x69, 0x6e, 0x6f, 0x4f, 0x70, 0x74,
        0x69, 0x6f, 0x6e, 0x73, 0x48, 0x00, 0x52, 0x0c, 0x74, 0x72, 0x69, 0x6e, 0x6f, 0x53, 0x74, 0x6f,
        0x72, 0x61, 0x67, 0x65, 0x12, 0x4a, 0x0a, 0x0d, 0x73, 0x70, 0x61, 0x72, 0x6b, 0x5f, 0x73, 0x74,
        0x6f, 0x72, 0x61, 0x67, 0x65, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e, 0x66, 0x65,
        0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x53, 0x6f, 0x75,
        0x72, 0x63, 0x65, 0x2e, 0x53, 0x70, 0x61, 0x72, 0x6b, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73,
        0x48, 0x00, 0x52, 0x0c, 0x73, 0x70, 0x61, 0x72, 0x6b, 0x53, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65,
        0x12, 0x53, 0x0a, 0x0e, 0x63, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x5f, 0x73, 0x74, 0x6f, 0x72, 0x61,
        0x67, 0x65, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x2a, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74,
        0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65,
        0x2e, 0x43, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x4f, 0x70, 0x74,
        0x69, 0x6f, 0x6e, 0x73, 0x48, 0x00, 0x52, 0x0d, 0x63, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x53, 0x74,
        0x6f, 0x72, 0x61, 0x67, 0x65, 0x12, 0x4d, 0x0a, 0x0e, 0x61, 0x74, 0x68, 0x65, 0x6e, 0x61, 0x5f,
        0x73, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e,
        0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x53,
        0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x41, 0x74, 0x68, 0x65, 0x6e, 0x61, 0x4f, 0x70, 0x74, 0x69,
        0x6f, 0x6e, 0x73, 0x48, 0x00, 0x52, 0x0d, 0x61, 0x74, 0x68, 0x65, 0x6e, 0x61, 0x53, 0x74, 0x6f,
        0x72, 0x61, 0x67, 0x65, 0x42, 0x06, 0x0a, 0x04, 0x6b, 0x69, 0x6e, 0x64, 0x22, 0xc5, 0x02, 0x0a,
        0x10, 0x53, 0x61, 0x76, 0x65, 0x64, 0x44, 0x61, 0x74, 0x61, 0x73, 0x65, 0x74, 0x4d, 0x65, 0x74,
        0x61, 0x12, 0x47, 0x0a, 0x11, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x74, 0x69, 0x6d,
        0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67,
        0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54,
        0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x10, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65,
        0x64, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x12, 0x50, 0x0a, 0x16, 0x6c, 0x61,
        0x73, 0x74, 0x5f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x73,
        0x74, 0x61, 0x6d, 0x70, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f,
        0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d,
        0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x14, 0x6c, 0x61, 0x73, 0x74, 0x55, 0x70, 0x64, 0x61,
        0x74, 0x65, 0x64, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x12, 0x4a, 0x0a, 0x13,
        0x6d, 0x69, 0x6e, 0x5f, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74,
        0x61, 0x6d, 0x70, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67,
        0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65,
        0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x11, 0x6d, 0x69, 0x6e, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x54,
        0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x12, 0x4a, 0x0a, 0x13, 0x6d, 0x61, 0x78, 0x5f,
        0x65, 0x76, 0x65, 0x6e, 0x74, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18,
        0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d,
        0x70, 0x52, 0x11, 0x6d, 0x61, 0x78, 0x45, 0x76, 0x65, 0x6e, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x73,
        0x74, 0x61, 0x6d, 0x70, 0x22, 0x72, 0x0a, 0x0c, 0x53, 0x61, 0x76, 0x65, 0x64, 0x44, 0x61, 0x74,
        0x61, 0x73, 0x65, 0x74, 0x12, 0x30, 0x0a, 0x04, 0x73, 0x70, 0x65, 0x63, 0x18, 0x01, 0x20, 0x01,
        0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e,
        0x53, 0x61, 0x76, 0x65, 0x64, 0x44, 0x61, 0x74, 0x61, 0x73, 0x65, 0x74, 0x53, 0x70, 0x65, 0x63,
        0x52, 0x04, 0x73, 0x70, 0x65, 0x63, 0x12, 0x30, 0x0a, 0x04, 0x6d, 0x65, 0x74, 0x61, 0x18, 0x02,
        0x20, 0x01, 0x28, 0x0b, 0x32, 0x1c, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72,
        0x65, 0x2e, 0x53, 0x61, 0x76, 0x65, 0x64, 0x44, 0x61, 0x74, 0x61, 0x73, 0x65, 0x74, 0x4d, 0x65,
        0x74, 0x61, 0x52, 0x04, 0x6d, 0x65, 0x74, 0x61, 0x42, 0x56, 0x0a, 0x10, 0x66, 0x65, 0x61, 0x73,
        0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x42, 0x11, 0x53, 0x61,
        0x76, 0x65, 0x64, 0x44, 0x61, 0x74, 0x61, 0x73, 0x65, 0x74, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x5a,
        0x2f, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x66, 0x65, 0x61, 0x73,
        0x74, 0x2d, 0x64, 0x65, 0x76, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x67, 0x6f, 0x2f, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x73, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65,
        0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_feast_core_SavedDataset_proto_rawDescOnce sync.Once
        file_feast_core_SavedDataset_proto_rawDescData = file_feast_core_SavedDataset_proto_rawDesc
)

func file_feast_core_SavedDataset_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_feast_core_SavedDataset_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_feast_core_SavedDataset_proto_rawDescData = protoimpl.X.CompressGZIP(file_feast_core_SavedDataset_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_feast_core_SavedDataset_proto_rawDescData</span>
}

var file_feast_core_SavedDataset_proto_msgTypes = make([]protoimpl.MessageInfo, 5)
var file_feast_core_SavedDataset_proto_goTypes = []interface{}{
        (*SavedDatasetSpec)(nil),               // 0: feast.core.SavedDatasetSpec
        (*SavedDatasetStorage)(nil),            // 1: feast.core.SavedDatasetStorage
        (*SavedDatasetMeta)(nil),               // 2: feast.core.SavedDatasetMeta
        (*SavedDataset)(nil),                   // 3: feast.core.SavedDataset
        nil,                                    // 4: feast.core.SavedDatasetSpec.TagsEntry
        (*DataSource_FileOptions)(nil),         // 5: feast.core.DataSource.FileOptions
        (*DataSource_BigQueryOptions)(nil),     // 6: feast.core.DataSource.BigQueryOptions
        (*DataSource_RedshiftOptions)(nil),     // 7: feast.core.DataSource.RedshiftOptions
        (*DataSource_SnowflakeOptions)(nil),    // 8: feast.core.DataSource.SnowflakeOptions
        (*DataSource_TrinoOptions)(nil),        // 9: feast.core.DataSource.TrinoOptions
        (*DataSource_SparkOptions)(nil),        // 10: feast.core.DataSource.SparkOptions
        (*DataSource_CustomSourceOptions)(nil), // 11: feast.core.DataSource.CustomSourceOptions
        (*DataSource_AthenaOptions)(nil),       // 12: feast.core.DataSource.AthenaOptions
        (*timestamppb.Timestamp)(nil),          // 13: google.protobuf.Timestamp
}
var file_feast_core_SavedDataset_proto_depIdxs = []int32{
        1,  // 0: feast.core.SavedDatasetSpec.storage:type_name -&gt; feast.core.SavedDatasetStorage
        4,  // 1: feast.core.SavedDatasetSpec.tags:type_name -&gt; feast.core.SavedDatasetSpec.TagsEntry
        5,  // 2: feast.core.SavedDatasetStorage.file_storage:type_name -&gt; feast.core.DataSource.FileOptions
        6,  // 3: feast.core.SavedDatasetStorage.bigquery_storage:type_name -&gt; feast.core.DataSource.BigQueryOptions
        7,  // 4: feast.core.SavedDatasetStorage.redshift_storage:type_name -&gt; feast.core.DataSource.RedshiftOptions
        8,  // 5: feast.core.SavedDatasetStorage.snowflake_storage:type_name -&gt; feast.core.DataSource.SnowflakeOptions
        9,  // 6: feast.core.SavedDatasetStorage.trino_storage:type_name -&gt; feast.core.DataSource.TrinoOptions
        10, // 7: feast.core.SavedDatasetStorage.spark_storage:type_name -&gt; feast.core.DataSource.SparkOptions
        11, // 8: feast.core.SavedDatasetStorage.custom_storage:type_name -&gt; feast.core.DataSource.CustomSourceOptions
        12, // 9: feast.core.SavedDatasetStorage.athena_storage:type_name -&gt; feast.core.DataSource.AthenaOptions
        13, // 10: feast.core.SavedDatasetMeta.created_timestamp:type_name -&gt; google.protobuf.Timestamp
        13, // 11: feast.core.SavedDatasetMeta.last_updated_timestamp:type_name -&gt; google.protobuf.Timestamp
        13, // 12: feast.core.SavedDatasetMeta.min_event_timestamp:type_name -&gt; google.protobuf.Timestamp
        13, // 13: feast.core.SavedDatasetMeta.max_event_timestamp:type_name -&gt; google.protobuf.Timestamp
        0,  // 14: feast.core.SavedDataset.spec:type_name -&gt; feast.core.SavedDatasetSpec
        2,  // 15: feast.core.SavedDataset.meta:type_name -&gt; feast.core.SavedDatasetMeta
        16, // [16:16] is the sub-list for method output_type
        16, // [16:16] is the sub-list for method input_type
        16, // [16:16] is the sub-list for extension type_name
        16, // [16:16] is the sub-list for extension extendee
        0,  // [0:16] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_feast_core_SavedDataset_proto_init() }</span>
func file_feast_core_SavedDataset_proto_init() <span class="cov8" title="1">{
        if File_feast_core_SavedDataset_proto != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">file_feast_core_DataSource_proto_init()
        if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_feast_core_SavedDataset_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*SavedDatasetSpec); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_SavedDataset_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*SavedDatasetStorage); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_SavedDataset_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*SavedDatasetMeta); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_SavedDataset_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*SavedDataset); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">file_feast_core_SavedDataset_proto_msgTypes[1].OneofWrappers = []interface{}{
                (*SavedDatasetStorage_FileStorage)(nil),
                (*SavedDatasetStorage_BigqueryStorage)(nil),
                (*SavedDatasetStorage_RedshiftStorage)(nil),
                (*SavedDatasetStorage_SnowflakeStorage)(nil),
                (*SavedDatasetStorage_TrinoStorage)(nil),
                (*SavedDatasetStorage_SparkStorage)(nil),
                (*SavedDatasetStorage_CustomStorage)(nil),
                (*SavedDatasetStorage_AthenaStorage)(nil),
        }
        type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_feast_core_SavedDataset_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   5,
                        NumExtensions: 0,
                        NumServices:   0,
                },
                GoTypes:           file_feast_core_SavedDataset_proto_goTypes,
                DependencyIndexes: file_feast_core_SavedDataset_proto_depIdxs,
                MessageInfos:      file_feast_core_SavedDataset_proto_msgTypes,
        }.Build()
        File_feast_core_SavedDataset_proto = out.File
        file_feast_core_SavedDataset_proto_rawDesc = nil
        file_feast_core_SavedDataset_proto_goTypes = nil
        file_feast_core_SavedDataset_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">//
// Copyright 2020 The Feast Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.31.0
//         protoc        v4.25.1
// source: feast/core/SortedFeatureView.proto

package core

import (
        types "github.com/feast-dev/feast/go/protos/feast/types"
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        durationpb "google.golang.org/protobuf/types/known/durationpb"
        _ "google.golang.org/protobuf/types/known/timestamppb"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type SortOrder_Enum int32

const (
        // Invalid sorting order (default value).
        SortOrder_INVALID SortOrder_Enum = 0
        // Ascending sorting order.
        SortOrder_ASC SortOrder_Enum = 1
        // Descending sorting order.
        SortOrder_DESC SortOrder_Enum = 2
)

// Enum value maps for SortOrder_Enum.
var (
        SortOrder_Enum_name = map[int32]string{
                0: "INVALID",
                1: "ASC",
                2: "DESC",
        }
        SortOrder_Enum_value = map[string]int32{
                "INVALID": 0,
                "ASC":     1,
                "DESC":    2,
        }
)

func (x SortOrder_Enum) Enum() *SortOrder_Enum <span class="cov0" title="0">{
        p := new(SortOrder_Enum)
        *p = x
        return p
}</span>

func (x SortOrder_Enum) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (SortOrder_Enum) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_feast_core_SortedFeatureView_proto_enumTypes[0].Descriptor()
}</span>

func (SortOrder_Enum) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_feast_core_SortedFeatureView_proto_enumTypes[0]
}</span>

func (x SortOrder_Enum) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use SortOrder_Enum.Descriptor instead.
func (SortOrder_Enum) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_SortedFeatureView_proto_rawDescGZIP(), []int{3, 0}
}</span>

// Represents a SortedFeatureView, used for range queries on features
type SortedFeatureView struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // User-specified specifications of the sorted feature view.
        Spec *SortedFeatureViewSpec `protobuf:"bytes,1,opt,name=spec,proto3" json:"spec,omitempty"`
        // System-populated metadata for this feature view.
        Meta *FeatureViewMeta `protobuf:"bytes,2,opt,name=meta,proto3" json:"meta,omitempty"`
}

func (x *SortedFeatureView) Reset() <span class="cov0" title="0">{
        *x = SortedFeatureView{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_SortedFeatureView_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *SortedFeatureView) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SortedFeatureView) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SortedFeatureView) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_SortedFeatureView_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use SortedFeatureView.ProtoReflect.Descriptor instead.
func (*SortedFeatureView) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_SortedFeatureView_proto_rawDescGZIP(), []int{0}
}</span>

func (x *SortedFeatureView) GetSpec() *SortedFeatureViewSpec <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Spec
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SortedFeatureView) GetMeta() *FeatureViewMeta <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Meta
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type SortedFeatureViewSpec struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Name of the feature view. Must be unique. Not updated.
        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        // Name of Feast project that this feature view belongs to.
        Project string `protobuf:"bytes,2,opt,name=project,proto3" json:"project,omitempty"`
        // List of names of entities associated with this feature view.
        Entities []string `protobuf:"bytes,3,rep,name=entities,proto3" json:"entities,omitempty"`
        // List of specifications for each feature defined as part of this feature view.
        Features []*FeatureSpecV2 `protobuf:"bytes,4,rep,name=features,proto3" json:"features,omitempty"`
        // List of specifications for each entity defined as part of this feature view.
        EntityColumns []*FeatureSpecV2 `protobuf:"bytes,12,rep,name=entity_columns,json=entityColumns,proto3" json:"entity_columns,omitempty"`
        // List of sort keys for this feature view.
        SortKeys []*SortKey `protobuf:"bytes,13,rep,name=sort_keys,json=sortKeys,proto3" json:"sort_keys,omitempty"`
        // Description of the feature view.
        Description string `protobuf:"bytes,10,opt,name=description,proto3" json:"description,omitempty"`
        // User defined metadata
        Tags map[string]string `protobuf:"bytes,5,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        // Owner of the feature view.
        Owner string `protobuf:"bytes,11,opt,name=owner,proto3" json:"owner,omitempty"`
        // Features in this feature view can only be retrieved from online serving
        // younger than ttl. Ttl is measured as the duration of time between
        // the feature's event timestamp and when the feature is retrieved
        // Feature values outside ttl will be returned as unset values and indicated to end user
        Ttl *durationpb.Duration `protobuf:"bytes,6,opt,name=ttl,proto3" json:"ttl,omitempty"`
        // Batch/Offline DataSource where this view can retrieve offline feature data.
        BatchSource *DataSource `protobuf:"bytes,7,opt,name=batch_source,json=batchSource,proto3" json:"batch_source,omitempty"`
        // Streaming DataSource from where this view can consume "online" feature data.
        StreamSource *DataSource `protobuf:"bytes,9,opt,name=stream_source,json=streamSource,proto3" json:"stream_source,omitempty"`
        // Whether these features should be served online or not
        Online bool `protobuf:"varint,8,opt,name=online,proto3" json:"online,omitempty"`
        // User-specified specifications of this entity.
        // Adding higher index to avoid conflicts in future
        // if Feast adds more fields
        OriginalEntities []*Entity `protobuf:"bytes,30,rep,name=original_entities,json=originalEntities,proto3" json:"original_entities,omitempty"`
}

func (x *SortedFeatureViewSpec) Reset() <span class="cov0" title="0">{
        *x = SortedFeatureViewSpec{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_SortedFeatureView_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *SortedFeatureViewSpec) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SortedFeatureViewSpec) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SortedFeatureViewSpec) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_feast_core_SortedFeatureView_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SortedFeatureViewSpec.ProtoReflect.Descriptor instead.
func (*SortedFeatureViewSpec) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_SortedFeatureView_proto_rawDescGZIP(), []int{1}
}</span>

func (x *SortedFeatureViewSpec) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SortedFeatureViewSpec) GetProject() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Project
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SortedFeatureViewSpec) GetEntities() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Entities
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SortedFeatureViewSpec) GetFeatures() []*FeatureSpecV2 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Features
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SortedFeatureViewSpec) GetEntityColumns() []*FeatureSpecV2 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.EntityColumns
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SortedFeatureViewSpec) GetSortKeys() []*SortKey <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SortKeys
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SortedFeatureViewSpec) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SortedFeatureViewSpec) GetTags() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tags
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SortedFeatureViewSpec) GetOwner() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Owner
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SortedFeatureViewSpec) GetTtl() *durationpb.Duration <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Ttl
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SortedFeatureViewSpec) GetBatchSource() *DataSource <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.BatchSource
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SortedFeatureViewSpec) GetStreamSource() *DataSource <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.StreamSource
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SortedFeatureViewSpec) GetOnline() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Online
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *SortedFeatureViewSpec) GetOriginalEntities() []*Entity <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OriginalEntities
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Defines the sorting criteria for range-based feature queries.
type SortKey struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Name of the feature used for sorting.
        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        // The value type of the sorting key (e.g., INT64, FLOAT, STRING).
        ValueType types.ValueType_Enum `protobuf:"varint,2,opt,name=value_type,json=valueType,proto3,enum=feast.types.ValueType_Enum" json:"value_type,omitempty"`
        // The default sorting order for this key.
        DefaultSortOrder SortOrder_Enum `protobuf:"varint,3,opt,name=default_sort_order,json=defaultSortOrder,proto3,enum=feast.core.SortOrder_Enum" json:"default_sort_order,omitempty"`
        // Tags for user defined metadata on a feature
        Tags map[string]string `protobuf:"bytes,4,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        // Description of the feature.
        Description string `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
}

func (x *SortKey) Reset() <span class="cov0" title="0">{
        *x = SortKey{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_SortedFeatureView_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *SortKey) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SortKey) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SortKey) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_feast_core_SortedFeatureView_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SortKey.ProtoReflect.Descriptor instead.
func (*SortKey) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_SortedFeatureView_proto_rawDescGZIP(), []int{2}
}</span>

func (x *SortKey) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SortKey) GetValueType() types.ValueType_Enum <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ValueType
        }</span>
        <span class="cov0" title="0">return types.ValueType_Enum(0)</span>
}

func (x *SortKey) GetDefaultSortOrder() SortOrder_Enum <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.DefaultSortOrder
        }</span>
        <span class="cov0" title="0">return SortOrder_INVALID</span>
}

func (x *SortKey) GetTags() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tags
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SortKey) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Specifies the possible sorting orders for a feature view.
type SortOrder struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *SortOrder) Reset() <span class="cov0" title="0">{
        *x = SortOrder{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_SortedFeatureView_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *SortOrder) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SortOrder) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SortOrder) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_feast_core_SortedFeatureView_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SortOrder.ProtoReflect.Descriptor instead.
func (*SortOrder) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_SortedFeatureView_proto_rawDescGZIP(), []int{3}
}</span>

var File_feast_core_SortedFeatureView_proto protoreflect.FileDescriptor

var file_feast_core_SortedFeatureView_proto_rawDesc = []byte{
        0x0a, 0x22, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x53, 0x6f, 0x72,
        0x74, 0x65, 0x64, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0a, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65,
        0x1a, 0x1e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75,
        0x66, 0x2f, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x1a, 0x1f, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75,
        0x66, 0x2f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x1a, 0x1b, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x44, 0x61,
        0x74, 0x61, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x17,
        0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x45, 0x6e, 0x74, 0x69, 0x74,
        0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x18, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63,
        0x6f, 0x72, 0x65, 0x2f, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x1a, 0x1c, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x46, 0x65,
        0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a,
        0x17, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2f, 0x56, 0x61, 0x6c,
        0x75, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x7b, 0x0a, 0x11, 0x53, 0x6f, 0x72, 0x74,
        0x65, 0x64, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77, 0x12, 0x35, 0x0a,
        0x04, 0x73, 0x70, 0x65, 0x63, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x66, 0x65,
        0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x53, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x46,
        0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77, 0x53, 0x70, 0x65, 0x63, 0x52, 0x04,
        0x73, 0x70, 0x65, 0x63, 0x12, 0x2f, 0x0a, 0x04, 0x6d, 0x65, 0x74, 0x61, 0x18, 0x02, 0x20, 0x01,
        0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e,
        0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77, 0x4d, 0x65, 0x74, 0x61, 0x52,
        0x04, 0x6d, 0x65, 0x74, 0x61, 0x22, 0xbc, 0x05, 0x0a, 0x15, 0x53, 0x6f, 0x72, 0x74, 0x65, 0x64,
        0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77, 0x53, 0x70, 0x65, 0x63, 0x12,
        0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e,
        0x61, 0x6d, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x18, 0x02,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x12, 0x1a, 0x0a,
        0x08, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x69, 0x65, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x09, 0x52,
        0x08, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x69, 0x65, 0x73, 0x12, 0x35, 0x0a, 0x08, 0x66, 0x65, 0x61,
        0x74, 0x75, 0x72, 0x65, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x66, 0x65,
        0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65,
        0x53, 0x70, 0x65, 0x63, 0x56, 0x32, 0x52, 0x08, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73,
        0x12, 0x40, 0x0a, 0x0e, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x5f, 0x63, 0x6f, 0x6c, 0x75, 0x6d,
        0x6e, 0x73, 0x18, 0x0c, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74,
        0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x53, 0x70, 0x65,
        0x63, 0x56, 0x32, 0x52, 0x0d, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x43, 0x6f, 0x6c, 0x75, 0x6d,
        0x6e, 0x73, 0x12, 0x30, 0x0a, 0x09, 0x73, 0x6f, 0x72, 0x74, 0x5f, 0x6b, 0x65, 0x79, 0x73, 0x18,
        0x0d, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x13, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f,
        0x72, 0x65, 0x2e, 0x53, 0x6f, 0x72, 0x74, 0x4b, 0x65, 0x79, 0x52, 0x08, 0x73, 0x6f, 0x72, 0x74,
        0x4b, 0x65, 0x79, 0x73, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,
        0x69, 0x6f, 0x6e, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72,
        0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x3f, 0x0a, 0x04, 0x74, 0x61, 0x67, 0x73, 0x18, 0x05,
        0x20, 0x03, 0x28, 0x0b, 0x32, 0x2b, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72,
        0x65, 0x2e, 0x53, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56,
        0x69, 0x65, 0x77, 0x53, 0x70, 0x65, 0x63, 0x2e, 0x54, 0x61, 0x67, 0x73, 0x45, 0x6e, 0x74, 0x72,
        0x79, 0x52, 0x04, 0x74, 0x61, 0x67, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72,
        0x18, 0x0b, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x12, 0x2b, 0x0a,
        0x03, 0x74, 0x74, 0x6c, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67, 0x6f, 0x6f,
        0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x44, 0x75, 0x72,
        0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x03, 0x74, 0x74, 0x6c, 0x12, 0x39, 0x0a, 0x0c, 0x62, 0x61,
        0x74, 0x63, 0x68, 0x5f, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b,
        0x32, 0x16, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x44, 0x61,
        0x74, 0x61, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x52, 0x0b, 0x62, 0x61, 0x74, 0x63, 0x68, 0x53,
        0x6f, 0x75, 0x72, 0x63, 0x65, 0x12, 0x3b, 0x0a, 0x0d, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x5f,
        0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x66,
        0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x53, 0x6f,
        0x75, 0x72, 0x63, 0x65, 0x52, 0x0c, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x53, 0x6f, 0x75, 0x72,
        0x63, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x6f, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x18, 0x08, 0x20, 0x01,
        0x28, 0x08, 0x52, 0x06, 0x6f, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x12, 0x3f, 0x0a, 0x11, 0x6f, 0x72,
        0x69, 0x67, 0x69, 0x6e, 0x61, 0x6c, 0x5f, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x69, 0x65, 0x73, 0x18,
        0x1e, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f,
        0x72, 0x65, 0x2e, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x52, 0x10, 0x6f, 0x72, 0x69, 0x67, 0x69,
        0x6e, 0x61, 0x6c, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x69, 0x65, 0x73, 0x1a, 0x37, 0x0a, 0x09, 0x54,
        0x61, 0x67, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61,
        0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65,
        0x3a, 0x02, 0x38, 0x01, 0x22, 0xb1, 0x02, 0x0a, 0x07, 0x53, 0x6f, 0x72, 0x74, 0x4b, 0x65, 0x79,
        0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04,
        0x6e, 0x61, 0x6d, 0x65, 0x12, 0x3a, 0x0a, 0x0a, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x5f, 0x74, 0x79,
        0x70, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1b, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74,
        0x2e, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x54, 0x79, 0x70, 0x65,
        0x2e, 0x45, 0x6e, 0x75, 0x6d, 0x52, 0x09, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x54, 0x79, 0x70, 0x65,
        0x12, 0x48, 0x0a, 0x12, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c, 0x74, 0x5f, 0x73, 0x6f, 0x72, 0x74,
        0x5f, 0x6f, 0x72, 0x64, 0x65, 0x72, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1a, 0x2e, 0x66,
        0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x53, 0x6f, 0x72, 0x74, 0x4f, 0x72,
        0x64, 0x65, 0x72, 0x2e, 0x45, 0x6e, 0x75, 0x6d, 0x52, 0x10, 0x64, 0x65, 0x66, 0x61, 0x75, 0x6c,
        0x74, 0x53, 0x6f, 0x72, 0x74, 0x4f, 0x72, 0x64, 0x65, 0x72, 0x12, 0x31, 0x0a, 0x04, 0x74, 0x61,
        0x67, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74,
        0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x53, 0x6f, 0x72, 0x74, 0x4b, 0x65, 0x79, 0x2e, 0x54, 0x61,
        0x67, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x04, 0x74, 0x61, 0x67, 0x73, 0x12, 0x20, 0x0a,
        0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x05, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x1a,
        0x37, 0x0a, 0x09, 0x54, 0x61, 0x67, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03,
        0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14,
        0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76,
        0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0x33, 0x0a, 0x09, 0x53, 0x6f, 0x72, 0x74,
        0x4f, 0x72, 0x64, 0x65, 0x72, 0x22, 0x26, 0x0a, 0x04, 0x45, 0x6e, 0x75, 0x6d, 0x12, 0x0b, 0x0a,
        0x07, 0x49, 0x4e, 0x56, 0x41, 0x4c, 0x49, 0x44, 0x10, 0x00, 0x12, 0x07, 0x0a, 0x03, 0x41, 0x53,
        0x43, 0x10, 0x01, 0x12, 0x08, 0x0a, 0x04, 0x44, 0x45, 0x53, 0x43, 0x10, 0x02, 0x42, 0x5b, 0x0a,
        0x10, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x63, 0x6f, 0x72,
        0x65, 0x42, 0x16, 0x53, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65,
        0x56, 0x69, 0x65, 0x77, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x5a, 0x2f, 0x67, 0x69, 0x74, 0x68, 0x75,
        0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2d, 0x64, 0x65, 0x76, 0x2f,
        0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x67, 0x6f, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x73, 0x2f,
        0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x33,
}

var (
        file_feast_core_SortedFeatureView_proto_rawDescOnce sync.Once
        file_feast_core_SortedFeatureView_proto_rawDescData = file_feast_core_SortedFeatureView_proto_rawDesc
)

func file_feast_core_SortedFeatureView_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_feast_core_SortedFeatureView_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_feast_core_SortedFeatureView_proto_rawDescData = protoimpl.X.CompressGZIP(file_feast_core_SortedFeatureView_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_feast_core_SortedFeatureView_proto_rawDescData</span>
}

var file_feast_core_SortedFeatureView_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_feast_core_SortedFeatureView_proto_msgTypes = make([]protoimpl.MessageInfo, 6)
var file_feast_core_SortedFeatureView_proto_goTypes = []interface{}{
        (SortOrder_Enum)(0),           // 0: feast.core.SortOrder.Enum
        (*SortedFeatureView)(nil),     // 1: feast.core.SortedFeatureView
        (*SortedFeatureViewSpec)(nil), // 2: feast.core.SortedFeatureViewSpec
        (*SortKey)(nil),               // 3: feast.core.SortKey
        (*SortOrder)(nil),             // 4: feast.core.SortOrder
        nil,                           // 5: feast.core.SortedFeatureViewSpec.TagsEntry
        nil,                           // 6: feast.core.SortKey.TagsEntry
        (*FeatureViewMeta)(nil),       // 7: feast.core.FeatureViewMeta
        (*FeatureSpecV2)(nil),         // 8: feast.core.FeatureSpecV2
        (*durationpb.Duration)(nil),   // 9: google.protobuf.Duration
        (*DataSource)(nil),            // 10: feast.core.DataSource
        (*Entity)(nil),                // 11: feast.core.Entity
        (types.ValueType_Enum)(0),     // 12: feast.types.ValueType.Enum
}
var file_feast_core_SortedFeatureView_proto_depIdxs = []int32{
        2,  // 0: feast.core.SortedFeatureView.spec:type_name -&gt; feast.core.SortedFeatureViewSpec
        7,  // 1: feast.core.SortedFeatureView.meta:type_name -&gt; feast.core.FeatureViewMeta
        8,  // 2: feast.core.SortedFeatureViewSpec.features:type_name -&gt; feast.core.FeatureSpecV2
        8,  // 3: feast.core.SortedFeatureViewSpec.entity_columns:type_name -&gt; feast.core.FeatureSpecV2
        3,  // 4: feast.core.SortedFeatureViewSpec.sort_keys:type_name -&gt; feast.core.SortKey
        5,  // 5: feast.core.SortedFeatureViewSpec.tags:type_name -&gt; feast.core.SortedFeatureViewSpec.TagsEntry
        9,  // 6: feast.core.SortedFeatureViewSpec.ttl:type_name -&gt; google.protobuf.Duration
        10, // 7: feast.core.SortedFeatureViewSpec.batch_source:type_name -&gt; feast.core.DataSource
        10, // 8: feast.core.SortedFeatureViewSpec.stream_source:type_name -&gt; feast.core.DataSource
        11, // 9: feast.core.SortedFeatureViewSpec.original_entities:type_name -&gt; feast.core.Entity
        12, // 10: feast.core.SortKey.value_type:type_name -&gt; feast.types.ValueType.Enum
        0,  // 11: feast.core.SortKey.default_sort_order:type_name -&gt; feast.core.SortOrder.Enum
        6,  // 12: feast.core.SortKey.tags:type_name -&gt; feast.core.SortKey.TagsEntry
        13, // [13:13] is the sub-list for method output_type
        13, // [13:13] is the sub-list for method input_type
        13, // [13:13] is the sub-list for extension type_name
        13, // [13:13] is the sub-list for extension extendee
        0,  // [0:13] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_feast_core_SortedFeatureView_proto_init() }</span>
func file_feast_core_SortedFeatureView_proto_init() <span class="cov8" title="1">{
        if File_feast_core_SortedFeatureView_proto != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">file_feast_core_DataSource_proto_init()
        file_feast_core_Entity_proto_init()
        file_feast_core_Feature_proto_init()
        file_feast_core_FeatureView_proto_init()
        if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_feast_core_SortedFeatureView_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*SortedFeatureView); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_SortedFeatureView_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*SortedFeatureViewSpec); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_SortedFeatureView_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*SortKey); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_SortedFeatureView_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*SortOrder); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_feast_core_SortedFeatureView_proto_rawDesc,
                        NumEnums:      1,
                        NumMessages:   6,
                        NumExtensions: 0,
                        NumServices:   0,
                },
                GoTypes:           file_feast_core_SortedFeatureView_proto_goTypes,
                DependencyIndexes: file_feast_core_SortedFeatureView_proto_depIdxs,
                EnumInfos:         file_feast_core_SortedFeatureView_proto_enumTypes,
                MessageInfos:      file_feast_core_SortedFeatureView_proto_msgTypes,
        }.Build()
        File_feast_core_SortedFeatureView_proto = out.File
        file_feast_core_SortedFeatureView_proto_rawDesc = nil
        file_feast_core_SortedFeatureView_proto_goTypes = nil
        file_feast_core_SortedFeatureView_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">//
// * Copyright 2021 The Feast Authors
// *
// * Licensed under the Apache License, Version 2.0 (the "License");
// * you may not use this file except in compliance with the License.
// * You may obtain a copy of the License at
// *
// *     https://www.apache.org/licenses/LICENSE-2.0
// *
// * Unless required by applicable law or agreed to in writing, software
// * distributed under the License is distributed on an "AS IS" BASIS,
// * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// * See the License for the specific language governing permissions and
// * limitations under the License.
//

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.31.0
//         protoc        v4.25.1
// source: feast/core/SqliteTable.proto

package core

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Represents a Sqlite table
type SqliteTable struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Absolute path of the table
        Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
        // Name of the table
        Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (x *SqliteTable) Reset() <span class="cov0" title="0">{
        *x = SqliteTable{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_SqliteTable_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *SqliteTable) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SqliteTable) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SqliteTable) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_SqliteTable_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use SqliteTable.ProtoReflect.Descriptor instead.
func (*SqliteTable) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_SqliteTable_proto_rawDescGZIP(), []int{0}
}</span>

func (x *SqliteTable) GetPath() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Path
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *SqliteTable) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

var File_feast_core_SqliteTable_proto protoreflect.FileDescriptor

var file_feast_core_SqliteTable_proto_rawDesc = []byte{
        0x0a, 0x1c, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x53, 0x71, 0x6c,
        0x69, 0x74, 0x65, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0a,
        0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x22, 0x35, 0x0a, 0x0b, 0x53, 0x71,
        0x6c, 0x69, 0x74, 0x65, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x70, 0x61, 0x74,
        0x68, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x70, 0x61, 0x74, 0x68, 0x12, 0x12, 0x0a,
        0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d,
        0x65, 0x42, 0x55, 0x0a, 0x10, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x2e, 0x63, 0x6f, 0x72, 0x65, 0x42, 0x10, 0x53, 0x71, 0x6c, 0x69, 0x74, 0x65, 0x54, 0x61, 0x62,
        0x6c, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x5a, 0x2f, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e,
        0x63, 0x6f, 0x6d, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2d, 0x64, 0x65, 0x76, 0x2f, 0x66, 0x65,
        0x61, 0x73, 0x74, 0x2f, 0x67, 0x6f, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x73, 0x2f, 0x66, 0x65,
        0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_feast_core_SqliteTable_proto_rawDescOnce sync.Once
        file_feast_core_SqliteTable_proto_rawDescData = file_feast_core_SqliteTable_proto_rawDesc
)

func file_feast_core_SqliteTable_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_feast_core_SqliteTable_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_feast_core_SqliteTable_proto_rawDescData = protoimpl.X.CompressGZIP(file_feast_core_SqliteTable_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_feast_core_SqliteTable_proto_rawDescData</span>
}

var file_feast_core_SqliteTable_proto_msgTypes = make([]protoimpl.MessageInfo, 1)
var file_feast_core_SqliteTable_proto_goTypes = []interface{}{
        (*SqliteTable)(nil), // 0: feast.core.SqliteTable
}
var file_feast_core_SqliteTable_proto_depIdxs = []int32{
        0, // [0:0] is the sub-list for method output_type
        0, // [0:0] is the sub-list for method input_type
        0, // [0:0] is the sub-list for extension type_name
        0, // [0:0] is the sub-list for extension extendee
        0, // [0:0] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_feast_core_SqliteTable_proto_init() }</span>
func file_feast_core_SqliteTable_proto_init() <span class="cov8" title="1">{
        if File_feast_core_SqliteTable_proto != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_feast_core_SqliteTable_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*SqliteTable); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_feast_core_SqliteTable_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   1,
                        NumExtensions: 0,
                        NumServices:   0,
                },
                GoTypes:           file_feast_core_SqliteTable_proto_goTypes,
                DependencyIndexes: file_feast_core_SqliteTable_proto_depIdxs,
                MessageInfos:      file_feast_core_SqliteTable_proto_msgTypes,
        }.Build()
        File_feast_core_SqliteTable_proto = out.File
        file_feast_core_SqliteTable_proto_rawDesc = nil
        file_feast_core_SqliteTable_proto_goTypes = nil
        file_feast_core_SqliteTable_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">//
// * Copyright 2019 The Feast Authors
// *
// * Licensed under the Apache License, Version 2.0 (the "License");
// * you may not use this file except in compliance with the License.
// * You may obtain a copy of the License at
// *
// *     https://www.apache.org/licenses/LICENSE-2.0
// *
// * Unless required by applicable law or agreed to in writing, software
// * distributed under the License is distributed on an "AS IS" BASIS,
// * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// * See the License for the specific language governing permissions and
// * limitations under the License.
//

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.31.0
//         protoc        v4.25.1
// source: feast/core/Store.proto

package core

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Store_StoreType int32

const (
        Store_INVALID Store_StoreType = 0
        // Redis stores a FeatureRow element as a key, value pair.
        //
        // The Redis data types used (https://redis.io/topics/data-types):
        // - key: STRING
        // - value: STRING
        //
        // Encodings:
        // - key: byte array of RedisKey (refer to feast.storage.RedisKeyV2)
        // - value: Redis hashmap
        Store_REDIS         Store_StoreType = 1
        Store_REDIS_CLUSTER Store_StoreType = 4
)

// Enum value maps for Store_StoreType.
var (
        Store_StoreType_name = map[int32]string{
                0: "INVALID",
                1: "REDIS",
                4: "REDIS_CLUSTER",
        }
        Store_StoreType_value = map[string]int32{
                "INVALID":       0,
                "REDIS":         1,
                "REDIS_CLUSTER": 4,
        }
)

func (x Store_StoreType) Enum() *Store_StoreType <span class="cov0" title="0">{
        p := new(Store_StoreType)
        *p = x
        return p
}</span>

func (x Store_StoreType) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (Store_StoreType) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_feast_core_Store_proto_enumTypes[0].Descriptor()
}</span>

func (Store_StoreType) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_feast_core_Store_proto_enumTypes[0]
}</span>

func (x Store_StoreType) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use Store_StoreType.Descriptor instead.
func (Store_StoreType) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_Store_proto_rawDescGZIP(), []int{0, 0}
}</span>

// Optional. Priority of nodes when reading from cluster
type Store_RedisClusterConfig_ReadFrom int32

const (
        Store_RedisClusterConfig_MASTER            Store_RedisClusterConfig_ReadFrom = 0
        Store_RedisClusterConfig_MASTER_PREFERRED  Store_RedisClusterConfig_ReadFrom = 1
        Store_RedisClusterConfig_REPLICA           Store_RedisClusterConfig_ReadFrom = 2
        Store_RedisClusterConfig_REPLICA_PREFERRED Store_RedisClusterConfig_ReadFrom = 3
)

// Enum value maps for Store_RedisClusterConfig_ReadFrom.
var (
        Store_RedisClusterConfig_ReadFrom_name = map[int32]string{
                0: "MASTER",
                1: "MASTER_PREFERRED",
                2: "REPLICA",
                3: "REPLICA_PREFERRED",
        }
        Store_RedisClusterConfig_ReadFrom_value = map[string]int32{
                "MASTER":            0,
                "MASTER_PREFERRED":  1,
                "REPLICA":           2,
                "REPLICA_PREFERRED": 3,
        }
)

func (x Store_RedisClusterConfig_ReadFrom) Enum() *Store_RedisClusterConfig_ReadFrom <span class="cov0" title="0">{
        p := new(Store_RedisClusterConfig_ReadFrom)
        *p = x
        return p
}</span>

func (x Store_RedisClusterConfig_ReadFrom) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (Store_RedisClusterConfig_ReadFrom) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_feast_core_Store_proto_enumTypes[1].Descriptor()
}</span>

func (Store_RedisClusterConfig_ReadFrom) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_feast_core_Store_proto_enumTypes[1]
}</span>

func (x Store_RedisClusterConfig_ReadFrom) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use Store_RedisClusterConfig_ReadFrom.Descriptor instead.
func (Store_RedisClusterConfig_ReadFrom) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_Store_proto_rawDescGZIP(), []int{0, 1, 0}
}</span>

// Store provides a location where Feast reads and writes feature values.
// Feature values will be written to the Store in the form of FeatureRow elements.
// The way FeatureRow is encoded and decoded when it is written to and read from
// the Store depends on the type of the Store.
type Store struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Name of the store.
        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        // Type of store.
        Type Store_StoreType `protobuf:"varint,2,opt,name=type,proto3,enum=feast.core.Store_StoreType" json:"type,omitempty"`
        // Feature sets to subscribe to.
        Subscriptions []*Store_Subscription `protobuf:"bytes,4,rep,name=subscriptions,proto3" json:"subscriptions,omitempty"`
        // Configuration to connect to the store. Required.
        //
        // Types that are assignable to Config:
        //
        //        *Store_RedisConfig_
        //        *Store_RedisClusterConfig_
        Config isStore_Config `protobuf_oneof:"config"`
}

func (x *Store) Reset() <span class="cov0" title="0">{
        *x = Store{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_Store_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Store) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Store) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Store) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_feast_core_Store_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Store.ProtoReflect.Descriptor instead.
func (*Store) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_Store_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Store) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Store) GetType() Store_StoreType <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return Store_INVALID</span>
}

func (x *Store) GetSubscriptions() []*Store_Subscription <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Subscriptions
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *Store) GetConfig() isStore_Config <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Config
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Store) GetRedisConfig() *Store_RedisConfig <span class="cov0" title="0">{
        if x, ok := x.GetConfig().(*Store_RedisConfig_); ok </span><span class="cov0" title="0">{
                return x.RedisConfig
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Store) GetRedisClusterConfig() *Store_RedisClusterConfig <span class="cov0" title="0">{
        if x, ok := x.GetConfig().(*Store_RedisClusterConfig_); ok </span><span class="cov0" title="0">{
                return x.RedisClusterConfig
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type isStore_Config interface {
        isStore_Config()
}

type Store_RedisConfig_ struct {
        RedisConfig *Store_RedisConfig `protobuf:"bytes,11,opt,name=redis_config,json=redisConfig,proto3,oneof"`
}

type Store_RedisClusterConfig_ struct {
        RedisClusterConfig *Store_RedisClusterConfig `protobuf:"bytes,14,opt,name=redis_cluster_config,json=redisClusterConfig,proto3,oneof"`
}

func (*Store_RedisConfig_) isStore_Config() {<span class="cov0" title="0">}</span>

func (*Store_RedisClusterConfig_) isStore_Config() {<span class="cov0" title="0">}</span>

type Store_RedisConfig struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Host string `protobuf:"bytes,1,opt,name=host,proto3" json:"host,omitempty"`
        Port int32  `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
        // Optional. The number of milliseconds to wait before retrying failed Redis connection.
        // By default, Feast uses exponential backoff policy and "initial_backoff_ms" sets the initial wait duration.
        InitialBackoffMs int32 `protobuf:"varint,3,opt,name=initial_backoff_ms,json=initialBackoffMs,proto3" json:"initial_backoff_ms,omitempty"`
        // Optional. Maximum total number of retries for connecting to Redis. Default to zero retries.
        MaxRetries int32 `protobuf:"varint,4,opt,name=max_retries,json=maxRetries,proto3" json:"max_retries,omitempty"`
        // Optional. How often flush data to redis
        FlushFrequencySeconds int32 `protobuf:"varint,5,opt,name=flush_frequency_seconds,json=flushFrequencySeconds,proto3" json:"flush_frequency_seconds,omitempty"`
        // Optional. Connect over SSL.
        Ssl bool `protobuf:"varint,6,opt,name=ssl,proto3" json:"ssl,omitempty"`
}

func (x *Store_RedisConfig) Reset() <span class="cov0" title="0">{
        *x = Store_RedisConfig{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_Store_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Store_RedisConfig) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Store_RedisConfig) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Store_RedisConfig) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_feast_core_Store_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Store_RedisConfig.ProtoReflect.Descriptor instead.
func (*Store_RedisConfig) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_Store_proto_rawDescGZIP(), []int{0, 0}
}</span>

func (x *Store_RedisConfig) GetHost() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Host
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Store_RedisConfig) GetPort() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Port
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Store_RedisConfig) GetInitialBackoffMs() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.InitialBackoffMs
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Store_RedisConfig) GetMaxRetries() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MaxRetries
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Store_RedisConfig) GetFlushFrequencySeconds() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FlushFrequencySeconds
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Store_RedisConfig) GetSsl() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Ssl
        }</span>
        <span class="cov0" title="0">return false</span>
}

type Store_RedisClusterConfig struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // List of Redis Uri for all the nodes in Redis Cluster, comma separated. Eg. host1:6379, host2:6379
        ConnectionString string `protobuf:"bytes,1,opt,name=connection_string,json=connectionString,proto3" json:"connection_string,omitempty"`
        InitialBackoffMs int32  `protobuf:"varint,2,opt,name=initial_backoff_ms,json=initialBackoffMs,proto3" json:"initial_backoff_ms,omitempty"`
        MaxRetries       int32  `protobuf:"varint,3,opt,name=max_retries,json=maxRetries,proto3" json:"max_retries,omitempty"`
        // Optional. How often flush data to redis
        FlushFrequencySeconds int32 `protobuf:"varint,4,opt,name=flush_frequency_seconds,json=flushFrequencySeconds,proto3" json:"flush_frequency_seconds,omitempty"`
        // Optional. Append a prefix to the Redis Key
        KeyPrefix string `protobuf:"bytes,5,opt,name=key_prefix,json=keyPrefix,proto3" json:"key_prefix,omitempty"`
        // Optional. Enable fallback to another key prefix if the original key is not present.
        // Useful for migrating key prefix without re-ingestion. Disabled by default.
        EnableFallback bool `protobuf:"varint,6,opt,name=enable_fallback,json=enableFallback,proto3" json:"enable_fallback,omitempty"`
        // Optional. This would be the fallback prefix to use if enable_fallback is true.
        FallbackPrefix string                            `protobuf:"bytes,7,opt,name=fallback_prefix,json=fallbackPrefix,proto3" json:"fallback_prefix,omitempty"`
        ReadFrom       Store_RedisClusterConfig_ReadFrom `protobuf:"varint,8,opt,name=read_from,json=readFrom,proto3,enum=feast.core.Store_RedisClusterConfig_ReadFrom" json:"read_from,omitempty"`
}

func (x *Store_RedisClusterConfig) Reset() <span class="cov0" title="0">{
        *x = Store_RedisClusterConfig{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_Store_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Store_RedisClusterConfig) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Store_RedisClusterConfig) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Store_RedisClusterConfig) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_feast_core_Store_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Store_RedisClusterConfig.ProtoReflect.Descriptor instead.
func (*Store_RedisClusterConfig) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_Store_proto_rawDescGZIP(), []int{0, 1}
}</span>

func (x *Store_RedisClusterConfig) GetConnectionString() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ConnectionString
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Store_RedisClusterConfig) GetInitialBackoffMs() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.InitialBackoffMs
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Store_RedisClusterConfig) GetMaxRetries() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.MaxRetries
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Store_RedisClusterConfig) GetFlushFrequencySeconds() int32 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FlushFrequencySeconds
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Store_RedisClusterConfig) GetKeyPrefix() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.KeyPrefix
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Store_RedisClusterConfig) GetEnableFallback() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.EnableFallback
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *Store_RedisClusterConfig) GetFallbackPrefix() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FallbackPrefix
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Store_RedisClusterConfig) GetReadFrom() Store_RedisClusterConfig_ReadFrom <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ReadFrom
        }</span>
        <span class="cov0" title="0">return Store_RedisClusterConfig_MASTER</span>
}

type Store_Subscription struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Name of project that the feature sets belongs to. This can be one of
        // - [project_name]
        // - *
        // If an asterisk is provided, filtering on projects will be disabled. All projects will
        // be matched. It is NOT possible to provide an asterisk with a string in order to do
        // pattern matching.
        Project string `protobuf:"bytes,3,opt,name=project,proto3" json:"project,omitempty"`
        // Name of the desired feature set. Asterisks can be used as wildcards in the name.
        // Matching on names is only permitted if a specific project is defined. It is disallowed
        // If the project name is set to "*"
        // e.g.
        // - * can be used to match all feature sets
        // - my-feature-set* can be used to match all features prefixed by "my-feature-set"
        // - my-feature-set-6 can be used to select a single feature set
        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        // All matches with exclude enabled will be filtered out instead of added
        Exclude bool `protobuf:"varint,4,opt,name=exclude,proto3" json:"exclude,omitempty"`
}

func (x *Store_Subscription) Reset() <span class="cov0" title="0">{
        *x = Store_Subscription{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_Store_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Store_Subscription) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Store_Subscription) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Store_Subscription) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_feast_core_Store_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Store_Subscription.ProtoReflect.Descriptor instead.
func (*Store_Subscription) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_Store_proto_rawDescGZIP(), []int{0, 2}
}</span>

func (x *Store_Subscription) GetProject() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Project
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Store_Subscription) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Store_Subscription) GetExclude() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Exclude
        }</span>
        <span class="cov0" title="0">return false</span>
}

var File_feast_core_Store_proto protoreflect.FileDescriptor

var file_feast_core_Store_proto_rawDesc = []byte{
        0x0a, 0x16, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x53, 0x74, 0x6f,
        0x72, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0a, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e,
        0x63, 0x6f, 0x72, 0x65, 0x22, 0x93, 0x09, 0x0a, 0x05, 0x53, 0x74, 0x6f, 0x72, 0x65, 0x12, 0x12,
        0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61,
        0x6d, 0x65, 0x12, 0x2f, 0x0a, 0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e,
        0x32, 0x1b, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x53, 0x74,
        0x6f, 0x72, 0x65, 0x2e, 0x53, 0x74, 0x6f, 0x72, 0x65, 0x54, 0x79, 0x70, 0x65, 0x52, 0x04, 0x74,
        0x79, 0x70, 0x65, 0x12, 0x44, 0x0a, 0x0d, 0x73, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,
        0x69, 0x6f, 0x6e, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1e, 0x2e, 0x66, 0x65, 0x61,
        0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x53, 0x74, 0x6f, 0x72, 0x65, 0x2e, 0x53, 0x75,
        0x62, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0d, 0x73, 0x75, 0x62, 0x73,
        0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x42, 0x0a, 0x0c, 0x72, 0x65, 0x64,
        0x69, 0x73, 0x5f, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0b, 0x32,
        0x1d, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x53, 0x74, 0x6f,
        0x72, 0x65, 0x2e, 0x52, 0x65, 0x64, 0x69, 0x73, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x48, 0x00,
        0x52, 0x0b, 0x72, 0x65, 0x64, 0x69, 0x73, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x58, 0x0a,
        0x14, 0x72, 0x65, 0x64, 0x69, 0x73, 0x5f, 0x63, 0x6c, 0x75, 0x73, 0x74, 0x65, 0x72, 0x5f, 0x63,
        0x6f, 0x6e, 0x66, 0x69, 0x67, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x66, 0x65,
        0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x53, 0x74, 0x6f, 0x72, 0x65, 0x2e, 0x52,
        0x65, 0x64, 0x69, 0x73, 0x43, 0x6c, 0x75, 0x73, 0x74, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69,
        0x67, 0x48, 0x00, 0x52, 0x12, 0x72, 0x65, 0x64, 0x69, 0x73, 0x43, 0x6c, 0x75, 0x73, 0x74, 0x65,
        0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x1a, 0xce, 0x01, 0x0a, 0x0b, 0x52, 0x65, 0x64, 0x69,
        0x73, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12, 0x12, 0x0a, 0x04, 0x68, 0x6f, 0x73, 0x74, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x68, 0x6f, 0x73, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x70,
        0x6f, 0x72, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x04, 0x70, 0x6f, 0x72, 0x74, 0x12,
        0x2c, 0x0a, 0x12, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x6c, 0x5f, 0x62, 0x61, 0x63, 0x6b, 0x6f,
        0x66, 0x66, 0x5f, 0x6d, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52, 0x10, 0x69, 0x6e, 0x69,
        0x74, 0x69, 0x61, 0x6c, 0x42, 0x61, 0x63, 0x6b, 0x6f, 0x66, 0x66, 0x4d, 0x73, 0x12, 0x1f, 0x0a,
        0x0b, 0x6d, 0x61, 0x78, 0x5f, 0x72, 0x65, 0x74, 0x72, 0x69, 0x65, 0x73, 0x18, 0x04, 0x20, 0x01,
        0x28, 0x05, 0x52, 0x0a, 0x6d, 0x61, 0x78, 0x52, 0x65, 0x74, 0x72, 0x69, 0x65, 0x73, 0x12, 0x36,
        0x0a, 0x17, 0x66, 0x6c, 0x75, 0x73, 0x68, 0x5f, 0x66, 0x72, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x63,
        0x79, 0x5f, 0x73, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x05, 0x52,
        0x15, 0x66, 0x6c, 0x75, 0x73, 0x68, 0x46, 0x72, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x79, 0x53,
        0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x12, 0x10, 0x0a, 0x03, 0x73, 0x73, 0x6c, 0x18, 0x06, 0x20,
        0x01, 0x28, 0x08, 0x52, 0x03, 0x73, 0x73, 0x6c, 0x1a, 0xd7, 0x03, 0x0a, 0x12, 0x52, 0x65, 0x64,
        0x69, 0x73, 0x43, 0x6c, 0x75, 0x73, 0x74, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x12,
        0x2b, 0x0a, 0x11, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x73, 0x74,
        0x72, 0x69, 0x6e, 0x67, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x10, 0x63, 0x6f, 0x6e, 0x6e,
        0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x12, 0x2c, 0x0a, 0x12,
        0x69, 0x6e, 0x69, 0x74, 0x69, 0x61, 0x6c, 0x5f, 0x62, 0x61, 0x63, 0x6b, 0x6f, 0x66, 0x66, 0x5f,
        0x6d, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x10, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x61,
        0x6c, 0x42, 0x61, 0x63, 0x6b, 0x6f, 0x66, 0x66, 0x4d, 0x73, 0x12, 0x1f, 0x0a, 0x0b, 0x6d, 0x61,
        0x78, 0x5f, 0x72, 0x65, 0x74, 0x72, 0x69, 0x65, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52,
        0x0a, 0x6d, 0x61, 0x78, 0x52, 0x65, 0x74, 0x72, 0x69, 0x65, 0x73, 0x12, 0x36, 0x0a, 0x17, 0x66,
        0x6c, 0x75, 0x73, 0x68, 0x5f, 0x66, 0x72, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x79, 0x5f, 0x73,
        0x65, 0x63, 0x6f, 0x6e, 0x64, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x05, 0x52, 0x15, 0x66, 0x6c,
        0x75, 0x73, 0x68, 0x46, 0x72, 0x65, 0x71, 0x75, 0x65, 0x6e, 0x63, 0x79, 0x53, 0x65, 0x63, 0x6f,
        0x6e, 0x64, 0x73, 0x12, 0x1d, 0x0a, 0x0a, 0x6b, 0x65, 0x79, 0x5f, 0x70, 0x72, 0x65, 0x66, 0x69,
        0x78, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x6b, 0x65, 0x79, 0x50, 0x72, 0x65, 0x66,
        0x69, 0x78, 0x12, 0x27, 0x0a, 0x0f, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x66, 0x61, 0x6c,
        0x6c, 0x62, 0x61, 0x63, 0x6b, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0e, 0x65, 0x6e, 0x61,
        0x62, 0x6c, 0x65, 0x46, 0x61, 0x6c, 0x6c, 0x62, 0x61, 0x63, 0x6b, 0x12, 0x27, 0x0a, 0x0f, 0x66,
        0x61, 0x6c, 0x6c, 0x62, 0x61, 0x63, 0x6b, 0x5f, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x18, 0x07,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x66, 0x61, 0x6c, 0x6c, 0x62, 0x61, 0x63, 0x6b, 0x50, 0x72,
        0x65, 0x66, 0x69, 0x78, 0x12, 0x4a, 0x0a, 0x09, 0x72, 0x65, 0x61, 0x64, 0x5f, 0x66, 0x72, 0x6f,
        0x6d, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x2d, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e,
        0x63, 0x6f, 0x72, 0x65, 0x2e, 0x53, 0x74, 0x6f, 0x72, 0x65, 0x2e, 0x52, 0x65, 0x64, 0x69, 0x73,
        0x43, 0x6c, 0x75, 0x73, 0x74, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x2e, 0x52, 0x65,
        0x61, 0x64, 0x46, 0x72, 0x6f, 0x6d, 0x52, 0x08, 0x72, 0x65, 0x61, 0x64, 0x46, 0x72, 0x6f, 0x6d,
        0x22, 0x50, 0x0a, 0x08, 0x52, 0x65, 0x61, 0x64, 0x46, 0x72, 0x6f, 0x6d, 0x12, 0x0a, 0x0a, 0x06,
        0x4d, 0x41, 0x53, 0x54, 0x45, 0x52, 0x10, 0x00, 0x12, 0x14, 0x0a, 0x10, 0x4d, 0x41, 0x53, 0x54,
        0x45, 0x52, 0x5f, 0x50, 0x52, 0x45, 0x46, 0x45, 0x52, 0x52, 0x45, 0x44, 0x10, 0x01, 0x12, 0x0b,
        0x0a, 0x07, 0x52, 0x45, 0x50, 0x4c, 0x49, 0x43, 0x41, 0x10, 0x02, 0x12, 0x15, 0x0a, 0x11, 0x52,
        0x45, 0x50, 0x4c, 0x49, 0x43, 0x41, 0x5f, 0x50, 0x52, 0x45, 0x46, 0x45, 0x52, 0x52, 0x45, 0x44,
        0x10, 0x03, 0x1a, 0x5c, 0x0a, 0x0c, 0x53, 0x75, 0x62, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69,
        0x6f, 0x6e, 0x12, 0x18, 0x0a, 0x07, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x18, 0x03, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x07, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x12, 0x12, 0x0a, 0x04,
        0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65,
        0x12, 0x18, 0x0a, 0x07, 0x65, 0x78, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28,
        0x08, 0x52, 0x07, 0x65, 0x78, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x4a, 0x04, 0x08, 0x02, 0x10, 0x03,
        0x22, 0x4e, 0x0a, 0x09, 0x53, 0x74, 0x6f, 0x72, 0x65, 0x54, 0x79, 0x70, 0x65, 0x12, 0x0b, 0x0a,
        0x07, 0x49, 0x4e, 0x56, 0x41, 0x4c, 0x49, 0x44, 0x10, 0x00, 0x12, 0x09, 0x0a, 0x05, 0x52, 0x45,
        0x44, 0x49, 0x53, 0x10, 0x01, 0x12, 0x11, 0x0a, 0x0d, 0x52, 0x45, 0x44, 0x49, 0x53, 0x5f, 0x43,
        0x4c, 0x55, 0x53, 0x54, 0x45, 0x52, 0x10, 0x04, 0x22, 0x04, 0x08, 0x02, 0x10, 0x02, 0x22, 0x04,
        0x08, 0x03, 0x10, 0x03, 0x22, 0x04, 0x08, 0x0c, 0x10, 0x0c, 0x22, 0x04, 0x08, 0x0d, 0x10, 0x0d,
        0x42, 0x08, 0x0a, 0x06, 0x63, 0x6f, 0x6e, 0x66, 0x69, 0x67, 0x42, 0x4f, 0x0a, 0x10, 0x66, 0x65,
        0x61, 0x73, 0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x42, 0x0a,
        0x53, 0x74, 0x6f, 0x72, 0x65, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x5a, 0x2f, 0x67, 0x69, 0x74, 0x68,
        0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2d, 0x64, 0x65, 0x76,
        0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x67, 0x6f, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x73,
        0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x62, 0x06, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x33,
}

var (
        file_feast_core_Store_proto_rawDescOnce sync.Once
        file_feast_core_Store_proto_rawDescData = file_feast_core_Store_proto_rawDesc
)

func file_feast_core_Store_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_feast_core_Store_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_feast_core_Store_proto_rawDescData = protoimpl.X.CompressGZIP(file_feast_core_Store_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_feast_core_Store_proto_rawDescData</span>
}

var file_feast_core_Store_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_feast_core_Store_proto_msgTypes = make([]protoimpl.MessageInfo, 4)
var file_feast_core_Store_proto_goTypes = []interface{}{
        (Store_StoreType)(0),                   // 0: feast.core.Store.StoreType
        (Store_RedisClusterConfig_ReadFrom)(0), // 1: feast.core.Store.RedisClusterConfig.ReadFrom
        (*Store)(nil),                          // 2: feast.core.Store
        (*Store_RedisConfig)(nil),              // 3: feast.core.Store.RedisConfig
        (*Store_RedisClusterConfig)(nil),       // 4: feast.core.Store.RedisClusterConfig
        (*Store_Subscription)(nil),             // 5: feast.core.Store.Subscription
}
var file_feast_core_Store_proto_depIdxs = []int32{
        0, // 0: feast.core.Store.type:type_name -&gt; feast.core.Store.StoreType
        5, // 1: feast.core.Store.subscriptions:type_name -&gt; feast.core.Store.Subscription
        3, // 2: feast.core.Store.redis_config:type_name -&gt; feast.core.Store.RedisConfig
        4, // 3: feast.core.Store.redis_cluster_config:type_name -&gt; feast.core.Store.RedisClusterConfig
        1, // 4: feast.core.Store.RedisClusterConfig.read_from:type_name -&gt; feast.core.Store.RedisClusterConfig.ReadFrom
        5, // [5:5] is the sub-list for method output_type
        5, // [5:5] is the sub-list for method input_type
        5, // [5:5] is the sub-list for extension type_name
        5, // [5:5] is the sub-list for extension extendee
        0, // [0:5] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_feast_core_Store_proto_init() }</span>
func file_feast_core_Store_proto_init() <span class="cov8" title="1">{
        if File_feast_core_Store_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_feast_core_Store_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Store); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_Store_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Store_RedisConfig); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_Store_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Store_RedisClusterConfig); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_Store_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Store_Subscription); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">file_feast_core_Store_proto_msgTypes[0].OneofWrappers = []interface{}{
                (*Store_RedisConfig_)(nil),
                (*Store_RedisClusterConfig_)(nil),
        }
        type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_feast_core_Store_proto_rawDesc,
                        NumEnums:      2,
                        NumMessages:   4,
                        NumExtensions: 0,
                        NumServices:   0,
                },
                GoTypes:           file_feast_core_Store_proto_goTypes,
                DependencyIndexes: file_feast_core_Store_proto_depIdxs,
                EnumInfos:         file_feast_core_Store_proto_enumTypes,
                MessageInfos:      file_feast_core_Store_proto_msgTypes,
        }.Build()
        File_feast_core_Store_proto = out.File
        file_feast_core_Store_proto_rawDesc = nil
        file_feast_core_Store_proto_goTypes = nil
        file_feast_core_Store_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">//
// Copyright 2020 The Feast Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.31.0
//         protoc        v4.25.1
// source: feast/core/StreamFeatureView.proto

package core

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        durationpb "google.golang.org/protobuf/types/known/durationpb"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type StreamFeatureView struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // User-specified specifications of this feature view.
        Spec *StreamFeatureViewSpec `protobuf:"bytes,1,opt,name=spec,proto3" json:"spec,omitempty"`
        Meta *FeatureViewMeta       `protobuf:"bytes,2,opt,name=meta,proto3" json:"meta,omitempty"`
}

func (x *StreamFeatureView) Reset() <span class="cov0" title="0">{
        *x = StreamFeatureView{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_StreamFeatureView_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *StreamFeatureView) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StreamFeatureView) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StreamFeatureView) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_StreamFeatureView_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use StreamFeatureView.ProtoReflect.Descriptor instead.
func (*StreamFeatureView) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_StreamFeatureView_proto_rawDescGZIP(), []int{0}
}</span>

func (x *StreamFeatureView) GetSpec() *StreamFeatureViewSpec <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Spec
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *StreamFeatureView) GetMeta() *FeatureViewMeta <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Meta
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Next available id: 17
type StreamFeatureViewSpec struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Name of the feature view. Must be unique. Not updated.
        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        // Name of Feast project that this feature view belongs to.
        Project string `protobuf:"bytes,2,opt,name=project,proto3" json:"project,omitempty"`
        // List of names of entities associated with this feature view.
        Entities []string `protobuf:"bytes,3,rep,name=entities,proto3" json:"entities,omitempty"`
        // List of specifications for each feature defined as part of this feature view.
        Features []*FeatureSpecV2 `protobuf:"bytes,4,rep,name=features,proto3" json:"features,omitempty"`
        // List of specifications for each entity defined as part of this feature view.
        EntityColumns []*FeatureSpecV2 `protobuf:"bytes,5,rep,name=entity_columns,json=entityColumns,proto3" json:"entity_columns,omitempty"`
        // Description of the feature view.
        Description string `protobuf:"bytes,6,opt,name=description,proto3" json:"description,omitempty"`
        // User defined metadata
        Tags map[string]string `protobuf:"bytes,7,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        // Owner of the feature view.
        Owner string `protobuf:"bytes,8,opt,name=owner,proto3" json:"owner,omitempty"`
        // Features in this feature view can only be retrieved from online serving
        // younger than ttl. Ttl is measured as the duration of time between
        // the feature's event timestamp and when the feature is retrieved
        // Feature values outside ttl will be returned as unset values and indicated to end user
        Ttl *durationpb.Duration `protobuf:"bytes,9,opt,name=ttl,proto3" json:"ttl,omitempty"`
        // Batch/Offline DataSource where this view can retrieve offline feature data.
        BatchSource *DataSource `protobuf:"bytes,10,opt,name=batch_source,json=batchSource,proto3" json:"batch_source,omitempty"`
        // Streaming DataSource from where this view can consume "online" feature data.
        StreamSource *DataSource `protobuf:"bytes,11,opt,name=stream_source,json=streamSource,proto3" json:"stream_source,omitempty"`
        // Whether these features should be served online or not
        Online bool `protobuf:"varint,12,opt,name=online,proto3" json:"online,omitempty"`
        // Serialized function that is encoded in the streamfeatureview
        //
        // Deprecated: Marked as deprecated in feast/core/StreamFeatureView.proto.
        UserDefinedFunction *UserDefinedFunction `protobuf:"bytes,13,opt,name=user_defined_function,json=userDefinedFunction,proto3" json:"user_defined_function,omitempty"`
        // Mode of execution
        Mode string `protobuf:"bytes,14,opt,name=mode,proto3" json:"mode,omitempty"`
        // Aggregation definitions
        Aggregations []*Aggregation `protobuf:"bytes,15,rep,name=aggregations,proto3" json:"aggregations,omitempty"`
        // Timestamp field for aggregation
        TimestampField string `protobuf:"bytes,16,opt,name=timestamp_field,json=timestampField,proto3" json:"timestamp_field,omitempty"`
        // Oneof with {user_defined_function, on_demand_substrait_transformation}
        FeatureTransformation *FeatureTransformationV2 `protobuf:"bytes,17,opt,name=feature_transformation,json=featureTransformation,proto3" json:"feature_transformation,omitempty"`
}

func (x *StreamFeatureViewSpec) Reset() <span class="cov0" title="0">{
        *x = StreamFeatureViewSpec{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_StreamFeatureView_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *StreamFeatureViewSpec) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StreamFeatureViewSpec) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StreamFeatureViewSpec) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_feast_core_StreamFeatureView_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use StreamFeatureViewSpec.ProtoReflect.Descriptor instead.
func (*StreamFeatureViewSpec) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_StreamFeatureView_proto_rawDescGZIP(), []int{1}
}</span>

func (x *StreamFeatureViewSpec) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *StreamFeatureViewSpec) GetProject() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Project
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *StreamFeatureViewSpec) GetEntities() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Entities
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *StreamFeatureViewSpec) GetFeatures() []*FeatureSpecV2 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Features
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *StreamFeatureViewSpec) GetEntityColumns() []*FeatureSpecV2 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.EntityColumns
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *StreamFeatureViewSpec) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *StreamFeatureViewSpec) GetTags() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tags
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *StreamFeatureViewSpec) GetOwner() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Owner
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *StreamFeatureViewSpec) GetTtl() *durationpb.Duration <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Ttl
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *StreamFeatureViewSpec) GetBatchSource() *DataSource <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.BatchSource
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *StreamFeatureViewSpec) GetStreamSource() *DataSource <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.StreamSource
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *StreamFeatureViewSpec) GetOnline() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Online
        }</span>
        <span class="cov0" title="0">return false</span>
}

// Deprecated: Marked as deprecated in feast/core/StreamFeatureView.proto.
func (x *StreamFeatureViewSpec) GetUserDefinedFunction() *UserDefinedFunction <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.UserDefinedFunction
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *StreamFeatureViewSpec) GetMode() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Mode
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *StreamFeatureViewSpec) GetAggregations() []*Aggregation <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Aggregations
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *StreamFeatureViewSpec) GetTimestampField() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TimestampField
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *StreamFeatureViewSpec) GetFeatureTransformation() *FeatureTransformationV2 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FeatureTransformation
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_feast_core_StreamFeatureView_proto protoreflect.FileDescriptor

var file_feast_core_StreamFeatureView_proto_rawDesc = []byte{
        0x0a, 0x22, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x53, 0x74, 0x72,
        0x65, 0x61, 0x6d, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0a, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65,
        0x1a, 0x1e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75,
        0x66, 0x2f, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x1a, 0x24, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x4f, 0x6e, 0x44,
        0x65, 0x6d, 0x61, 0x6e, 0x64, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77,
        0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1c, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f,
        0x72, 0x65, 0x2f, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x18, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65,
        0x2f, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1b,
        0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x44, 0x61, 0x74, 0x61, 0x53,
        0x6f, 0x75, 0x72, 0x63, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1c, 0x66, 0x65, 0x61,
        0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x41, 0x67, 0x67, 0x72, 0x65, 0x67, 0x61, 0x74,
        0x69, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1f, 0x66, 0x65, 0x61, 0x73, 0x74,
        0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x61,
        0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x7b, 0x0a, 0x11, 0x53, 0x74,
        0x72, 0x65, 0x61, 0x6d, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77, 0x12,
        0x35, 0x0a, 0x04, 0x73, 0x70, 0x65, 0x63, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x21, 0x2e,
        0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x53, 0x74, 0x72, 0x65, 0x61,
        0x6d, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77, 0x53, 0x70, 0x65, 0x63,
        0x52, 0x04, 0x73, 0x70, 0x65, 0x63, 0x12, 0x2f, 0x0a, 0x04, 0x6d, 0x65, 0x74, 0x61, 0x18, 0x02,
        0x20, 0x01, 0x28, 0x0b, 0x32, 0x1b, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72,
        0x65, 0x2e, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77, 0x4d, 0x65, 0x74,
        0x61, 0x52, 0x04, 0x6d, 0x65, 0x74, 0x61, 0x22, 0xf8, 0x06, 0x0a, 0x15, 0x53, 0x74, 0x72, 0x65,
        0x61, 0x6d, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77, 0x53, 0x70, 0x65,
        0x63, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74,
        0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x12,
        0x1a, 0x0a, 0x08, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x69, 0x65, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28,
        0x09, 0x52, 0x08, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x69, 0x65, 0x73, 0x12, 0x35, 0x0a, 0x08, 0x66,
        0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x19, 0x2e,
        0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x46, 0x65, 0x61, 0x74, 0x75,
        0x72, 0x65, 0x53, 0x70, 0x65, 0x63, 0x56, 0x32, 0x52, 0x08, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72,
        0x65, 0x73, 0x12, 0x40, 0x0a, 0x0e, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x5f, 0x63, 0x6f, 0x6c,
        0x75, 0x6d, 0x6e, 0x73, 0x18, 0x05, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x66, 0x65, 0x61,
        0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x53,
        0x70, 0x65, 0x63, 0x56, 0x32, 0x52, 0x0d, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x43, 0x6f, 0x6c,
        0x75, 0x6d, 0x6e, 0x73, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,
        0x69, 0x6f, 0x6e, 0x18, 0x06, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72,
        0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x3f, 0x0a, 0x04, 0x74, 0x61, 0x67, 0x73, 0x18, 0x07,
        0x20, 0x03, 0x28, 0x0b, 0x32, 0x2b, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72,
        0x65, 0x2e, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56,
        0x69, 0x65, 0x77, 0x53, 0x70, 0x65, 0x63, 0x2e, 0x54, 0x61, 0x67, 0x73, 0x45, 0x6e, 0x74, 0x72,
        0x79, 0x52, 0x04, 0x74, 0x61, 0x67, 0x73, 0x12, 0x14, 0x0a, 0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72,
        0x18, 0x08, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x6f, 0x77, 0x6e, 0x65, 0x72, 0x12, 0x2b, 0x0a,
        0x03, 0x74, 0x74, 0x6c, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67, 0x6f, 0x6f,
        0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x44, 0x75, 0x72,
        0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x03, 0x74, 0x74, 0x6c, 0x12, 0x39, 0x0a, 0x0c, 0x62, 0x61,
        0x74, 0x63, 0x68, 0x5f, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0b,
        0x32, 0x16, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x44, 0x61,
        0x74, 0x61, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x52, 0x0b, 0x62, 0x61, 0x74, 0x63, 0x68, 0x53,
        0x6f, 0x75, 0x72, 0x63, 0x65, 0x12, 0x3b, 0x0a, 0x0d, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x5f,
        0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x66,
        0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x44, 0x61, 0x74, 0x61, 0x53, 0x6f,
        0x75, 0x72, 0x63, 0x65, 0x52, 0x0c, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x53, 0x6f, 0x75, 0x72,
        0x63, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x6f, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x18, 0x0c, 0x20, 0x01,
        0x28, 0x08, 0x52, 0x06, 0x6f, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x12, 0x57, 0x0a, 0x15, 0x75, 0x73,
        0x65, 0x72, 0x5f, 0x64, 0x65, 0x66, 0x69, 0x6e, 0x65, 0x64, 0x5f, 0x66, 0x75, 0x6e, 0x63, 0x74,
        0x69, 0x6f, 0x6e, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1f, 0x2e, 0x66, 0x65, 0x61, 0x73,
        0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x44, 0x65, 0x66, 0x69, 0x6e,
        0x65, 0x64, 0x46, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x42, 0x02, 0x18, 0x01, 0x52, 0x13,
        0x75, 0x73, 0x65, 0x72, 0x44, 0x65, 0x66, 0x69, 0x6e, 0x65, 0x64, 0x46, 0x75, 0x6e, 0x63, 0x74,
        0x69, 0x6f, 0x6e, 0x12, 0x12, 0x0a, 0x04, 0x6d, 0x6f, 0x64, 0x65, 0x18, 0x0e, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x04, 0x6d, 0x6f, 0x64, 0x65, 0x12, 0x3b, 0x0a, 0x0c, 0x61, 0x67, 0x67, 0x72, 0x65,
        0x67, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x0f, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x17, 0x2e,
        0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x41, 0x67, 0x67, 0x72, 0x65,
        0x67, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0c, 0x61, 0x67, 0x67, 0x72, 0x65, 0x67, 0x61, 0x74,
        0x69, 0x6f, 0x6e, 0x73, 0x12, 0x27, 0x0a, 0x0f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d,
        0x70, 0x5f, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x18, 0x10, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x74,
        0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x12, 0x5a, 0x0a,
        0x16, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x5f, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f,
        0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x11, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x23, 0x2e,
        0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x46, 0x65, 0x61, 0x74, 0x75,
        0x72, 0x65, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e,
        0x56, 0x32, 0x52, 0x15, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x54, 0x72, 0x61, 0x6e, 0x73,
        0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x1a, 0x37, 0x0a, 0x09, 0x54, 0x61, 0x67,
        0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75,
        0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02,
        0x38, 0x01, 0x42, 0x5b, 0x0a, 0x10, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x42, 0x16, 0x53, 0x74, 0x72, 0x65, 0x61, 0x6d, 0x46, 0x65,
        0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x5a, 0x2f,
        0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74,
        0x2d, 0x64, 0x65, 0x76, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x67, 0x6f, 0x2f, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x73, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x62,
        0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_feast_core_StreamFeatureView_proto_rawDescOnce sync.Once
        file_feast_core_StreamFeatureView_proto_rawDescData = file_feast_core_StreamFeatureView_proto_rawDesc
)

func file_feast_core_StreamFeatureView_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_feast_core_StreamFeatureView_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_feast_core_StreamFeatureView_proto_rawDescData = protoimpl.X.CompressGZIP(file_feast_core_StreamFeatureView_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_feast_core_StreamFeatureView_proto_rawDescData</span>
}

var file_feast_core_StreamFeatureView_proto_msgTypes = make([]protoimpl.MessageInfo, 3)
var file_feast_core_StreamFeatureView_proto_goTypes = []interface{}{
        (*StreamFeatureView)(nil),       // 0: feast.core.StreamFeatureView
        (*StreamFeatureViewSpec)(nil),   // 1: feast.core.StreamFeatureViewSpec
        nil,                             // 2: feast.core.StreamFeatureViewSpec.TagsEntry
        (*FeatureViewMeta)(nil),         // 3: feast.core.FeatureViewMeta
        (*FeatureSpecV2)(nil),           // 4: feast.core.FeatureSpecV2
        (*durationpb.Duration)(nil),     // 5: google.protobuf.Duration
        (*DataSource)(nil),              // 6: feast.core.DataSource
        (*UserDefinedFunction)(nil),     // 7: feast.core.UserDefinedFunction
        (*Aggregation)(nil),             // 8: feast.core.Aggregation
        (*FeatureTransformationV2)(nil), // 9: feast.core.FeatureTransformationV2
}
var file_feast_core_StreamFeatureView_proto_depIdxs = []int32{
        1,  // 0: feast.core.StreamFeatureView.spec:type_name -&gt; feast.core.StreamFeatureViewSpec
        3,  // 1: feast.core.StreamFeatureView.meta:type_name -&gt; feast.core.FeatureViewMeta
        4,  // 2: feast.core.StreamFeatureViewSpec.features:type_name -&gt; feast.core.FeatureSpecV2
        4,  // 3: feast.core.StreamFeatureViewSpec.entity_columns:type_name -&gt; feast.core.FeatureSpecV2
        2,  // 4: feast.core.StreamFeatureViewSpec.tags:type_name -&gt; feast.core.StreamFeatureViewSpec.TagsEntry
        5,  // 5: feast.core.StreamFeatureViewSpec.ttl:type_name -&gt; google.protobuf.Duration
        6,  // 6: feast.core.StreamFeatureViewSpec.batch_source:type_name -&gt; feast.core.DataSource
        6,  // 7: feast.core.StreamFeatureViewSpec.stream_source:type_name -&gt; feast.core.DataSource
        7,  // 8: feast.core.StreamFeatureViewSpec.user_defined_function:type_name -&gt; feast.core.UserDefinedFunction
        8,  // 9: feast.core.StreamFeatureViewSpec.aggregations:type_name -&gt; feast.core.Aggregation
        9,  // 10: feast.core.StreamFeatureViewSpec.feature_transformation:type_name -&gt; feast.core.FeatureTransformationV2
        11, // [11:11] is the sub-list for method output_type
        11, // [11:11] is the sub-list for method input_type
        11, // [11:11] is the sub-list for extension type_name
        11, // [11:11] is the sub-list for extension extendee
        0,  // [0:11] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_feast_core_StreamFeatureView_proto_init() }</span>
func file_feast_core_StreamFeatureView_proto_init() <span class="cov8" title="1">{
        if File_feast_core_StreamFeatureView_proto != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">file_feast_core_OnDemandFeatureView_proto_init()
        file_feast_core_FeatureView_proto_init()
        file_feast_core_Feature_proto_init()
        file_feast_core_DataSource_proto_init()
        file_feast_core_Aggregation_proto_init()
        file_feast_core_Transformation_proto_init()
        if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_feast_core_StreamFeatureView_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*StreamFeatureView); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_StreamFeatureView_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*StreamFeatureViewSpec); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_feast_core_StreamFeatureView_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   3,
                        NumExtensions: 0,
                        NumServices:   0,
                },
                GoTypes:           file_feast_core_StreamFeatureView_proto_goTypes,
                DependencyIndexes: file_feast_core_StreamFeatureView_proto_depIdxs,
                MessageInfos:      file_feast_core_StreamFeatureView_proto_msgTypes,
        }.Build()
        File_feast_core_StreamFeatureView_proto = out.File
        file_feast_core_StreamFeatureView_proto_rawDesc = nil
        file_feast_core_StreamFeatureView_proto_goTypes = nil
        file_feast_core_StreamFeatureView_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.31.0
//         protoc        v4.25.1
// source: feast/core/Transformation.proto

package core

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Serialized representation of python function.
type UserDefinedFunctionV2 struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // The function name
        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        // The python-syntax function body (serialized by dill)
        Body []byte `protobuf:"bytes,2,opt,name=body,proto3" json:"body,omitempty"`
        // The string representation of the udf
        BodyText string `protobuf:"bytes,3,opt,name=body_text,json=bodyText,proto3" json:"body_text,omitempty"`
}

func (x *UserDefinedFunctionV2) Reset() <span class="cov0" title="0">{
        *x = UserDefinedFunctionV2{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_Transformation_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *UserDefinedFunctionV2) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*UserDefinedFunctionV2) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *UserDefinedFunctionV2) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_feast_core_Transformation_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use UserDefinedFunctionV2.ProtoReflect.Descriptor instead.
func (*UserDefinedFunctionV2) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_Transformation_proto_rawDescGZIP(), []int{0}
}</span>

func (x *UserDefinedFunctionV2) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *UserDefinedFunctionV2) GetBody() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Body
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *UserDefinedFunctionV2) GetBodyText() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.BodyText
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// A feature transformation executed as a user-defined function
type FeatureTransformationV2 struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Types that are assignable to Transformation:
        //
        //        *FeatureTransformationV2_UserDefinedFunction
        //        *FeatureTransformationV2_SubstraitTransformation
        Transformation isFeatureTransformationV2_Transformation `protobuf_oneof:"transformation"`
}

func (x *FeatureTransformationV2) Reset() <span class="cov0" title="0">{
        *x = FeatureTransformationV2{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_Transformation_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *FeatureTransformationV2) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FeatureTransformationV2) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FeatureTransformationV2) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_Transformation_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use FeatureTransformationV2.ProtoReflect.Descriptor instead.
func (*FeatureTransformationV2) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_Transformation_proto_rawDescGZIP(), []int{1}
}</span>

func (m *FeatureTransformationV2) GetTransformation() isFeatureTransformationV2_Transformation <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Transformation
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FeatureTransformationV2) GetUserDefinedFunction() *UserDefinedFunctionV2 <span class="cov0" title="0">{
        if x, ok := x.GetTransformation().(*FeatureTransformationV2_UserDefinedFunction); ok </span><span class="cov0" title="0">{
                return x.UserDefinedFunction
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *FeatureTransformationV2) GetSubstraitTransformation() *SubstraitTransformationV2 <span class="cov0" title="0">{
        if x, ok := x.GetTransformation().(*FeatureTransformationV2_SubstraitTransformation); ok </span><span class="cov0" title="0">{
                return x.SubstraitTransformation
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type isFeatureTransformationV2_Transformation interface {
        isFeatureTransformationV2_Transformation()
}

type FeatureTransformationV2_UserDefinedFunction struct {
        UserDefinedFunction *UserDefinedFunctionV2 `protobuf:"bytes,1,opt,name=user_defined_function,json=userDefinedFunction,proto3,oneof"`
}

type FeatureTransformationV2_SubstraitTransformation struct {
        SubstraitTransformation *SubstraitTransformationV2 `protobuf:"bytes,2,opt,name=substrait_transformation,json=substraitTransformation,proto3,oneof"`
}

func (*FeatureTransformationV2_UserDefinedFunction) isFeatureTransformationV2_Transformation() {<span class="cov0" title="0">}</span>

func (*FeatureTransformationV2_SubstraitTransformation) isFeatureTransformationV2_Transformation() {<span class="cov0" title="0">}</span>

type SubstraitTransformationV2 struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        SubstraitPlan []byte `protobuf:"bytes,1,opt,name=substrait_plan,json=substraitPlan,proto3" json:"substrait_plan,omitempty"`
        IbisFunction  []byte `protobuf:"bytes,2,opt,name=ibis_function,json=ibisFunction,proto3" json:"ibis_function,omitempty"`
}

func (x *SubstraitTransformationV2) Reset() <span class="cov0" title="0">{
        *x = SubstraitTransformationV2{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_Transformation_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *SubstraitTransformationV2) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*SubstraitTransformationV2) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *SubstraitTransformationV2) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_feast_core_Transformation_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use SubstraitTransformationV2.ProtoReflect.Descriptor instead.
func (*SubstraitTransformationV2) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_Transformation_proto_rawDescGZIP(), []int{2}
}</span>

func (x *SubstraitTransformationV2) GetSubstraitPlan() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.SubstraitPlan
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *SubstraitTransformationV2) GetIbisFunction() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.IbisFunction
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_feast_core_Transformation_proto protoreflect.FileDescriptor

var file_feast_core_Transformation_proto_rawDesc = []byte{
        0x0a, 0x1f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x54, 0x72, 0x61,
        0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x12, 0x0a, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x22, 0x5c, 0x0a,
        0x15, 0x55, 0x73, 0x65, 0x72, 0x44, 0x65, 0x66, 0x69, 0x6e, 0x65, 0x64, 0x46, 0x75, 0x6e, 0x63,
        0x74, 0x69, 0x6f, 0x6e, 0x56, 0x32, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x62, 0x6f,
        0x64, 0x79, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x04, 0x62, 0x6f, 0x64, 0x79, 0x12, 0x1b,
        0x0a, 0x09, 0x62, 0x6f, 0x64, 0x79, 0x5f, 0x74, 0x65, 0x78, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x08, 0x62, 0x6f, 0x64, 0x79, 0x54, 0x65, 0x78, 0x74, 0x22, 0xe8, 0x01, 0x0a, 0x17,
        0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d,
        0x61, 0x74, 0x69, 0x6f, 0x6e, 0x56, 0x32, 0x12, 0x57, 0x0a, 0x15, 0x75, 0x73, 0x65, 0x72, 0x5f,
        0x64, 0x65, 0x66, 0x69, 0x6e, 0x65, 0x64, 0x5f, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e,
        0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63,
        0x6f, 0x72, 0x65, 0x2e, 0x55, 0x73, 0x65, 0x72, 0x44, 0x65, 0x66, 0x69, 0x6e, 0x65, 0x64, 0x46,
        0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x56, 0x32, 0x48, 0x00, 0x52, 0x13, 0x75, 0x73, 0x65,
        0x72, 0x44, 0x65, 0x66, 0x69, 0x6e, 0x65, 0x64, 0x46, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e,
        0x12, 0x62, 0x0a, 0x18, 0x73, 0x75, 0x62, 0x73, 0x74, 0x72, 0x61, 0x69, 0x74, 0x5f, 0x74, 0x72,
        0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01,
        0x28, 0x0b, 0x32, 0x25, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e,
        0x53, 0x75, 0x62, 0x73, 0x74, 0x72, 0x61, 0x69, 0x74, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f,
        0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x56, 0x32, 0x48, 0x00, 0x52, 0x17, 0x73, 0x75, 0x62,
        0x73, 0x74, 0x72, 0x61, 0x69, 0x74, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x61,
        0x74, 0x69, 0x6f, 0x6e, 0x42, 0x10, 0x0a, 0x0e, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72,
        0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x67, 0x0a, 0x19, 0x53, 0x75, 0x62, 0x73, 0x74, 0x72,
        0x61, 0x69, 0x74, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f,
        0x6e, 0x56, 0x32, 0x12, 0x25, 0x0a, 0x0e, 0x73, 0x75, 0x62, 0x73, 0x74, 0x72, 0x61, 0x69, 0x74,
        0x5f, 0x70, 0x6c, 0x61, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x0d, 0x73, 0x75, 0x62,
        0x73, 0x74, 0x72, 0x61, 0x69, 0x74, 0x50, 0x6c, 0x61, 0x6e, 0x12, 0x23, 0x0a, 0x0d, 0x69, 0x62,
        0x69, 0x73, 0x5f, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28,
        0x0c, 0x52, 0x0c, 0x69, 0x62, 0x69, 0x73, 0x46, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x42,
        0x5f, 0x0a, 0x10, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x63,
        0x6f, 0x72, 0x65, 0x42, 0x1a, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x54, 0x72, 0x61, 0x6e,
        0x73, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x5a,
        0x2f, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x66, 0x65, 0x61, 0x73,
        0x74, 0x2d, 0x64, 0x65, 0x76, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x67, 0x6f, 0x2f, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x73, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65,
        0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_feast_core_Transformation_proto_rawDescOnce sync.Once
        file_feast_core_Transformation_proto_rawDescData = file_feast_core_Transformation_proto_rawDesc
)

func file_feast_core_Transformation_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_feast_core_Transformation_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_feast_core_Transformation_proto_rawDescData = protoimpl.X.CompressGZIP(file_feast_core_Transformation_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_feast_core_Transformation_proto_rawDescData</span>
}

var file_feast_core_Transformation_proto_msgTypes = make([]protoimpl.MessageInfo, 3)
var file_feast_core_Transformation_proto_goTypes = []interface{}{
        (*UserDefinedFunctionV2)(nil),     // 0: feast.core.UserDefinedFunctionV2
        (*FeatureTransformationV2)(nil),   // 1: feast.core.FeatureTransformationV2
        (*SubstraitTransformationV2)(nil), // 2: feast.core.SubstraitTransformationV2
}
var file_feast_core_Transformation_proto_depIdxs = []int32{
        0, // 0: feast.core.FeatureTransformationV2.user_defined_function:type_name -&gt; feast.core.UserDefinedFunctionV2
        2, // 1: feast.core.FeatureTransformationV2.substrait_transformation:type_name -&gt; feast.core.SubstraitTransformationV2
        2, // [2:2] is the sub-list for method output_type
        2, // [2:2] is the sub-list for method input_type
        2, // [2:2] is the sub-list for extension type_name
        2, // [2:2] is the sub-list for extension extendee
        0, // [0:2] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_feast_core_Transformation_proto_init() }</span>
func file_feast_core_Transformation_proto_init() <span class="cov8" title="1">{
        if File_feast_core_Transformation_proto != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_feast_core_Transformation_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*UserDefinedFunctionV2); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_Transformation_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*FeatureTransformationV2); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_Transformation_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*SubstraitTransformationV2); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">file_feast_core_Transformation_proto_msgTypes[1].OneofWrappers = []interface{}{
                (*FeatureTransformationV2_UserDefinedFunction)(nil),
                (*FeatureTransformationV2_SubstraitTransformation)(nil),
        }
        type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_feast_core_Transformation_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   3,
                        NumExtensions: 0,
                        NumServices:   0,
                },
                GoTypes:           file_feast_core_Transformation_proto_goTypes,
                DependencyIndexes: file_feast_core_Transformation_proto_depIdxs,
                MessageInfos:      file_feast_core_Transformation_proto_msgTypes,
        }.Build()
        File_feast_core_Transformation_proto = out.File
        file_feast_core_Transformation_proto_rawDesc = nil
        file_feast_core_Transformation_proto_goTypes = nil
        file_feast_core_Transformation_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">//
// Copyright 2021 The Feast Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.31.0
//         protoc        v4.25.1
// source: feast/core/ValidationProfile.proto

package core

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type GEValidationProfiler struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Profiler *GEValidationProfiler_UserDefinedProfiler `protobuf:"bytes,1,opt,name=profiler,proto3" json:"profiler,omitempty"`
}

func (x *GEValidationProfiler) Reset() <span class="cov0" title="0">{
        *x = GEValidationProfiler{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_ValidationProfile_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GEValidationProfiler) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GEValidationProfiler) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GEValidationProfiler) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_feast_core_ValidationProfile_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GEValidationProfiler.ProtoReflect.Descriptor instead.
func (*GEValidationProfiler) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_ValidationProfile_proto_rawDescGZIP(), []int{0}
}</span>

func (x *GEValidationProfiler) GetProfiler() *GEValidationProfiler_UserDefinedProfiler <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Profiler
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GEValidationProfile struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // JSON-serialized ExpectationSuite object
        ExpectationSuite []byte `protobuf:"bytes,1,opt,name=expectation_suite,json=expectationSuite,proto3" json:"expectation_suite,omitempty"`
}

func (x *GEValidationProfile) Reset() <span class="cov0" title="0">{
        *x = GEValidationProfile{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_ValidationProfile_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GEValidationProfile) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GEValidationProfile) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GEValidationProfile) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_feast_core_ValidationProfile_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GEValidationProfile.ProtoReflect.Descriptor instead.
func (*GEValidationProfile) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_ValidationProfile_proto_rawDescGZIP(), []int{1}
}</span>

func (x *GEValidationProfile) GetExpectationSuite() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ExpectationSuite
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ValidationReference struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Unique name of validation reference within the project
        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        // Name of saved dataset used as reference dataset
        ReferenceDatasetName string `protobuf:"bytes,2,opt,name=reference_dataset_name,json=referenceDatasetName,proto3" json:"reference_dataset_name,omitempty"`
        // Name of Feast project that this object source belongs to
        Project string `protobuf:"bytes,3,opt,name=project,proto3" json:"project,omitempty"`
        // Description of the validation reference
        Description string `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
        // User defined metadata
        Tags map[string]string `protobuf:"bytes,5,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        // validation profiler
        //
        // Types that are assignable to Profiler:
        //
        //        *ValidationReference_GeProfiler
        Profiler isValidationReference_Profiler `protobuf_oneof:"profiler"`
        // (optional) cached validation profile (to avoid constant recalculation)
        //
        // Types that are assignable to CachedProfile:
        //
        //        *ValidationReference_GeProfile
        CachedProfile isValidationReference_CachedProfile `protobuf_oneof:"cached_profile"`
}

func (x *ValidationReference) Reset() <span class="cov0" title="0">{
        *x = ValidationReference{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_ValidationProfile_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ValidationReference) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ValidationReference) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ValidationReference) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_core_ValidationProfile_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use ValidationReference.ProtoReflect.Descriptor instead.
func (*ValidationReference) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_ValidationProfile_proto_rawDescGZIP(), []int{2}
}</span>

func (x *ValidationReference) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ValidationReference) GetReferenceDatasetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.ReferenceDatasetName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ValidationReference) GetProject() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Project
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ValidationReference) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *ValidationReference) GetTags() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tags
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *ValidationReference) GetProfiler() isValidationReference_Profiler <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Profiler
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ValidationReference) GetGeProfiler() *GEValidationProfiler <span class="cov0" title="0">{
        if x, ok := x.GetProfiler().(*ValidationReference_GeProfiler); ok </span><span class="cov0" title="0">{
                return x.GeProfiler
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (m *ValidationReference) GetCachedProfile() isValidationReference_CachedProfile <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.CachedProfile
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ValidationReference) GetGeProfile() *GEValidationProfile <span class="cov0" title="0">{
        if x, ok := x.GetCachedProfile().(*ValidationReference_GeProfile); ok </span><span class="cov0" title="0">{
                return x.GeProfile
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type isValidationReference_Profiler interface {
        isValidationReference_Profiler()
}

type ValidationReference_GeProfiler struct {
        GeProfiler *GEValidationProfiler `protobuf:"bytes,6,opt,name=ge_profiler,json=geProfiler,proto3,oneof"`
}

func (*ValidationReference_GeProfiler) isValidationReference_Profiler() {<span class="cov0" title="0">}</span>

type isValidationReference_CachedProfile interface {
        isValidationReference_CachedProfile()
}

type ValidationReference_GeProfile struct {
        GeProfile *GEValidationProfile `protobuf:"bytes,7,opt,name=ge_profile,json=geProfile,proto3,oneof"`
}

func (*ValidationReference_GeProfile) isValidationReference_CachedProfile() {<span class="cov0" title="0">}</span>

type GEValidationProfiler_UserDefinedProfiler struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // The python-syntax function body (serialized by dill)
        Body []byte `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
}

func (x *GEValidationProfiler_UserDefinedProfiler) Reset() <span class="cov0" title="0">{
        *x = GEValidationProfiler_UserDefinedProfiler{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_core_ValidationProfile_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GEValidationProfiler_UserDefinedProfiler) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GEValidationProfiler_UserDefinedProfiler) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GEValidationProfiler_UserDefinedProfiler) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_feast_core_ValidationProfile_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GEValidationProfiler_UserDefinedProfiler.ProtoReflect.Descriptor instead.
func (*GEValidationProfiler_UserDefinedProfiler) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_core_ValidationProfile_proto_rawDescGZIP(), []int{0, 0}
}</span>

func (x *GEValidationProfiler_UserDefinedProfiler) GetBody() []byte <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Body
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_feast_core_ValidationProfile_proto protoreflect.FileDescriptor

var file_feast_core_ValidationProfile_proto_rawDesc = []byte{
        0x0a, 0x22, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x56, 0x61, 0x6c,
        0x69, 0x64, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0a, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65,
        0x22, 0x93, 0x01, 0x0a, 0x14, 0x47, 0x45, 0x56, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x69, 0x6f,
        0x6e, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65, 0x72, 0x12, 0x50, 0x0a, 0x08, 0x70, 0x72, 0x6f,
        0x66, 0x69, 0x6c, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x34, 0x2e, 0x66, 0x65,
        0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x47, 0x45, 0x56, 0x61, 0x6c, 0x69, 0x64,
        0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65, 0x72, 0x2e, 0x55, 0x73,
        0x65, 0x72, 0x44, 0x65, 0x66, 0x69, 0x6e, 0x65, 0x64, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65,
        0x72, 0x52, 0x08, 0x70, 0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65, 0x72, 0x1a, 0x29, 0x0a, 0x13, 0x55,
        0x73, 0x65, 0x72, 0x44, 0x65, 0x66, 0x69, 0x6e, 0x65, 0x64, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x6c,
        0x65, 0x72, 0x12, 0x12, 0x0a, 0x04, 0x62, 0x6f, 0x64, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c,
        0x52, 0x04, 0x62, 0x6f, 0x64, 0x79, 0x22, 0x42, 0x0a, 0x13, 0x47, 0x45, 0x56, 0x61, 0x6c, 0x69,
        0x64, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65, 0x12, 0x2b, 0x0a,
        0x11, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x73, 0x75, 0x69,
        0x74, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x10, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74,
        0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x75, 0x69, 0x74, 0x65, 0x22, 0xb8, 0x03, 0x0a, 0x13, 0x56,
        0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6e,
        0x63, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x34, 0x0a, 0x16, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65,
        0x6e, 0x63, 0x65, 0x5f, 0x64, 0x61, 0x74, 0x61, 0x73, 0x65, 0x74, 0x5f, 0x6e, 0x61, 0x6d, 0x65,
        0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x14, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x63,
        0x65, 0x44, 0x61, 0x74, 0x61, 0x73, 0x65, 0x74, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x18, 0x0a, 0x07,
        0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x70,
        0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69,
        0x70, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73,
        0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x3d, 0x0a, 0x04, 0x74, 0x61, 0x67, 0x73,
        0x18, 0x05, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63,
        0x6f, 0x72, 0x65, 0x2e, 0x56, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x65,
        0x66, 0x65, 0x72, 0x65, 0x6e, 0x63, 0x65, 0x2e, 0x54, 0x61, 0x67, 0x73, 0x45, 0x6e, 0x74, 0x72,
        0x79, 0x52, 0x04, 0x74, 0x61, 0x67, 0x73, 0x12, 0x43, 0x0a, 0x0b, 0x67, 0x65, 0x5f, 0x70, 0x72,
        0x6f, 0x66, 0x69, 0x6c, 0x65, 0x72, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x66,
        0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x47, 0x45, 0x56, 0x61, 0x6c, 0x69,
        0x64, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65, 0x72, 0x48, 0x00,
        0x52, 0x0a, 0x67, 0x65, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65, 0x72, 0x12, 0x40, 0x0a, 0x0a,
        0x67, 0x65, 0x5f, 0x70, 0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b,
        0x32, 0x1f, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x47, 0x45,
        0x56, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x6c,
        0x65, 0x48, 0x01, 0x52, 0x09, 0x67, 0x65, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65, 0x1a, 0x37,
        0x0a, 0x09, 0x54, 0x61, 0x67, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b,
        0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a,
        0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61,
        0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x42, 0x0a, 0x0a, 0x08, 0x70, 0x72, 0x6f, 0x66, 0x69,
        0x6c, 0x65, 0x72, 0x42, 0x10, 0x0a, 0x0e, 0x63, 0x61, 0x63, 0x68, 0x65, 0x64, 0x5f, 0x70, 0x72,
        0x6f, 0x66, 0x69, 0x6c, 0x65, 0x42, 0x56, 0x0a, 0x10, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x42, 0x11, 0x56, 0x61, 0x6c, 0x69, 0x64,
        0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x72, 0x6f, 0x66, 0x69, 0x6c, 0x65, 0x5a, 0x2f, 0x67, 0x69,
        0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2d, 0x64,
        0x65, 0x76, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x67, 0x6f, 0x2f, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x73, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x62, 0x06, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_feast_core_ValidationProfile_proto_rawDescOnce sync.Once
        file_feast_core_ValidationProfile_proto_rawDescData = file_feast_core_ValidationProfile_proto_rawDesc
)

func file_feast_core_ValidationProfile_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_feast_core_ValidationProfile_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_feast_core_ValidationProfile_proto_rawDescData = protoimpl.X.CompressGZIP(file_feast_core_ValidationProfile_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_feast_core_ValidationProfile_proto_rawDescData</span>
}

var file_feast_core_ValidationProfile_proto_msgTypes = make([]protoimpl.MessageInfo, 5)
var file_feast_core_ValidationProfile_proto_goTypes = []interface{}{
        (*GEValidationProfiler)(nil),                     // 0: feast.core.GEValidationProfiler
        (*GEValidationProfile)(nil),                      // 1: feast.core.GEValidationProfile
        (*ValidationReference)(nil),                      // 2: feast.core.ValidationReference
        (*GEValidationProfiler_UserDefinedProfiler)(nil), // 3: feast.core.GEValidationProfiler.UserDefinedProfiler
        nil, // 4: feast.core.ValidationReference.TagsEntry
}
var file_feast_core_ValidationProfile_proto_depIdxs = []int32{
        3, // 0: feast.core.GEValidationProfiler.profiler:type_name -&gt; feast.core.GEValidationProfiler.UserDefinedProfiler
        4, // 1: feast.core.ValidationReference.tags:type_name -&gt; feast.core.ValidationReference.TagsEntry
        0, // 2: feast.core.ValidationReference.ge_profiler:type_name -&gt; feast.core.GEValidationProfiler
        1, // 3: feast.core.ValidationReference.ge_profile:type_name -&gt; feast.core.GEValidationProfile
        4, // [4:4] is the sub-list for method output_type
        4, // [4:4] is the sub-list for method input_type
        4, // [4:4] is the sub-list for extension type_name
        4, // [4:4] is the sub-list for extension extendee
        0, // [0:4] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_feast_core_ValidationProfile_proto_init() }</span>
func file_feast_core_ValidationProfile_proto_init() <span class="cov8" title="1">{
        if File_feast_core_ValidationProfile_proto != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_feast_core_ValidationProfile_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GEValidationProfiler); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_ValidationProfile_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GEValidationProfile); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_ValidationProfile_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ValidationReference); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_core_ValidationProfile_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GEValidationProfiler_UserDefinedProfiler); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">file_feast_core_ValidationProfile_proto_msgTypes[2].OneofWrappers = []interface{}{
                (*ValidationReference_GeProfiler)(nil),
                (*ValidationReference_GeProfile)(nil),
        }
        type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_feast_core_ValidationProfile_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   5,
                        NumExtensions: 0,
                        NumServices:   0,
                },
                GoTypes:           file_feast_core_ValidationProfile_proto_goTypes,
                DependencyIndexes: file_feast_core_ValidationProfile_proto_depIdxs,
                MessageInfos:      file_feast_core_ValidationProfile_proto_msgTypes,
        }.Build()
        File_feast_core_ValidationProfile_proto = out.File
        file_feast_core_ValidationProfile_proto_rawDesc = nil
        file_feast_core_ValidationProfile_proto_goTypes = nil
        file_feast_core_ValidationProfile_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.31.0
//         protoc        v4.25.1
// source: feast/serving/Connector.proto

package serving

import (
        types "github.com/feast-dev/feast/go/protos/feast/types"
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type ConnectorFeature struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Reference *FeatureReferenceV2    `protobuf:"bytes,1,opt,name=reference,proto3" json:"reference,omitempty"`
        Timestamp *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
        Value     *types.Value           `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
}

func (x *ConnectorFeature) Reset() <span class="cov0" title="0">{
        *x = ConnectorFeature{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_serving_Connector_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ConnectorFeature) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ConnectorFeature) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ConnectorFeature) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_feast_serving_Connector_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ConnectorFeature.ProtoReflect.Descriptor instead.
func (*ConnectorFeature) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_serving_Connector_proto_rawDescGZIP(), []int{0}
}</span>

func (x *ConnectorFeature) GetReference() *FeatureReferenceV2 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Reference
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ConnectorFeature) GetTimestamp() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Timestamp
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ConnectorFeature) GetValue() *types.Value <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Value
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type ConnectorFeatureList struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        FeatureList []*ConnectorFeature `protobuf:"bytes,1,rep,name=featureList,proto3" json:"featureList,omitempty"`
}

func (x *ConnectorFeatureList) Reset() <span class="cov0" title="0">{
        *x = ConnectorFeatureList{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_serving_Connector_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ConnectorFeatureList) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ConnectorFeatureList) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ConnectorFeatureList) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_feast_serving_Connector_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ConnectorFeatureList.ProtoReflect.Descriptor instead.
func (*ConnectorFeatureList) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_serving_Connector_proto_rawDescGZIP(), []int{1}
}</span>

func (x *ConnectorFeatureList) GetFeatureList() []*ConnectorFeature <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FeatureList
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type OnlineReadRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        EntityKeys []*types.EntityKey `protobuf:"bytes,1,rep,name=entityKeys,proto3" json:"entityKeys,omitempty"`
        View       string             `protobuf:"bytes,2,opt,name=view,proto3" json:"view,omitempty"`
        Features   []string           `protobuf:"bytes,3,rep,name=features,proto3" json:"features,omitempty"`
}

func (x *OnlineReadRequest) Reset() <span class="cov0" title="0">{
        *x = OnlineReadRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_serving_Connector_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *OnlineReadRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*OnlineReadRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *OnlineReadRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_feast_serving_Connector_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use OnlineReadRequest.ProtoReflect.Descriptor instead.
func (*OnlineReadRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_serving_Connector_proto_rawDescGZIP(), []int{2}
}</span>

func (x *OnlineReadRequest) GetEntityKeys() []*types.EntityKey <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.EntityKeys
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *OnlineReadRequest) GetView() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.View
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *OnlineReadRequest) GetFeatures() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Features
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type OnlineReadResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Results []*ConnectorFeatureList `protobuf:"bytes,1,rep,name=results,proto3" json:"results,omitempty"`
}

func (x *OnlineReadResponse) Reset() <span class="cov0" title="0">{
        *x = OnlineReadResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_serving_Connector_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *OnlineReadResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*OnlineReadResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *OnlineReadResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_feast_serving_Connector_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use OnlineReadResponse.ProtoReflect.Descriptor instead.
func (*OnlineReadResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_serving_Connector_proto_rawDescGZIP(), []int{3}
}</span>

func (x *OnlineReadResponse) GetResults() []*ConnectorFeatureList <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Results
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_feast_serving_Connector_proto protoreflect.FileDescriptor

var file_feast_serving_Connector_proto_rawDesc = []byte{
        0x0a, 0x1d, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2f,
        0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12,
        0x0e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x1a,
        0x1f, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66,
        0x2f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x1a, 0x17, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2f, 0x56, 0x61,
        0x6c, 0x75, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1b, 0x66, 0x65, 0x61, 0x73, 0x74,
        0x2f, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2f, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x4b, 0x65, 0x79,
        0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x22, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x73, 0x65,
        0x72, 0x76, 0x69, 0x6e, 0x67, 0x2f, 0x53, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x53, 0x65, 0x72,
        0x76, 0x69, 0x63, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xb7, 0x01, 0x0a, 0x10, 0x43,
        0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x12,
        0x3f, 0x0a, 0x09, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x63, 0x65, 0x18, 0x01, 0x20, 0x01,
        0x28, 0x0b, 0x32, 0x21, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69,
        0x6e, 0x67, 0x2e, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x52, 0x65, 0x66, 0x65, 0x72, 0x65,
        0x6e, 0x63, 0x65, 0x56, 0x32, 0x52, 0x09, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x63, 0x65,
        0x12, 0x38, 0x0a, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x18, 0x02, 0x20,
        0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52,
        0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x12, 0x28, 0x0a, 0x05, 0x76, 0x61,
        0x6c, 0x75, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x66, 0x65, 0x61, 0x73,
        0x74, 0x2e, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x05, 0x76,
        0x61, 0x6c, 0x75, 0x65, 0x22, 0x5a, 0x0a, 0x14, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f,
        0x72, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x4c, 0x69, 0x73, 0x74, 0x12, 0x42, 0x0a, 0x0b,
        0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x4c, 0x69, 0x73, 0x74, 0x18, 0x01, 0x20, 0x03, 0x28,
        0x0b, 0x32, 0x20, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74,
        0x6f, 0x72, 0x2e, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x46, 0x65, 0x61, 0x74,
        0x75, 0x72, 0x65, 0x52, 0x0b, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x4c, 0x69, 0x73, 0x74,
        0x22, 0x7b, 0x0a, 0x11, 0x4f, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x52, 0x65, 0x61, 0x64, 0x52, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x36, 0x0a, 0x0a, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x4b,
        0x65, 0x79, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x66, 0x65, 0x61, 0x73,
        0x74, 0x2e, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2e, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x4b, 0x65,
        0x79, 0x52, 0x0a, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x4b, 0x65, 0x79, 0x73, 0x12, 0x12, 0x0a,
        0x04, 0x76, 0x69, 0x65, 0x77, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x76, 0x69, 0x65,
        0x77, 0x12, 0x1a, 0x0a, 0x08, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x18, 0x03, 0x20,
        0x03, 0x28, 0x09, 0x52, 0x08, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x22, 0x54, 0x0a,
        0x12, 0x4f, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x52, 0x65, 0x61, 0x64, 0x52, 0x65, 0x73, 0x70, 0x6f,
        0x6e, 0x73, 0x65, 0x12, 0x3e, 0x0a, 0x07, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x73, 0x18, 0x01,
        0x20, 0x03, 0x28, 0x0b, 0x32, 0x24, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x63, 0x6f, 0x6e, 0x6e,
        0x65, 0x63, 0x74, 0x6f, 0x72, 0x2e, 0x43, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x46,
        0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x4c, 0x69, 0x73, 0x74, 0x52, 0x07, 0x72, 0x65, 0x73, 0x75,
        0x6c, 0x74, 0x73, 0x32, 0x62, 0x0a, 0x0b, 0x4f, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x53, 0x74, 0x6f,
        0x72, 0x65, 0x12, 0x53, 0x0a, 0x0a, 0x4f, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x52, 0x65, 0x61, 0x64,
        0x12, 0x21, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f,
        0x72, 0x2e, 0x4f, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x52, 0x65, 0x61, 0x64, 0x52, 0x65, 0x71, 0x75,
        0x65, 0x73, 0x74, 0x1a, 0x22, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x63, 0x6f, 0x6e, 0x6e, 0x65,
        0x63, 0x74, 0x6f, 0x72, 0x2e, 0x4f, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x52, 0x65, 0x61, 0x64, 0x52,
        0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x42, 0x34, 0x5a, 0x32, 0x67, 0x69, 0x74, 0x68, 0x75,
        0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2d, 0x64, 0x65, 0x76, 0x2f,
        0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x67, 0x6f, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x73, 0x2f,
        0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x62, 0x06, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_feast_serving_Connector_proto_rawDescOnce sync.Once
        file_feast_serving_Connector_proto_rawDescData = file_feast_serving_Connector_proto_rawDesc
)

func file_feast_serving_Connector_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_feast_serving_Connector_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_feast_serving_Connector_proto_rawDescData = protoimpl.X.CompressGZIP(file_feast_serving_Connector_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_feast_serving_Connector_proto_rawDescData</span>
}

var file_feast_serving_Connector_proto_msgTypes = make([]protoimpl.MessageInfo, 4)
var file_feast_serving_Connector_proto_goTypes = []interface{}{
        (*ConnectorFeature)(nil),      // 0: grpc.connector.ConnectorFeature
        (*ConnectorFeatureList)(nil),  // 1: grpc.connector.ConnectorFeatureList
        (*OnlineReadRequest)(nil),     // 2: grpc.connector.OnlineReadRequest
        (*OnlineReadResponse)(nil),    // 3: grpc.connector.OnlineReadResponse
        (*FeatureReferenceV2)(nil),    // 4: feast.serving.FeatureReferenceV2
        (*timestamppb.Timestamp)(nil), // 5: google.protobuf.Timestamp
        (*types.Value)(nil),           // 6: feast.types.Value
        (*types.EntityKey)(nil),       // 7: feast.types.EntityKey
}
var file_feast_serving_Connector_proto_depIdxs = []int32{
        4, // 0: grpc.connector.ConnectorFeature.reference:type_name -&gt; feast.serving.FeatureReferenceV2
        5, // 1: grpc.connector.ConnectorFeature.timestamp:type_name -&gt; google.protobuf.Timestamp
        6, // 2: grpc.connector.ConnectorFeature.value:type_name -&gt; feast.types.Value
        0, // 3: grpc.connector.ConnectorFeatureList.featureList:type_name -&gt; grpc.connector.ConnectorFeature
        7, // 4: grpc.connector.OnlineReadRequest.entityKeys:type_name -&gt; feast.types.EntityKey
        1, // 5: grpc.connector.OnlineReadResponse.results:type_name -&gt; grpc.connector.ConnectorFeatureList
        2, // 6: grpc.connector.OnlineStore.OnlineRead:input_type -&gt; grpc.connector.OnlineReadRequest
        3, // 7: grpc.connector.OnlineStore.OnlineRead:output_type -&gt; grpc.connector.OnlineReadResponse
        7, // [7:8] is the sub-list for method output_type
        6, // [6:7] is the sub-list for method input_type
        6, // [6:6] is the sub-list for extension type_name
        6, // [6:6] is the sub-list for extension extendee
        0, // [0:6] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_feast_serving_Connector_proto_init() }</span>
func file_feast_serving_Connector_proto_init() <span class="cov8" title="1">{
        if File_feast_serving_Connector_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">file_feast_serving_ServingService_proto_init()
        if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_feast_serving_Connector_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ConnectorFeature); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_serving_Connector_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ConnectorFeatureList); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_serving_Connector_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*OnlineReadRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_serving_Connector_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*OnlineReadResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_feast_serving_Connector_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   4,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_feast_serving_Connector_proto_goTypes,
                DependencyIndexes: file_feast_serving_Connector_proto_depIdxs,
                MessageInfos:      file_feast_serving_Connector_proto_msgTypes,
        }.Build()
        File_feast_serving_Connector_proto = out.File
        file_feast_serving_Connector_proto_rawDesc = nil
        file_feast_serving_Connector_proto_goTypes = nil
        file_feast_serving_Connector_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.25.1
// source: feast/serving/Connector.proto

package serving

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
        OnlineStore_OnlineRead_FullMethodName = "/grpc.connector.OnlineStore/OnlineRead"
)

// OnlineStoreClient is the client API for OnlineStore service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type OnlineStoreClient interface {
        OnlineRead(ctx context.Context, in *OnlineReadRequest, opts ...grpc.CallOption) (*OnlineReadResponse, error)
}

type onlineStoreClient struct {
        cc grpc.ClientConnInterface
}

func NewOnlineStoreClient(cc grpc.ClientConnInterface) OnlineStoreClient <span class="cov0" title="0">{
        return &amp;onlineStoreClient{cc}
}</span>

func (c *onlineStoreClient) OnlineRead(ctx context.Context, in *OnlineReadRequest, opts ...grpc.CallOption) (*OnlineReadResponse, error) <span class="cov0" title="0">{
        out := new(OnlineReadResponse)
        err := c.cc.Invoke(ctx, OnlineStore_OnlineRead_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// OnlineStoreServer is the server API for OnlineStore service.
// All implementations must embed UnimplementedOnlineStoreServer
// for forward compatibility
type OnlineStoreServer interface {
        OnlineRead(context.Context, *OnlineReadRequest) (*OnlineReadResponse, error)
        mustEmbedUnimplementedOnlineStoreServer()
}

// UnimplementedOnlineStoreServer must be embedded to have forward compatible implementations.
type UnimplementedOnlineStoreServer struct {
}

func (UnimplementedOnlineStoreServer) OnlineRead(context.Context, *OnlineReadRequest) (*OnlineReadResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method OnlineRead not implemented")
}</span>
func (UnimplementedOnlineStoreServer) mustEmbedUnimplementedOnlineStoreServer() {<span class="cov0" title="0">}</span>

// UnsafeOnlineStoreServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OnlineStoreServer will
// result in compilation errors.
type UnsafeOnlineStoreServer interface {
        mustEmbedUnimplementedOnlineStoreServer()
}

func RegisterOnlineStoreServer(s grpc.ServiceRegistrar, srv OnlineStoreServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;OnlineStore_ServiceDesc, srv)
}</span>

func _OnlineStore_OnlineRead_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(OnlineReadRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(OnlineStoreServer).OnlineRead(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: OnlineStore_OnlineRead_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(OnlineStoreServer).OnlineRead(ctx, req.(*OnlineReadRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// OnlineStore_ServiceDesc is the grpc.ServiceDesc for OnlineStore service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var OnlineStore_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "grpc.connector.OnlineStore",
        HandlerType: (*OnlineStoreServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "OnlineRead",
                        Handler:    _OnlineStore_OnlineRead_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "feast/serving/Connector.proto",
}
</pre>
		
		<pre class="file" id="file58" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.31.0
//         protoc        v4.25.1
// source: feast/serving/GrpcServer.proto

package serving

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type PushRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Features           map[string]string `protobuf:"bytes,1,rep,name=features,proto3" json:"features,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        StreamFeatureView  string            `protobuf:"bytes,2,opt,name=stream_feature_view,json=streamFeatureView,proto3" json:"stream_feature_view,omitempty"`
        AllowRegistryCache bool              `protobuf:"varint,3,opt,name=allow_registry_cache,json=allowRegistryCache,proto3" json:"allow_registry_cache,omitempty"`
        To                 string            `protobuf:"bytes,4,opt,name=to,proto3" json:"to,omitempty"`
}

func (x *PushRequest) Reset() <span class="cov0" title="0">{
        *x = PushRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_serving_GrpcServer_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *PushRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*PushRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *PushRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_feast_serving_GrpcServer_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use PushRequest.ProtoReflect.Descriptor instead.
func (*PushRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_serving_GrpcServer_proto_rawDescGZIP(), []int{0}
}</span>

func (x *PushRequest) GetFeatures() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Features
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *PushRequest) GetStreamFeatureView() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.StreamFeatureView
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *PushRequest) GetAllowRegistryCache() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AllowRegistryCache
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *PushRequest) GetTo() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.To
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type PushResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Status bool `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (x *PushResponse) Reset() <span class="cov0" title="0">{
        *x = PushResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_serving_GrpcServer_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *PushResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*PushResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *PushResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_feast_serving_GrpcServer_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use PushResponse.ProtoReflect.Descriptor instead.
func (*PushResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_serving_GrpcServer_proto_rawDescGZIP(), []int{1}
}</span>

func (x *PushResponse) GetStatus() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return false</span>
}

type WriteToOnlineStoreRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Features           map[string]string `protobuf:"bytes,1,rep,name=features,proto3" json:"features,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        FeatureViewName    string            `protobuf:"bytes,2,opt,name=feature_view_name,json=featureViewName,proto3" json:"feature_view_name,omitempty"`
        AllowRegistryCache bool              `protobuf:"varint,3,opt,name=allow_registry_cache,json=allowRegistryCache,proto3" json:"allow_registry_cache,omitempty"`
}

func (x *WriteToOnlineStoreRequest) Reset() <span class="cov0" title="0">{
        *x = WriteToOnlineStoreRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_serving_GrpcServer_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *WriteToOnlineStoreRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*WriteToOnlineStoreRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *WriteToOnlineStoreRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_feast_serving_GrpcServer_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use WriteToOnlineStoreRequest.ProtoReflect.Descriptor instead.
func (*WriteToOnlineStoreRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_serving_GrpcServer_proto_rawDescGZIP(), []int{2}
}</span>

func (x *WriteToOnlineStoreRequest) GetFeatures() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Features
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *WriteToOnlineStoreRequest) GetFeatureViewName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FeatureViewName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *WriteToOnlineStoreRequest) GetAllowRegistryCache() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.AllowRegistryCache
        }</span>
        <span class="cov0" title="0">return false</span>
}

type WriteToOnlineStoreResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Status bool `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (x *WriteToOnlineStoreResponse) Reset() <span class="cov0" title="0">{
        *x = WriteToOnlineStoreResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_serving_GrpcServer_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *WriteToOnlineStoreResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*WriteToOnlineStoreResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *WriteToOnlineStoreResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_feast_serving_GrpcServer_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use WriteToOnlineStoreResponse.ProtoReflect.Descriptor instead.
func (*WriteToOnlineStoreResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_serving_GrpcServer_proto_rawDescGZIP(), []int{3}
}</span>

func (x *WriteToOnlineStoreResponse) GetStatus() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return false</span>
}

var File_feast_serving_GrpcServer_proto protoreflect.FileDescriptor

var file_feast_serving_GrpcServer_proto_rawDesc = []byte{
        0x0a, 0x1e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2f,
        0x47, 0x72, 0x70, 0x63, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x12, 0x0e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72,
        0x1a, 0x22, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2f,
        0x53, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x22, 0x83, 0x02, 0x0a, 0x0b, 0x50, 0x75, 0x73, 0x68, 0x52, 0x65, 0x71,
        0x75, 0x65, 0x73, 0x74, 0x12, 0x45, 0x0a, 0x08, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73,
        0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x29, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x63, 0x6f,
        0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x2e, 0x50, 0x75, 0x73, 0x68, 0x52, 0x65, 0x71, 0x75,
        0x65, 0x73, 0x74, 0x2e, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x45, 0x6e, 0x74, 0x72,
        0x79, 0x52, 0x08, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x12, 0x2e, 0x0a, 0x13, 0x73,
        0x74, 0x72, 0x65, 0x61, 0x6d, 0x5f, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x5f, 0x76, 0x69,
        0x65, 0x77, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x11, 0x73, 0x74, 0x72, 0x65, 0x61, 0x6d,
        0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77, 0x12, 0x30, 0x0a, 0x14, 0x61,
        0x6c, 0x6c, 0x6f, 0x77, 0x5f, 0x72, 0x65, 0x67, 0x69, 0x73, 0x74, 0x72, 0x79, 0x5f, 0x63, 0x61,
        0x63, 0x68, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52, 0x12, 0x61, 0x6c, 0x6c, 0x6f, 0x77,
        0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x72, 0x79, 0x43, 0x61, 0x63, 0x68, 0x65, 0x12, 0x0e, 0x0a,
        0x02, 0x74, 0x6f, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x02, 0x74, 0x6f, 0x1a, 0x3b, 0x0a,
        0x0d, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10,
        0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79,
        0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0x26, 0x0a, 0x0c, 0x50, 0x75,
        0x73, 0x68, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x74,
        0x61, 0x74, 0x75, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x06, 0x73, 0x74, 0x61, 0x74,
        0x75, 0x73, 0x22, 0x8b, 0x02, 0x0a, 0x19, 0x57, 0x72, 0x69, 0x74, 0x65, 0x54, 0x6f, 0x4f, 0x6e,
        0x6c, 0x69, 0x6e, 0x65, 0x53, 0x74, 0x6f, 0x72, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
        0x12, 0x53, 0x0a, 0x08, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03,
        0x28, 0x0b, 0x32, 0x37, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63,
        0x74, 0x6f, 0x72, 0x2e, 0x57, 0x72, 0x69, 0x74, 0x65, 0x54, 0x6f, 0x4f, 0x6e, 0x6c, 0x69, 0x6e,
        0x65, 0x53, 0x74, 0x6f, 0x72, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x2e, 0x46, 0x65,
        0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x08, 0x66, 0x65, 0x61,
        0x74, 0x75, 0x72, 0x65, 0x73, 0x12, 0x2a, 0x0a, 0x11, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65,
        0x5f, 0x76, 0x69, 0x65, 0x77, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09,
        0x52, 0x0f, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65, 0x77, 0x4e, 0x61, 0x6d,
        0x65, 0x12, 0x30, 0x0a, 0x14, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x5f, 0x72, 0x65, 0x67, 0x69, 0x73,
        0x74, 0x72, 0x79, 0x5f, 0x63, 0x61, 0x63, 0x68, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52,
        0x12, 0x61, 0x6c, 0x6c, 0x6f, 0x77, 0x52, 0x65, 0x67, 0x69, 0x73, 0x74, 0x72, 0x79, 0x43, 0x61,
        0x63, 0x68, 0x65, 0x1a, 0x3b, 0x0a, 0x0d, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x45,
        0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28,
        0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18,
        0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01,
        0x22, 0x34, 0x0a, 0x1a, 0x57, 0x72, 0x69, 0x74, 0x65, 0x54, 0x6f, 0x4f, 0x6e, 0x6c, 0x69, 0x6e,
        0x65, 0x53, 0x74, 0x6f, 0x72, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x16,
        0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x08, 0x52, 0x06,
        0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x32, 0xad, 0x02, 0x0a, 0x11, 0x47, 0x72, 0x70, 0x63, 0x46,
        0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x53, 0x65, 0x72, 0x76, 0x65, 0x72, 0x12, 0x43, 0x0a, 0x04,
        0x50, 0x75, 0x73, 0x68, 0x12, 0x1b, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x63, 0x6f, 0x6e, 0x6e,
        0x65, 0x63, 0x74, 0x6f, 0x72, 0x2e, 0x50, 0x75, 0x73, 0x68, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
        0x74, 0x1a, 0x1c, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74,
        0x6f, 0x72, 0x2e, 0x50, 0x75, 0x73, 0x68, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x22,
        0x00, 0x12, 0x6b, 0x0a, 0x12, 0x57, 0x72, 0x69, 0x74, 0x65, 0x54, 0x6f, 0x4f, 0x6e, 0x6c, 0x69,
        0x6e, 0x65, 0x53, 0x74, 0x6f, 0x72, 0x65, 0x12, 0x29, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x63,
        0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x2e, 0x57, 0x72, 0x69, 0x74, 0x65, 0x54, 0x6f,
        0x4f, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x53, 0x74, 0x6f, 0x72, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65,
        0x73, 0x74, 0x1a, 0x2a, 0x2e, 0x67, 0x72, 0x70, 0x63, 0x2e, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63,
        0x74, 0x6f, 0x72, 0x2e, 0x57, 0x72, 0x69, 0x74, 0x65, 0x54, 0x6f, 0x4f, 0x6e, 0x6c, 0x69, 0x6e,
        0x65, 0x53, 0x74, 0x6f, 0x72, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x66,
        0x0a, 0x11, 0x47, 0x65, 0x74, 0x4f, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x46, 0x65, 0x61, 0x74, 0x75,
        0x72, 0x65, 0x73, 0x12, 0x27, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x73, 0x65, 0x72, 0x76,
        0x69, 0x6e, 0x67, 0x2e, 0x47, 0x65, 0x74, 0x4f, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x46, 0x65, 0x61,
        0x74, 0x75, 0x72, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x28, 0x2e, 0x66,
        0x65, 0x61, 0x73, 0x74, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x47, 0x65, 0x74,
        0x4f, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x52, 0x65,
        0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x42, 0x34, 0x5a, 0x32, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62,
        0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2d, 0x64, 0x65, 0x76, 0x2f, 0x66,
        0x65, 0x61, 0x73, 0x74, 0x2f, 0x67, 0x6f, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x73, 0x2f, 0x66,
        0x65, 0x61, 0x73, 0x74, 0x2f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x62, 0x06, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_feast_serving_GrpcServer_proto_rawDescOnce sync.Once
        file_feast_serving_GrpcServer_proto_rawDescData = file_feast_serving_GrpcServer_proto_rawDesc
)

func file_feast_serving_GrpcServer_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_feast_serving_GrpcServer_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_feast_serving_GrpcServer_proto_rawDescData = protoimpl.X.CompressGZIP(file_feast_serving_GrpcServer_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_feast_serving_GrpcServer_proto_rawDescData</span>
}

var file_feast_serving_GrpcServer_proto_msgTypes = make([]protoimpl.MessageInfo, 6)
var file_feast_serving_GrpcServer_proto_goTypes = []interface{}{
        (*PushRequest)(nil),                // 0: grpc.connector.PushRequest
        (*PushResponse)(nil),               // 1: grpc.connector.PushResponse
        (*WriteToOnlineStoreRequest)(nil),  // 2: grpc.connector.WriteToOnlineStoreRequest
        (*WriteToOnlineStoreResponse)(nil), // 3: grpc.connector.WriteToOnlineStoreResponse
        nil,                                // 4: grpc.connector.PushRequest.FeaturesEntry
        nil,                                // 5: grpc.connector.WriteToOnlineStoreRequest.FeaturesEntry
        (*GetOnlineFeaturesRequest)(nil),   // 6: feast.serving.GetOnlineFeaturesRequest
        (*GetOnlineFeaturesResponse)(nil),  // 7: feast.serving.GetOnlineFeaturesResponse
}
var file_feast_serving_GrpcServer_proto_depIdxs = []int32{
        4, // 0: grpc.connector.PushRequest.features:type_name -&gt; grpc.connector.PushRequest.FeaturesEntry
        5, // 1: grpc.connector.WriteToOnlineStoreRequest.features:type_name -&gt; grpc.connector.WriteToOnlineStoreRequest.FeaturesEntry
        0, // 2: grpc.connector.GrpcFeatureServer.Push:input_type -&gt; grpc.connector.PushRequest
        2, // 3: grpc.connector.GrpcFeatureServer.WriteToOnlineStore:input_type -&gt; grpc.connector.WriteToOnlineStoreRequest
        6, // 4: grpc.connector.GrpcFeatureServer.GetOnlineFeatures:input_type -&gt; feast.serving.GetOnlineFeaturesRequest
        1, // 5: grpc.connector.GrpcFeatureServer.Push:output_type -&gt; grpc.connector.PushResponse
        3, // 6: grpc.connector.GrpcFeatureServer.WriteToOnlineStore:output_type -&gt; grpc.connector.WriteToOnlineStoreResponse
        7, // 7: grpc.connector.GrpcFeatureServer.GetOnlineFeatures:output_type -&gt; feast.serving.GetOnlineFeaturesResponse
        5, // [5:8] is the sub-list for method output_type
        2, // [2:5] is the sub-list for method input_type
        2, // [2:2] is the sub-list for extension type_name
        2, // [2:2] is the sub-list for extension extendee
        0, // [0:2] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_feast_serving_GrpcServer_proto_init() }</span>
func file_feast_serving_GrpcServer_proto_init() <span class="cov8" title="1">{
        if File_feast_serving_GrpcServer_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">file_feast_serving_ServingService_proto_init()
        if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_feast_serving_GrpcServer_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*PushRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_serving_GrpcServer_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*PushResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_serving_GrpcServer_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*WriteToOnlineStoreRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_serving_GrpcServer_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*WriteToOnlineStoreResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_feast_serving_GrpcServer_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   6,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_feast_serving_GrpcServer_proto_goTypes,
                DependencyIndexes: file_feast_serving_GrpcServer_proto_depIdxs,
                MessageInfos:      file_feast_serving_GrpcServer_proto_msgTypes,
        }.Build()
        File_feast_serving_GrpcServer_proto = out.File
        file_feast_serving_GrpcServer_proto_rawDesc = nil
        file_feast_serving_GrpcServer_proto_goTypes = nil
        file_feast_serving_GrpcServer_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.25.1
// source: feast/serving/GrpcServer.proto

package serving

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
        GrpcFeatureServer_Push_FullMethodName               = "/grpc.connector.GrpcFeatureServer/Push"
        GrpcFeatureServer_WriteToOnlineStore_FullMethodName = "/grpc.connector.GrpcFeatureServer/WriteToOnlineStore"
        GrpcFeatureServer_GetOnlineFeatures_FullMethodName  = "/grpc.connector.GrpcFeatureServer/GetOnlineFeatures"
)

// GrpcFeatureServerClient is the client API for GrpcFeatureServer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GrpcFeatureServerClient interface {
        Push(ctx context.Context, in *PushRequest, opts ...grpc.CallOption) (*PushResponse, error)
        WriteToOnlineStore(ctx context.Context, in *WriteToOnlineStoreRequest, opts ...grpc.CallOption) (*WriteToOnlineStoreResponse, error)
        GetOnlineFeatures(ctx context.Context, in *GetOnlineFeaturesRequest, opts ...grpc.CallOption) (*GetOnlineFeaturesResponse, error)
}

type grpcFeatureServerClient struct {
        cc grpc.ClientConnInterface
}

func NewGrpcFeatureServerClient(cc grpc.ClientConnInterface) GrpcFeatureServerClient <span class="cov0" title="0">{
        return &amp;grpcFeatureServerClient{cc}
}</span>

func (c *grpcFeatureServerClient) Push(ctx context.Context, in *PushRequest, opts ...grpc.CallOption) (*PushResponse, error) <span class="cov0" title="0">{
        out := new(PushResponse)
        err := c.cc.Invoke(ctx, GrpcFeatureServer_Push_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *grpcFeatureServerClient) WriteToOnlineStore(ctx context.Context, in *WriteToOnlineStoreRequest, opts ...grpc.CallOption) (*WriteToOnlineStoreResponse, error) <span class="cov0" title="0">{
        out := new(WriteToOnlineStoreResponse)
        err := c.cc.Invoke(ctx, GrpcFeatureServer_WriteToOnlineStore_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *grpcFeatureServerClient) GetOnlineFeatures(ctx context.Context, in *GetOnlineFeaturesRequest, opts ...grpc.CallOption) (*GetOnlineFeaturesResponse, error) <span class="cov0" title="0">{
        out := new(GetOnlineFeaturesResponse)
        err := c.cc.Invoke(ctx, GrpcFeatureServer_GetOnlineFeatures_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// GrpcFeatureServerServer is the server API for GrpcFeatureServer service.
// All implementations must embed UnimplementedGrpcFeatureServerServer
// for forward compatibility
type GrpcFeatureServerServer interface {
        Push(context.Context, *PushRequest) (*PushResponse, error)
        WriteToOnlineStore(context.Context, *WriteToOnlineStoreRequest) (*WriteToOnlineStoreResponse, error)
        GetOnlineFeatures(context.Context, *GetOnlineFeaturesRequest) (*GetOnlineFeaturesResponse, error)
        mustEmbedUnimplementedGrpcFeatureServerServer()
}

// UnimplementedGrpcFeatureServerServer must be embedded to have forward compatible implementations.
type UnimplementedGrpcFeatureServerServer struct {
}

func (UnimplementedGrpcFeatureServerServer) Push(context.Context, *PushRequest) (*PushResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method Push not implemented")
}</span>
func (UnimplementedGrpcFeatureServerServer) WriteToOnlineStore(context.Context, *WriteToOnlineStoreRequest) (*WriteToOnlineStoreResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method WriteToOnlineStore not implemented")
}</span>
func (UnimplementedGrpcFeatureServerServer) GetOnlineFeatures(context.Context, *GetOnlineFeaturesRequest) (*GetOnlineFeaturesResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetOnlineFeatures not implemented")
}</span>
func (UnimplementedGrpcFeatureServerServer) mustEmbedUnimplementedGrpcFeatureServerServer() {<span class="cov0" title="0">}</span>

// UnsafeGrpcFeatureServerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GrpcFeatureServerServer will
// result in compilation errors.
type UnsafeGrpcFeatureServerServer interface {
        mustEmbedUnimplementedGrpcFeatureServerServer()
}

func RegisterGrpcFeatureServerServer(s grpc.ServiceRegistrar, srv GrpcFeatureServerServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;GrpcFeatureServer_ServiceDesc, srv)
}</span>

func _GrpcFeatureServer_Push_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(PushRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(GrpcFeatureServerServer).Push(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: GrpcFeatureServer_Push_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(GrpcFeatureServerServer).Push(ctx, req.(*PushRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _GrpcFeatureServer_WriteToOnlineStore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(WriteToOnlineStoreRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(GrpcFeatureServerServer).WriteToOnlineStore(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: GrpcFeatureServer_WriteToOnlineStore_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(GrpcFeatureServerServer).WriteToOnlineStore(ctx, req.(*WriteToOnlineStoreRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _GrpcFeatureServer_GetOnlineFeatures_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetOnlineFeaturesRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(GrpcFeatureServerServer).GetOnlineFeatures(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: GrpcFeatureServer_GetOnlineFeatures_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(GrpcFeatureServerServer).GetOnlineFeatures(ctx, req.(*GetOnlineFeaturesRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// GrpcFeatureServer_ServiceDesc is the grpc.ServiceDesc for GrpcFeatureServer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GrpcFeatureServer_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "grpc.connector.GrpcFeatureServer",
        HandlerType: (*GrpcFeatureServerServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "Push",
                        Handler:    _GrpcFeatureServer_Push_Handler,
                },
                {
                        MethodName: "WriteToOnlineStore",
                        Handler:    _GrpcFeatureServer_WriteToOnlineStore_Handler,
                },
                {
                        MethodName: "GetOnlineFeatures",
                        Handler:    _GrpcFeatureServer_GetOnlineFeatures_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "feast/serving/GrpcServer.proto",
}
</pre>
		
		<pre class="file" id="file60" style="display: none">//
// Copyright 2018 The Feast Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.31.0
//         protoc        v4.25.1
// source: feast/serving/ServingService.proto

package serving

import (
        types "github.com/feast-dev/feast/go/protos/feast/types"
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        timestamppb "google.golang.org/protobuf/types/known/timestamppb"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type FieldStatus int32

const (
        // Status is unset for this field.
        FieldStatus_INVALID FieldStatus = 0
        // Field value is present for this field and age is within max age.
        FieldStatus_PRESENT FieldStatus = 1
        // Values could be found for entity key and age is within max age, but
        // this field value is not assigned a value on ingestion into feast.
        FieldStatus_NULL_VALUE FieldStatus = 2
        // Entity key did not return any values as they do not exist in Feast.
        // This could suggest that the feature values have not yet been ingested
        // into feast or the ingestion failed.
        FieldStatus_NOT_FOUND FieldStatus = 3
        // Values could be found for entity key, but field values are outside the maximum
        // allowable range.
        FieldStatus_OUTSIDE_MAX_AGE FieldStatus = 4
)

// Enum value maps for FieldStatus.
var (
        FieldStatus_name = map[int32]string{
                0: "INVALID",
                1: "PRESENT",
                2: "NULL_VALUE",
                3: "NOT_FOUND",
                4: "OUTSIDE_MAX_AGE",
        }
        FieldStatus_value = map[string]int32{
                "INVALID":         0,
                "PRESENT":         1,
                "NULL_VALUE":      2,
                "NOT_FOUND":       3,
                "OUTSIDE_MAX_AGE": 4,
        }
)

func (x FieldStatus) Enum() *FieldStatus <span class="cov0" title="0">{
        p := new(FieldStatus)
        *p = x
        return p
}</span>

func (x FieldStatus) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (FieldStatus) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_feast_serving_ServingService_proto_enumTypes[0].Descriptor()
}</span>

func (FieldStatus) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_feast_serving_ServingService_proto_enumTypes[0]
}</span>

func (x FieldStatus) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use FieldStatus.Descriptor instead.
func (FieldStatus) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_serving_ServingService_proto_rawDescGZIP(), []int{0}
}</span>

type GetFeastServingInfoRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *GetFeastServingInfoRequest) Reset() <span class="cov8" title="1">{
        *x = GetFeastServingInfoRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov8" title="1">{
                mi := &amp;file_feast_serving_ServingService_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetFeastServingInfoRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetFeastServingInfoRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetFeastServingInfoRequest) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_serving_ServingService_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov8" title="1">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov8" title="1">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov8" title="1">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetFeastServingInfoRequest.ProtoReflect.Descriptor instead.
func (*GetFeastServingInfoRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_serving_ServingService_proto_rawDescGZIP(), []int{0}
}</span>

type GetFeastServingInfoResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Feast version of this serving deployment.
        Version string `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
}

func (x *GetFeastServingInfoResponse) Reset() <span class="cov8" title="1">{
        *x = GetFeastServingInfoResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov8" title="1">{
                mi := &amp;file_feast_serving_ServingService_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetFeastServingInfoResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetFeastServingInfoResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetFeastServingInfoResponse) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_serving_ServingService_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov8" title="1">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov8" title="1">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov8" title="1">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetFeastServingInfoResponse.ProtoReflect.Descriptor instead.
func (*GetFeastServingInfoResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_serving_ServingService_proto_rawDescGZIP(), []int{1}
}</span>

func (x *GetFeastServingInfoResponse) GetVersion() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Version
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type FeatureReferenceV2 struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Name of the Feature View to retrieve the feature from.
        FeatureViewName string `protobuf:"bytes,1,opt,name=feature_view_name,json=featureViewName,proto3" json:"feature_view_name,omitempty"`
        // Name of the Feature to retrieve the feature from.
        FeatureName string `protobuf:"bytes,2,opt,name=feature_name,json=featureName,proto3" json:"feature_name,omitempty"`
}

func (x *FeatureReferenceV2) Reset() <span class="cov0" title="0">{
        *x = FeatureReferenceV2{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_serving_ServingService_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *FeatureReferenceV2) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FeatureReferenceV2) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FeatureReferenceV2) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_feast_serving_ServingService_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use FeatureReferenceV2.ProtoReflect.Descriptor instead.
func (*FeatureReferenceV2) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_serving_ServingService_proto_rawDescGZIP(), []int{2}
}</span>

func (x *FeatureReferenceV2) GetFeatureViewName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FeatureViewName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *FeatureReferenceV2) GetFeatureName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FeatureName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// ToDo (oleksii): remove this message (since it's not used) and move EntityRow on package level
type GetOnlineFeaturesRequestV2 struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // List of features that are being retrieved
        Features []*FeatureReferenceV2 `protobuf:"bytes,4,rep,name=features,proto3" json:"features,omitempty"`
        // List of entity rows, containing entity id and timestamp data.
        // Used during retrieval of feature rows and for joining feature
        // rows into a final dataset
        EntityRows []*GetOnlineFeaturesRequestV2_EntityRow `protobuf:"bytes,2,rep,name=entity_rows,json=entityRows,proto3" json:"entity_rows,omitempty"`
        // Optional field to specify project name override. If specified, uses the
        // given project for retrieval. Overrides the projects specified in
        // Feature References if both are specified.
        Project string `protobuf:"bytes,5,opt,name=project,proto3" json:"project,omitempty"`
}

func (x *GetOnlineFeaturesRequestV2) Reset() <span class="cov0" title="0">{
        *x = GetOnlineFeaturesRequestV2{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_serving_ServingService_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetOnlineFeaturesRequestV2) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetOnlineFeaturesRequestV2) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetOnlineFeaturesRequestV2) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_feast_serving_ServingService_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetOnlineFeaturesRequestV2.ProtoReflect.Descriptor instead.
func (*GetOnlineFeaturesRequestV2) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_serving_ServingService_proto_rawDescGZIP(), []int{3}
}</span>

func (x *GetOnlineFeaturesRequestV2) GetFeatures() []*FeatureReferenceV2 <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Features
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetOnlineFeaturesRequestV2) GetEntityRows() []*GetOnlineFeaturesRequestV2_EntityRow <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.EntityRows
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetOnlineFeaturesRequestV2) GetProject() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Project
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// In JSON "val" field can be omitted
type FeatureList struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Val []string `protobuf:"bytes,1,rep,name=val,proto3" json:"val,omitempty"`
}

func (x *FeatureList) Reset() <span class="cov0" title="0">{
        *x = FeatureList{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_serving_ServingService_proto_msgTypes[4]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *FeatureList) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FeatureList) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FeatureList) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_serving_ServingService_proto_msgTypes[4]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use FeatureList.ProtoReflect.Descriptor instead.
func (*FeatureList) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_serving_ServingService_proto_rawDescGZIP(), []int{4}
}</span>

func (x *FeatureList) GetVal() []string <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.Val
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetOnlineFeaturesRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Types that are assignable to Kind:
        //
        //        *GetOnlineFeaturesRequest_FeatureService
        //        *GetOnlineFeaturesRequest_Features
        Kind isGetOnlineFeaturesRequest_Kind `protobuf_oneof:"kind"`
        // The entity data is specified in a columnar format
        // A map of entity name -&gt; list of values
        Entities         map[string]*types.RepeatedValue `protobuf:"bytes,3,rep,name=entities,proto3" json:"entities,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        FullFeatureNames bool                            `protobuf:"varint,4,opt,name=full_feature_names,json=fullFeatureNames,proto3" json:"full_feature_names,omitempty"`
        // Context for OnDemand Feature Transformation
        // (was moved to dedicated parameter to avoid unnecessary separation logic on serving side)
        // A map of variable name -&gt; list of values
        RequestContext map[string]*types.RepeatedValue `protobuf:"bytes,5,rep,name=request_context,json=requestContext,proto3" json:"request_context,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (x *GetOnlineFeaturesRequest) Reset() <span class="cov8" title="1">{
        *x = GetOnlineFeaturesRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov8" title="1">{
                mi := &amp;file_feast_serving_ServingService_proto_msgTypes[5]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetOnlineFeaturesRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetOnlineFeaturesRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetOnlineFeaturesRequest) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_serving_ServingService_proto_msgTypes[5]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov8" title="1">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov8" title="1">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov8" title="1">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetOnlineFeaturesRequest.ProtoReflect.Descriptor instead.
func (*GetOnlineFeaturesRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_serving_ServingService_proto_rawDescGZIP(), []int{5}
}</span>

func (m *GetOnlineFeaturesRequest) GetKind() isGetOnlineFeaturesRequest_Kind <span class="cov8" title="1">{
        if m != nil </span><span class="cov8" title="1">{
                return m.Kind
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetOnlineFeaturesRequest) GetFeatureService() string <span class="cov0" title="0">{
        if x, ok := x.GetKind().(*GetOnlineFeaturesRequest_FeatureService); ok </span><span class="cov0" title="0">{
                return x.FeatureService
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetOnlineFeaturesRequest) GetFeatures() *FeatureList <span class="cov0" title="0">{
        if x, ok := x.GetKind().(*GetOnlineFeaturesRequest_Features); ok </span><span class="cov0" title="0">{
                return x.Features
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetOnlineFeaturesRequest) GetEntities() map[string]*types.RepeatedValue <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.Entities
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetOnlineFeaturesRequest) GetFullFeatureNames() bool <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.FullFeatureNames
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *GetOnlineFeaturesRequest) GetRequestContext() map[string]*types.RepeatedValue <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.RequestContext
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type isGetOnlineFeaturesRequest_Kind interface {
        isGetOnlineFeaturesRequest_Kind()
}

type GetOnlineFeaturesRequest_FeatureService struct {
        FeatureService string `protobuf:"bytes,1,opt,name=feature_service,json=featureService,proto3,oneof"`
}

type GetOnlineFeaturesRequest_Features struct {
        Features *FeatureList `protobuf:"bytes,2,opt,name=features,proto3,oneof"`
}

func (*GetOnlineFeaturesRequest_FeatureService) isGetOnlineFeaturesRequest_Kind() {<span class="cov0" title="0">}</span>

func (*GetOnlineFeaturesRequest_Features) isGetOnlineFeaturesRequest_Kind() {<span class="cov0" title="0">}</span>

type GetOnlineFeaturesResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Metadata *GetOnlineFeaturesResponseMetadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
        // Length of "results" array should match length of requested features.
        // We also preserve the same order of features here as in metadata.feature_names
        Results []*GetOnlineFeaturesResponse_FeatureVector `protobuf:"bytes,2,rep,name=results,proto3" json:"results,omitempty"`
        Status  bool                                       `protobuf:"varint,3,opt,name=status,proto3" json:"status,omitempty"`
}

func (x *GetOnlineFeaturesResponse) Reset() <span class="cov8" title="1">{
        *x = GetOnlineFeaturesResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov8" title="1">{
                mi := &amp;file_feast_serving_ServingService_proto_msgTypes[6]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetOnlineFeaturesResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetOnlineFeaturesResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetOnlineFeaturesResponse) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_serving_ServingService_proto_msgTypes[6]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov8" title="1">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov8" title="1">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov8" title="1">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetOnlineFeaturesResponse.ProtoReflect.Descriptor instead.
func (*GetOnlineFeaturesResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_serving_ServingService_proto_rawDescGZIP(), []int{6}
}</span>

func (x *GetOnlineFeaturesResponse) GetMetadata() *GetOnlineFeaturesResponseMetadata <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Metadata
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetOnlineFeaturesResponse) GetResults() []*GetOnlineFeaturesResponse_FeatureVector <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Results
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetOnlineFeaturesResponse) GetStatus() bool <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Status
        }</span>
        <span class="cov0" title="0">return false</span>
}

type GetOnlineFeaturesResponseMetadata struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        FeatureNames *FeatureList `protobuf:"bytes,1,opt,name=feature_names,json=featureNames,proto3" json:"feature_names,omitempty"`
}

func (x *GetOnlineFeaturesResponseMetadata) Reset() <span class="cov0" title="0">{
        *x = GetOnlineFeaturesResponseMetadata{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_serving_ServingService_proto_msgTypes[7]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetOnlineFeaturesResponseMetadata) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetOnlineFeaturesResponseMetadata) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetOnlineFeaturesResponseMetadata) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_serving_ServingService_proto_msgTypes[7]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetOnlineFeaturesResponseMetadata.ProtoReflect.Descriptor instead.
func (*GetOnlineFeaturesResponseMetadata) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_serving_ServingService_proto_rawDescGZIP(), []int{7}
}</span>

func (x *GetOnlineFeaturesResponseMetadata) GetFeatureNames() *FeatureList <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.FeatureNames
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetOnlineFeaturesRequestV2_EntityRow struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Request timestamp of this row. This value will be used,
        // together with maxAge, to determine feature staleness.
        Timestamp *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
        // Map containing mapping of entity name to entity value.
        Fields map[string]*types.Value `protobuf:"bytes,2,rep,name=fields,proto3" json:"fields,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (x *GetOnlineFeaturesRequestV2_EntityRow) Reset() <span class="cov0" title="0">{
        *x = GetOnlineFeaturesRequestV2_EntityRow{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_serving_ServingService_proto_msgTypes[8]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetOnlineFeaturesRequestV2_EntityRow) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetOnlineFeaturesRequestV2_EntityRow) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetOnlineFeaturesRequestV2_EntityRow) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_feast_serving_ServingService_proto_msgTypes[8]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetOnlineFeaturesRequestV2_EntityRow.ProtoReflect.Descriptor instead.
func (*GetOnlineFeaturesRequestV2_EntityRow) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_serving_ServingService_proto_rawDescGZIP(), []int{3, 0}
}</span>

func (x *GetOnlineFeaturesRequestV2_EntityRow) GetTimestamp() *timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Timestamp
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetOnlineFeaturesRequestV2_EntityRow) GetFields() map[string]*types.Value <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Fields
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type GetOnlineFeaturesResponse_FeatureVector struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Values          []*types.Value           `protobuf:"bytes,1,rep,name=values,proto3" json:"values,omitempty"`
        Statuses        []FieldStatus            `protobuf:"varint,2,rep,packed,name=statuses,proto3,enum=feast.serving.FieldStatus" json:"statuses,omitempty"`
        EventTimestamps []*timestamppb.Timestamp `protobuf:"bytes,3,rep,name=event_timestamps,json=eventTimestamps,proto3" json:"event_timestamps,omitempty"`
}

func (x *GetOnlineFeaturesResponse_FeatureVector) Reset() <span class="cov0" title="0">{
        *x = GetOnlineFeaturesResponse_FeatureVector{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_serving_ServingService_proto_msgTypes[12]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetOnlineFeaturesResponse_FeatureVector) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetOnlineFeaturesResponse_FeatureVector) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetOnlineFeaturesResponse_FeatureVector) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_serving_ServingService_proto_msgTypes[12]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetOnlineFeaturesResponse_FeatureVector.ProtoReflect.Descriptor instead.
func (*GetOnlineFeaturesResponse_FeatureVector) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_serving_ServingService_proto_rawDescGZIP(), []int{6, 0}
}</span>

func (x *GetOnlineFeaturesResponse_FeatureVector) GetValues() []*types.Value <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Values
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetOnlineFeaturesResponse_FeatureVector) GetStatuses() []FieldStatus <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Statuses
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *GetOnlineFeaturesResponse_FeatureVector) GetEventTimestamps() []*timestamppb.Timestamp <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.EventTimestamps
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_feast_serving_ServingService_proto protoreflect.FileDescriptor

var file_feast_serving_ServingService_proto_rawDesc = []byte{
        0x0a, 0x22, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2f,
        0x53, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0d, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x73, 0x65, 0x72, 0x76,
        0x69, 0x6e, 0x67, 0x1a, 0x1f, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74,
        0x6f, 0x62, 0x75, 0x66, 0x2f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x17, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x74, 0x79, 0x70, 0x65,
        0x73, 0x2f, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x1c, 0x0a,
        0x1a, 0x47, 0x65, 0x74, 0x46, 0x65, 0x61, 0x73, 0x74, 0x53, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67,
        0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0x37, 0x0a, 0x1b, 0x47,
        0x65, 0x74, 0x46, 0x65, 0x61, 0x73, 0x74, 0x53, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x49, 0x6e,
        0x66, 0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x76, 0x65,
        0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x76, 0x65, 0x72,
        0x73, 0x69, 0x6f, 0x6e, 0x22, 0x63, 0x0a, 0x12, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x52,
        0x65, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x63, 0x65, 0x56, 0x32, 0x12, 0x2a, 0x0a, 0x11, 0x66, 0x65,
        0x61, 0x74, 0x75, 0x72, 0x65, 0x5f, 0x76, 0x69, 0x65, 0x77, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18,
        0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0f, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69,
        0x65, 0x77, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x21, 0x0a, 0x0c, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72,
        0x65, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x66, 0x65,
        0x61, 0x74, 0x75, 0x72, 0x65, 0x4e, 0x61, 0x6d, 0x65, 0x22, 0xbb, 0x03, 0x0a, 0x1a, 0x47, 0x65,
        0x74, 0x4f, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x52,
        0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x56, 0x32, 0x12, 0x3d, 0x0a, 0x08, 0x66, 0x65, 0x61, 0x74,
        0x75, 0x72, 0x65, 0x73, 0x18, 0x04, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x66, 0x65, 0x61,
        0x73, 0x74, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x46, 0x65, 0x61, 0x74, 0x75,
        0x72, 0x65, 0x52, 0x65, 0x66, 0x65, 0x72, 0x65, 0x6e, 0x63, 0x65, 0x56, 0x32, 0x52, 0x08, 0x66,
        0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x12, 0x54, 0x0a, 0x0b, 0x65, 0x6e, 0x74, 0x69, 0x74,
        0x79, 0x5f, 0x72, 0x6f, 0x77, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x33, 0x2e, 0x66,
        0x65, 0x61, 0x73, 0x74, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x47, 0x65, 0x74,
        0x4f, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x52, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x56, 0x32, 0x2e, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x52, 0x6f,
        0x77, 0x52, 0x0a, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x52, 0x6f, 0x77, 0x73, 0x12, 0x18, 0x0a,
        0x07, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x18, 0x05, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07,
        0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x1a, 0xed, 0x01, 0x0a, 0x09, 0x45, 0x6e, 0x74, 0x69,
        0x74, 0x79, 0x52, 0x6f, 0x77, 0x12, 0x38, 0x0a, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61,
        0x6d, 0x70, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c,
        0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73,
        0x74, 0x61, 0x6d, 0x70, 0x52, 0x09, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x12,
        0x57, 0x0a, 0x06, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32,
        0x3f, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e,
        0x47, 0x65, 0x74, 0x4f, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65,
        0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x56, 0x32, 0x2e, 0x45, 0x6e, 0x74, 0x69, 0x74,
        0x79, 0x52, 0x6f, 0x77, 0x2e, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79,
        0x52, 0x06, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x73, 0x1a, 0x4d, 0x0a, 0x0b, 0x46, 0x69, 0x65, 0x6c,
        0x64, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x28, 0x0a, 0x05, 0x76, 0x61, 0x6c,
        0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74,
        0x2e, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x05, 0x76, 0x61,
        0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x22, 0x1f, 0x0a, 0x0b, 0x46, 0x65, 0x61, 0x74, 0x75,
        0x72, 0x65, 0x4c, 0x69, 0x73, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x76, 0x61, 0x6c, 0x18, 0x01, 0x20,
        0x03, 0x28, 0x09, 0x52, 0x03, 0x76, 0x61, 0x6c, 0x22, 0xa6, 0x04, 0x0a, 0x18, 0x47, 0x65, 0x74,
        0x4f, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x52, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x29, 0x0a, 0x0f, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65,
        0x5f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x48, 0x00,
        0x52, 0x0e, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65,
        0x12, 0x38, 0x0a, 0x08, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x18, 0x02, 0x20, 0x01,
        0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69,
        0x6e, 0x67, 0x2e, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x4c, 0x69, 0x73, 0x74, 0x48, 0x00,
        0x52, 0x08, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x12, 0x51, 0x0a, 0x08, 0x65, 0x6e,
        0x74, 0x69, 0x74, 0x69, 0x65, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x35, 0x2e, 0x66,
        0x65, 0x61, 0x73, 0x74, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x47, 0x65, 0x74,
        0x4f, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x52, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x2e, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x69, 0x65, 0x73, 0x45, 0x6e,
        0x74, 0x72, 0x79, 0x52, 0x08, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x69, 0x65, 0x73, 0x12, 0x2c, 0x0a,
        0x12, 0x66, 0x75, 0x6c, 0x6c, 0x5f, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x5f, 0x6e, 0x61,
        0x6d, 0x65, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x10, 0x66, 0x75, 0x6c, 0x6c, 0x46,
        0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x4e, 0x61, 0x6d, 0x65, 0x73, 0x12, 0x64, 0x0a, 0x0f, 0x72,
        0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x5f, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x18, 0x05,
        0x20, 0x03, 0x28, 0x0b, 0x32, 0x3b, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x73, 0x65, 0x72,
        0x76, 0x69, 0x6e, 0x67, 0x2e, 0x47, 0x65, 0x74, 0x4f, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x46, 0x65,
        0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x2e, 0x52, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x45, 0x6e, 0x74, 0x72,
        0x79, 0x52, 0x0e, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78,
        0x74, 0x1a, 0x57, 0x0a, 0x0d, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x69, 0x65, 0x73, 0x45, 0x6e, 0x74,
        0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52,
        0x03, 0x6b, 0x65, 0x79, 0x12, 0x30, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20,
        0x01, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x74, 0x79, 0x70, 0x65,
        0x73, 0x2e, 0x52, 0x65, 0x70, 0x65, 0x61, 0x74, 0x65, 0x64, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52,
        0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x1a, 0x5d, 0x0a, 0x13, 0x52, 0x65,
        0x71, 0x75, 0x65, 0x73, 0x74, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x45, 0x6e, 0x74, 0x72,
        0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03,
        0x6b, 0x65, 0x79, 0x12, 0x30, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01,
        0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x74, 0x79, 0x70, 0x65, 0x73,
        0x2e, 0x52, 0x65, 0x70, 0x65, 0x61, 0x74, 0x65, 0x64, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x05,
        0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x42, 0x06, 0x0a, 0x04, 0x6b, 0x69, 0x6e,
        0x64, 0x22, 0x90, 0x03, 0x0a, 0x19, 0x47, 0x65, 0x74, 0x4f, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x46,
        0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12,
        0x4c, 0x0a, 0x08, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x18, 0x01, 0x20, 0x01, 0x28,
        0x0b, 0x32, 0x30, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e,
        0x67, 0x2e, 0x47, 0x65, 0x74, 0x4f, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x46, 0x65, 0x61, 0x74, 0x75,
        0x72, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x4d, 0x65, 0x74, 0x61, 0x64,
        0x61, 0x74, 0x61, 0x52, 0x08, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x12, 0x50, 0x0a,
        0x07, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x36,
        0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x47,
        0x65, 0x74, 0x4f, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73,
        0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65,
        0x56, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x52, 0x07, 0x72, 0x65, 0x73, 0x75, 0x6c, 0x74, 0x73, 0x12,
        0x16, 0x0a, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52,
        0x06, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x1a, 0xba, 0x01, 0x0a, 0x0d, 0x46, 0x65, 0x61, 0x74,
        0x75, 0x72, 0x65, 0x56, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x12, 0x2a, 0x0a, 0x06, 0x76, 0x61, 0x6c,
        0x75, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x66, 0x65, 0x61, 0x73,
        0x74, 0x2e, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x06, 0x76,
        0x61, 0x6c, 0x75, 0x65, 0x73, 0x12, 0x36, 0x0a, 0x08, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x65,
        0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0e, 0x32, 0x1a, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e,
        0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x53, 0x74, 0x61,
        0x74, 0x75, 0x73, 0x52, 0x08, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x65, 0x73, 0x12, 0x45, 0x0a,
        0x10, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x5f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70,
        0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65,
        0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74,
        0x61, 0x6d, 0x70, 0x52, 0x0f, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74,
        0x61, 0x6d, 0x70, 0x73, 0x22, 0x64, 0x0a, 0x21, 0x47, 0x65, 0x74, 0x4f, 0x6e, 0x6c, 0x69, 0x6e,
        0x65, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73,
        0x65, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x12, 0x3f, 0x0a, 0x0d, 0x66, 0x65, 0x61,
        0x74, 0x75, 0x72, 0x65, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b,
        0x32, 0x1a, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67,
        0x2e, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x4c, 0x69, 0x73, 0x74, 0x52, 0x0c, 0x66, 0x65,
        0x61, 0x74, 0x75, 0x72, 0x65, 0x4e, 0x61, 0x6d, 0x65, 0x73, 0x2a, 0x5b, 0x0a, 0x0b, 0x46, 0x69,
        0x65, 0x6c, 0x64, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x0b, 0x0a, 0x07, 0x49, 0x4e, 0x56,
        0x41, 0x4c, 0x49, 0x44, 0x10, 0x00, 0x12, 0x0b, 0x0a, 0x07, 0x50, 0x52, 0x45, 0x53, 0x45, 0x4e,
        0x54, 0x10, 0x01, 0x12, 0x0e, 0x0a, 0x0a, 0x4e, 0x55, 0x4c, 0x4c, 0x5f, 0x56, 0x41, 0x4c, 0x55,
        0x45, 0x10, 0x02, 0x12, 0x0d, 0x0a, 0x09, 0x4e, 0x4f, 0x54, 0x5f, 0x46, 0x4f, 0x55, 0x4e, 0x44,
        0x10, 0x03, 0x12, 0x13, 0x0a, 0x0f, 0x4f, 0x55, 0x54, 0x53, 0x49, 0x44, 0x45, 0x5f, 0x4d, 0x41,
        0x58, 0x5f, 0x41, 0x47, 0x45, 0x10, 0x04, 0x32, 0xe6, 0x01, 0x0a, 0x0e, 0x53, 0x65, 0x72, 0x76,
        0x69, 0x6e, 0x67, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x6c, 0x0a, 0x13, 0x47, 0x65,
        0x74, 0x46, 0x65, 0x61, 0x73, 0x74, 0x53, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x49, 0x6e, 0x66,
        0x6f, 0x12, 0x29, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e,
        0x67, 0x2e, 0x47, 0x65, 0x74, 0x46, 0x65, 0x61, 0x73, 0x74, 0x53, 0x65, 0x72, 0x76, 0x69, 0x6e,
        0x67, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x2a, 0x2e, 0x66,
        0x65, 0x61, 0x73, 0x74, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x47, 0x65, 0x74,
        0x46, 0x65, 0x61, 0x73, 0x74, 0x53, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x49, 0x6e, 0x66, 0x6f,
        0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x66, 0x0a, 0x11, 0x47, 0x65, 0x74, 0x4f,
        0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x12, 0x27, 0x2e,
        0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x47, 0x65,
        0x74, 0x4f, 0x6e, 0x6c, 0x69, 0x6e, 0x65, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x52,
        0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x28, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x73,
        0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x47, 0x65, 0x74, 0x4f, 0x6e, 0x6c, 0x69, 0x6e, 0x65,
        0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
        0x42, 0x5a, 0x0a, 0x13, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e,
        0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x42, 0x0f, 0x53, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67,
        0x41, 0x50, 0x49, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x5a, 0x32, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62,
        0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2d, 0x64, 0x65, 0x76, 0x2f, 0x66,
        0x65, 0x61, 0x73, 0x74, 0x2f, 0x67, 0x6f, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x73, 0x2f, 0x66,
        0x65, 0x61, 0x73, 0x74, 0x2f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x62, 0x06, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_feast_serving_ServingService_proto_rawDescOnce sync.Once
        file_feast_serving_ServingService_proto_rawDescData = file_feast_serving_ServingService_proto_rawDesc
)

func file_feast_serving_ServingService_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_feast_serving_ServingService_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_feast_serving_ServingService_proto_rawDescData = protoimpl.X.CompressGZIP(file_feast_serving_ServingService_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_feast_serving_ServingService_proto_rawDescData</span>
}

var file_feast_serving_ServingService_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_feast_serving_ServingService_proto_msgTypes = make([]protoimpl.MessageInfo, 13)
var file_feast_serving_ServingService_proto_goTypes = []interface{}{
        (FieldStatus)(0),                             // 0: feast.serving.FieldStatus
        (*GetFeastServingInfoRequest)(nil),           // 1: feast.serving.GetFeastServingInfoRequest
        (*GetFeastServingInfoResponse)(nil),          // 2: feast.serving.GetFeastServingInfoResponse
        (*FeatureReferenceV2)(nil),                   // 3: feast.serving.FeatureReferenceV2
        (*GetOnlineFeaturesRequestV2)(nil),           // 4: feast.serving.GetOnlineFeaturesRequestV2
        (*FeatureList)(nil),                          // 5: feast.serving.FeatureList
        (*GetOnlineFeaturesRequest)(nil),             // 6: feast.serving.GetOnlineFeaturesRequest
        (*GetOnlineFeaturesResponse)(nil),            // 7: feast.serving.GetOnlineFeaturesResponse
        (*GetOnlineFeaturesResponseMetadata)(nil),    // 8: feast.serving.GetOnlineFeaturesResponseMetadata
        (*GetOnlineFeaturesRequestV2_EntityRow)(nil), // 9: feast.serving.GetOnlineFeaturesRequestV2.EntityRow
        nil, // 10: feast.serving.GetOnlineFeaturesRequestV2.EntityRow.FieldsEntry
        nil, // 11: feast.serving.GetOnlineFeaturesRequest.EntitiesEntry
        nil, // 12: feast.serving.GetOnlineFeaturesRequest.RequestContextEntry
        (*GetOnlineFeaturesResponse_FeatureVector)(nil), // 13: feast.serving.GetOnlineFeaturesResponse.FeatureVector
        (*timestamppb.Timestamp)(nil),                   // 14: google.protobuf.Timestamp
        (*types.Value)(nil),                             // 15: feast.types.Value
        (*types.RepeatedValue)(nil),                     // 16: feast.types.RepeatedValue
}
var file_feast_serving_ServingService_proto_depIdxs = []int32{
        3,  // 0: feast.serving.GetOnlineFeaturesRequestV2.features:type_name -&gt; feast.serving.FeatureReferenceV2
        9,  // 1: feast.serving.GetOnlineFeaturesRequestV2.entity_rows:type_name -&gt; feast.serving.GetOnlineFeaturesRequestV2.EntityRow
        5,  // 2: feast.serving.GetOnlineFeaturesRequest.features:type_name -&gt; feast.serving.FeatureList
        11, // 3: feast.serving.GetOnlineFeaturesRequest.entities:type_name -&gt; feast.serving.GetOnlineFeaturesRequest.EntitiesEntry
        12, // 4: feast.serving.GetOnlineFeaturesRequest.request_context:type_name -&gt; feast.serving.GetOnlineFeaturesRequest.RequestContextEntry
        8,  // 5: feast.serving.GetOnlineFeaturesResponse.metadata:type_name -&gt; feast.serving.GetOnlineFeaturesResponseMetadata
        13, // 6: feast.serving.GetOnlineFeaturesResponse.results:type_name -&gt; feast.serving.GetOnlineFeaturesResponse.FeatureVector
        5,  // 7: feast.serving.GetOnlineFeaturesResponseMetadata.feature_names:type_name -&gt; feast.serving.FeatureList
        14, // 8: feast.serving.GetOnlineFeaturesRequestV2.EntityRow.timestamp:type_name -&gt; google.protobuf.Timestamp
        10, // 9: feast.serving.GetOnlineFeaturesRequestV2.EntityRow.fields:type_name -&gt; feast.serving.GetOnlineFeaturesRequestV2.EntityRow.FieldsEntry
        15, // 10: feast.serving.GetOnlineFeaturesRequestV2.EntityRow.FieldsEntry.value:type_name -&gt; feast.types.Value
        16, // 11: feast.serving.GetOnlineFeaturesRequest.EntitiesEntry.value:type_name -&gt; feast.types.RepeatedValue
        16, // 12: feast.serving.GetOnlineFeaturesRequest.RequestContextEntry.value:type_name -&gt; feast.types.RepeatedValue
        15, // 13: feast.serving.GetOnlineFeaturesResponse.FeatureVector.values:type_name -&gt; feast.types.Value
        0,  // 14: feast.serving.GetOnlineFeaturesResponse.FeatureVector.statuses:type_name -&gt; feast.serving.FieldStatus
        14, // 15: feast.serving.GetOnlineFeaturesResponse.FeatureVector.event_timestamps:type_name -&gt; google.protobuf.Timestamp
        1,  // 16: feast.serving.ServingService.GetFeastServingInfo:input_type -&gt; feast.serving.GetFeastServingInfoRequest
        6,  // 17: feast.serving.ServingService.GetOnlineFeatures:input_type -&gt; feast.serving.GetOnlineFeaturesRequest
        2,  // 18: feast.serving.ServingService.GetFeastServingInfo:output_type -&gt; feast.serving.GetFeastServingInfoResponse
        7,  // 19: feast.serving.ServingService.GetOnlineFeatures:output_type -&gt; feast.serving.GetOnlineFeaturesResponse
        18, // [18:20] is the sub-list for method output_type
        16, // [16:18] is the sub-list for method input_type
        16, // [16:16] is the sub-list for extension type_name
        16, // [16:16] is the sub-list for extension extendee
        0,  // [0:16] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_feast_serving_ServingService_proto_init() }</span>
func file_feast_serving_ServingService_proto_init() <span class="cov8" title="1">{
        if File_feast_serving_ServingService_proto != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_feast_serving_ServingService_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GetFeastServingInfoRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_serving_ServingService_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GetFeastServingInfoResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_serving_ServingService_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*FeatureReferenceV2); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_serving_ServingService_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GetOnlineFeaturesRequestV2); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_serving_ServingService_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*FeatureList); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_serving_ServingService_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GetOnlineFeaturesRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_serving_ServingService_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GetOnlineFeaturesResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_serving_ServingService_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GetOnlineFeaturesResponseMetadata); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_serving_ServingService_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GetOnlineFeaturesRequestV2_EntityRow); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_serving_ServingService_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GetOnlineFeaturesResponse_FeatureVector); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">file_feast_serving_ServingService_proto_msgTypes[5].OneofWrappers = []interface{}{
                (*GetOnlineFeaturesRequest_FeatureService)(nil),
                (*GetOnlineFeaturesRequest_Features)(nil),
        }
        type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_feast_serving_ServingService_proto_rawDesc,
                        NumEnums:      1,
                        NumMessages:   13,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_feast_serving_ServingService_proto_goTypes,
                DependencyIndexes: file_feast_serving_ServingService_proto_depIdxs,
                EnumInfos:         file_feast_serving_ServingService_proto_enumTypes,
                MessageInfos:      file_feast_serving_ServingService_proto_msgTypes,
        }.Build()
        File_feast_serving_ServingService_proto = out.File
        file_feast_serving_ServingService_proto_rawDesc = nil
        file_feast_serving_ServingService_proto_goTypes = nil
        file_feast_serving_ServingService_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">//
// Copyright 2018 The Feast Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.25.1
// source: feast/serving/ServingService.proto

package serving

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
        ServingService_GetFeastServingInfo_FullMethodName = "/feast.serving.ServingService/GetFeastServingInfo"
        ServingService_GetOnlineFeatures_FullMethodName   = "/feast.serving.ServingService/GetOnlineFeatures"
)

// ServingServiceClient is the client API for ServingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ServingServiceClient interface {
        // Get information about this Feast serving.
        GetFeastServingInfo(ctx context.Context, in *GetFeastServingInfoRequest, opts ...grpc.CallOption) (*GetFeastServingInfoResponse, error)
        // Get online features synchronously.
        GetOnlineFeatures(ctx context.Context, in *GetOnlineFeaturesRequest, opts ...grpc.CallOption) (*GetOnlineFeaturesResponse, error)
}

type servingServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewServingServiceClient(cc grpc.ClientConnInterface) ServingServiceClient <span class="cov8" title="1">{
        return &amp;servingServiceClient{cc}
}</span>

func (c *servingServiceClient) GetFeastServingInfo(ctx context.Context, in *GetFeastServingInfoRequest, opts ...grpc.CallOption) (*GetFeastServingInfoResponse, error) <span class="cov8" title="1">{
        out := new(GetFeastServingInfoResponse)
        err := c.cc.Invoke(ctx, ServingService_GetFeastServingInfo_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

func (c *servingServiceClient) GetOnlineFeatures(ctx context.Context, in *GetOnlineFeaturesRequest, opts ...grpc.CallOption) (*GetOnlineFeaturesResponse, error) <span class="cov8" title="1">{
        out := new(GetOnlineFeaturesResponse)
        err := c.cc.Invoke(ctx, ServingService_GetOnlineFeatures_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return out, nil</span>
}

// ServingServiceServer is the server API for ServingService service.
// All implementations must embed UnimplementedServingServiceServer
// for forward compatibility
type ServingServiceServer interface {
        // Get information about this Feast serving.
        GetFeastServingInfo(context.Context, *GetFeastServingInfoRequest) (*GetFeastServingInfoResponse, error)
        // Get online features synchronously.
        GetOnlineFeatures(context.Context, *GetOnlineFeaturesRequest) (*GetOnlineFeaturesResponse, error)
        mustEmbedUnimplementedServingServiceServer()
}

// UnimplementedServingServiceServer must be embedded to have forward compatible implementations.
type UnimplementedServingServiceServer struct {
}

func (UnimplementedServingServiceServer) GetFeastServingInfo(context.Context, *GetFeastServingInfoRequest) (*GetFeastServingInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetFeastServingInfo not implemented")
}</span>
func (UnimplementedServingServiceServer) GetOnlineFeatures(context.Context, *GetOnlineFeaturesRequest) (*GetOnlineFeaturesResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetOnlineFeatures not implemented")
}</span>
func (UnimplementedServingServiceServer) mustEmbedUnimplementedServingServiceServer() {<span class="cov0" title="0">}</span>

// UnsafeServingServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ServingServiceServer will
// result in compilation errors.
type UnsafeServingServiceServer interface {
        mustEmbedUnimplementedServingServiceServer()
}

func RegisterServingServiceServer(s grpc.ServiceRegistrar, srv ServingServiceServer) <span class="cov8" title="1">{
        s.RegisterService(&amp;ServingService_ServiceDesc, srv)
}</span>

func _ServingService_GetFeastServingInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(GetFeastServingInfoRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov8" title="1">{
                return srv.(ServingServiceServer).GetFeastServingInfo(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: ServingService_GetFeastServingInfo_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ServingServiceServer).GetFeastServingInfo(ctx, req.(*GetFeastServingInfoRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _ServingService_GetOnlineFeatures_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov8" title="1">{
        in := new(GetOnlineFeaturesRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if interceptor == nil </span><span class="cov8" title="1">{
                return srv.(ServingServiceServer).GetOnlineFeatures(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: ServingService_GetOnlineFeatures_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(ServingServiceServer).GetOnlineFeatures(ctx, req.(*GetOnlineFeaturesRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// ServingService_ServiceDesc is the grpc.ServiceDesc for ServingService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ServingService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "feast.serving.ServingService",
        HandlerType: (*ServingServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "GetFeastServingInfo",
                        Handler:    _ServingService_GetFeastServingInfo_Handler,
                },
                {
                        MethodName: "GetOnlineFeatures",
                        Handler:    _ServingService_GetOnlineFeatures_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "feast/serving/ServingService.proto",
}
</pre>
		
		<pre class="file" id="file62" style="display: none">//
// Copyright 2021 The Feast Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.31.0
//         protoc        v4.25.1
// source: feast/serving/TransformationService.proto

package serving

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type TransformationServiceType int32

const (
        TransformationServiceType_TRANSFORMATION_SERVICE_TYPE_INVALID TransformationServiceType = 0
        TransformationServiceType_TRANSFORMATION_SERVICE_TYPE_PYTHON  TransformationServiceType = 1
        TransformationServiceType_TRANSFORMATION_SERVICE_TYPE_CUSTOM  TransformationServiceType = 100
)

// Enum value maps for TransformationServiceType.
var (
        TransformationServiceType_name = map[int32]string{
                0:   "TRANSFORMATION_SERVICE_TYPE_INVALID",
                1:   "TRANSFORMATION_SERVICE_TYPE_PYTHON",
                100: "TRANSFORMATION_SERVICE_TYPE_CUSTOM",
        }
        TransformationServiceType_value = map[string]int32{
                "TRANSFORMATION_SERVICE_TYPE_INVALID": 0,
                "TRANSFORMATION_SERVICE_TYPE_PYTHON":  1,
                "TRANSFORMATION_SERVICE_TYPE_CUSTOM":  100,
        }
)

func (x TransformationServiceType) Enum() *TransformationServiceType <span class="cov0" title="0">{
        p := new(TransformationServiceType)
        *p = x
        return p
}</span>

func (x TransformationServiceType) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (TransformationServiceType) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_feast_serving_TransformationService_proto_enumTypes[0].Descriptor()
}</span>

func (TransformationServiceType) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_feast_serving_TransformationService_proto_enumTypes[0]
}</span>

func (x TransformationServiceType) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use TransformationServiceType.Descriptor instead.
func (TransformationServiceType) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_serving_TransformationService_proto_rawDescGZIP(), []int{0}
}</span>

type ValueType struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Types that are assignable to Value:
        //
        //        *ValueType_ArrowValue
        Value isValueType_Value `protobuf_oneof:"value"`
}

func (x *ValueType) Reset() <span class="cov0" title="0">{
        *x = ValueType{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_serving_TransformationService_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ValueType) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ValueType) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ValueType) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_feast_serving_TransformationService_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ValueType.ProtoReflect.Descriptor instead.
func (*ValueType) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_serving_TransformationService_proto_rawDescGZIP(), []int{0}
}</span>

func (m *ValueType) GetValue() isValueType_Value <span class="cov0" title="0">{
        if m != nil </span><span class="cov0" title="0">{
                return m.Value
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *ValueType) GetArrowValue() []byte <span class="cov0" title="0">{
        if x, ok := x.GetValue().(*ValueType_ArrowValue); ok </span><span class="cov0" title="0">{
                return x.ArrowValue
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type isValueType_Value interface {
        isValueType_Value()
}

type ValueType_ArrowValue struct {
        // Having a oneOf provides forward compatibility if we need to support compound types
        // that are not supported by arrow natively.
        ArrowValue []byte `protobuf:"bytes,1,opt,name=arrow_value,json=arrowValue,proto3,oneof"`
}

func (*ValueType_ArrowValue) isValueType_Value() {<span class="cov0" title="0">}</span>

type GetTransformationServiceInfoRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *GetTransformationServiceInfoRequest) Reset() <span class="cov0" title="0">{
        *x = GetTransformationServiceInfoRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_serving_TransformationService_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetTransformationServiceInfoRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetTransformationServiceInfoRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetTransformationServiceInfoRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_feast_serving_TransformationService_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetTransformationServiceInfoRequest.ProtoReflect.Descriptor instead.
func (*GetTransformationServiceInfoRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_serving_TransformationService_proto_rawDescGZIP(), []int{1}
}</span>

type GetTransformationServiceInfoResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // Feast version of this transformation service deployment.
        Version string `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
        // Type of transformation service deployment. This is either Python, or custom
        Type                             TransformationServiceType `protobuf:"varint,2,opt,name=type,proto3,enum=feast.serving.TransformationServiceType" json:"type,omitempty"`
        TransformationServiceTypeDetails string                    `protobuf:"bytes,3,opt,name=transformation_service_type_details,json=transformationServiceTypeDetails,proto3" json:"transformation_service_type_details,omitempty"`
}

func (x *GetTransformationServiceInfoResponse) Reset() <span class="cov0" title="0">{
        *x = GetTransformationServiceInfoResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_serving_TransformationService_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *GetTransformationServiceInfoResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*GetTransformationServiceInfoResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *GetTransformationServiceInfoResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_feast_serving_TransformationService_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use GetTransformationServiceInfoResponse.ProtoReflect.Descriptor instead.
func (*GetTransformationServiceInfoResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_serving_TransformationService_proto_rawDescGZIP(), []int{2}
}</span>

func (x *GetTransformationServiceInfoResponse) GetVersion() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Version
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *GetTransformationServiceInfoResponse) GetType() TransformationServiceType <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Type
        }</span>
        <span class="cov0" title="0">return TransformationServiceType_TRANSFORMATION_SERVICE_TYPE_INVALID</span>
}

func (x *GetTransformationServiceInfoResponse) GetTransformationServiceTypeDetails() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TransformationServiceTypeDetails
        }</span>
        <span class="cov0" title="0">return ""</span>
}

type TransformFeaturesRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        OnDemandFeatureViewName string     `protobuf:"bytes,1,opt,name=on_demand_feature_view_name,json=onDemandFeatureViewName,proto3" json:"on_demand_feature_view_name,omitempty"`
        Project                 string     `protobuf:"bytes,2,opt,name=project,proto3" json:"project,omitempty"`
        TransformationInput     *ValueType `protobuf:"bytes,3,opt,name=transformation_input,json=transformationInput,proto3" json:"transformation_input,omitempty"`
}

func (x *TransformFeaturesRequest) Reset() <span class="cov0" title="0">{
        *x = TransformFeaturesRequest{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_serving_TransformationService_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *TransformFeaturesRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*TransformFeaturesRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *TransformFeaturesRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_feast_serving_TransformationService_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use TransformFeaturesRequest.ProtoReflect.Descriptor instead.
func (*TransformFeaturesRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_serving_TransformationService_proto_rawDescGZIP(), []int{3}
}</span>

func (x *TransformFeaturesRequest) GetOnDemandFeatureViewName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.OnDemandFeatureViewName
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *TransformFeaturesRequest) GetProject() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Project
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *TransformFeaturesRequest) GetTransformationInput() *ValueType <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TransformationInput
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type TransformFeaturesResponse struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        TransformationOutput *ValueType `protobuf:"bytes,3,opt,name=transformation_output,json=transformationOutput,proto3" json:"transformation_output,omitempty"`
}

func (x *TransformFeaturesResponse) Reset() <span class="cov0" title="0">{
        *x = TransformFeaturesResponse{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_serving_TransformationService_proto_msgTypes[4]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *TransformFeaturesResponse) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*TransformFeaturesResponse) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *TransformFeaturesResponse) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_feast_serving_TransformationService_proto_msgTypes[4]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use TransformFeaturesResponse.ProtoReflect.Descriptor instead.
func (*TransformFeaturesResponse) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_serving_TransformationService_proto_rawDescGZIP(), []int{4}
}</span>

func (x *TransformFeaturesResponse) GetTransformationOutput() *ValueType <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.TransformationOutput
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_feast_serving_TransformationService_proto protoreflect.FileDescriptor

var file_feast_serving_TransformationService_proto_rawDesc = []byte{
        0x0a, 0x29, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2f,
        0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x65,
        0x72, 0x76, 0x69, 0x63, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0d, 0x66, 0x65, 0x61,
        0x73, 0x74, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x22, 0x37, 0x0a, 0x09, 0x56, 0x61,
        0x6c, 0x75, 0x65, 0x54, 0x79, 0x70, 0x65, 0x12, 0x21, 0x0a, 0x0b, 0x61, 0x72, 0x72, 0x6f, 0x77,
        0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x48, 0x00, 0x52, 0x0a,
        0x61, 0x72, 0x72, 0x6f, 0x77, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x42, 0x07, 0x0a, 0x05, 0x76, 0x61,
        0x6c, 0x75, 0x65, 0x22, 0x25, 0x0a, 0x23, 0x47, 0x65, 0x74, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66,
        0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x49,
        0x6e, 0x66, 0x6f, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x22, 0xcd, 0x01, 0x0a, 0x24, 0x47,
        0x65, 0x74, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e,
        0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f,
        0x6e, 0x73, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x18, 0x01,
        0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x3c, 0x0a,
        0x04, 0x74, 0x79, 0x70, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x28, 0x2e, 0x66, 0x65,
        0x61, 0x73, 0x74, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x54, 0x72, 0x61, 0x6e,
        0x73, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63,
        0x65, 0x54, 0x79, 0x70, 0x65, 0x52, 0x04, 0x74, 0x79, 0x70, 0x65, 0x12, 0x4d, 0x0a, 0x23, 0x74,
        0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x73, 0x65,
        0x72, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x5f, 0x64, 0x65, 0x74, 0x61, 0x69,
        0x6c, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x20, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x66,
        0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x54,
        0x79, 0x70, 0x65, 0x44, 0x65, 0x74, 0x61, 0x69, 0x6c, 0x73, 0x22, 0xbf, 0x01, 0x0a, 0x18, 0x54,
        0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73,
        0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x3c, 0x0a, 0x1b, 0x6f, 0x6e, 0x5f, 0x64, 0x65,
        0x6d, 0x61, 0x6e, 0x64, 0x5f, 0x66, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x5f, 0x76, 0x69, 0x65,
        0x77, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x17, 0x6f, 0x6e,
        0x44, 0x65, 0x6d, 0x61, 0x6e, 0x64, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x56, 0x69, 0x65,
        0x77, 0x4e, 0x61, 0x6d, 0x65, 0x12, 0x18, 0x0a, 0x07, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74,
        0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x12,
        0x4b, 0x0a, 0x14, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f,
        0x6e, 0x5f, 0x69, 0x6e, 0x70, 0x75, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x18, 0x2e,
        0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x56, 0x61,
        0x6c, 0x75, 0x65, 0x54, 0x79, 0x70, 0x65, 0x52, 0x13, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f,
        0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x22, 0x6a, 0x0a, 0x19,
        0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65,
        0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x4d, 0x0a, 0x15, 0x74, 0x72, 0x61,
        0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x6f, 0x75, 0x74, 0x70,
        0x75, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x18, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74,
        0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x54, 0x79,
        0x70, 0x65, 0x52, 0x14, 0x74, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69,
        0x6f, 0x6e, 0x4f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x2a, 0x94, 0x01, 0x0a, 0x19, 0x54, 0x72, 0x61,
        0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x65, 0x72, 0x76, 0x69,
        0x63, 0x65, 0x54, 0x79, 0x70, 0x65, 0x12, 0x27, 0x0a, 0x23, 0x54, 0x52, 0x41, 0x4e, 0x53, 0x46,
        0x4f, 0x52, 0x4d, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x53, 0x45, 0x52, 0x56, 0x49, 0x43, 0x45,
        0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x49, 0x4e, 0x56, 0x41, 0x4c, 0x49, 0x44, 0x10, 0x00, 0x12,
        0x26, 0x0a, 0x22, 0x54, 0x52, 0x41, 0x4e, 0x53, 0x46, 0x4f, 0x52, 0x4d, 0x41, 0x54, 0x49, 0x4f,
        0x4e, 0x5f, 0x53, 0x45, 0x52, 0x56, 0x49, 0x43, 0x45, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x50,
        0x59, 0x54, 0x48, 0x4f, 0x4e, 0x10, 0x01, 0x12, 0x26, 0x0a, 0x22, 0x54, 0x52, 0x41, 0x4e, 0x53,
        0x46, 0x4f, 0x52, 0x4d, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x53, 0x45, 0x52, 0x56, 0x49, 0x43,
        0x45, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x43, 0x55, 0x53, 0x54, 0x4f, 0x4d, 0x10, 0x64, 0x32,
        0x89, 0x02, 0x0a, 0x15, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69,
        0x6f, 0x6e, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x87, 0x01, 0x0a, 0x1c, 0x47, 0x65,
        0x74, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53,
        0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x32, 0x2e, 0x66, 0x65, 0x61,
        0x73, 0x74, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x47, 0x65, 0x74, 0x54, 0x72,
        0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x53, 0x65, 0x72, 0x76,
        0x69, 0x63, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x1a, 0x33,
        0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x47,
        0x65, 0x74, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e,
        0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x65, 0x73, 0x70, 0x6f,
        0x6e, 0x73, 0x65, 0x12, 0x66, 0x0a, 0x11, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d,
        0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x12, 0x27, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74,
        0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e, 0x67, 0x2e, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f,
        0x72, 0x6d, 0x46, 0x65, 0x61, 0x74, 0x75, 0x72, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
        0x74, 0x1a, 0x28, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69, 0x6e,
        0x67, 0x2e, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x46, 0x65, 0x61, 0x74, 0x75,
        0x72, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x42, 0x68, 0x0a, 0x13, 0x66,
        0x65, 0x61, 0x73, 0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x73, 0x65, 0x72, 0x76, 0x69,
        0x6e, 0x67, 0x42, 0x1d, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x69,
        0x6f, 0x6e, 0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x41, 0x50, 0x49, 0x50, 0x72, 0x6f, 0x74,
        0x6f, 0x5a, 0x32, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x66, 0x65,
        0x61, 0x73, 0x74, 0x2d, 0x64, 0x65, 0x76, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x67, 0x6f,
        0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x73, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x73, 0x65,
        0x72, 0x76, 0x69, 0x6e, 0x67, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_feast_serving_TransformationService_proto_rawDescOnce sync.Once
        file_feast_serving_TransformationService_proto_rawDescData = file_feast_serving_TransformationService_proto_rawDesc
)

func file_feast_serving_TransformationService_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_feast_serving_TransformationService_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_feast_serving_TransformationService_proto_rawDescData = protoimpl.X.CompressGZIP(file_feast_serving_TransformationService_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_feast_serving_TransformationService_proto_rawDescData</span>
}

var file_feast_serving_TransformationService_proto_enumTypes = make([]protoimpl.EnumInfo, 1)
var file_feast_serving_TransformationService_proto_msgTypes = make([]protoimpl.MessageInfo, 5)
var file_feast_serving_TransformationService_proto_goTypes = []interface{}{
        (TransformationServiceType)(0),               // 0: feast.serving.TransformationServiceType
        (*ValueType)(nil),                            // 1: feast.serving.ValueType
        (*GetTransformationServiceInfoRequest)(nil),  // 2: feast.serving.GetTransformationServiceInfoRequest
        (*GetTransformationServiceInfoResponse)(nil), // 3: feast.serving.GetTransformationServiceInfoResponse
        (*TransformFeaturesRequest)(nil),             // 4: feast.serving.TransformFeaturesRequest
        (*TransformFeaturesResponse)(nil),            // 5: feast.serving.TransformFeaturesResponse
}
var file_feast_serving_TransformationService_proto_depIdxs = []int32{
        0, // 0: feast.serving.GetTransformationServiceInfoResponse.type:type_name -&gt; feast.serving.TransformationServiceType
        1, // 1: feast.serving.TransformFeaturesRequest.transformation_input:type_name -&gt; feast.serving.ValueType
        1, // 2: feast.serving.TransformFeaturesResponse.transformation_output:type_name -&gt; feast.serving.ValueType
        2, // 3: feast.serving.TransformationService.GetTransformationServiceInfo:input_type -&gt; feast.serving.GetTransformationServiceInfoRequest
        4, // 4: feast.serving.TransformationService.TransformFeatures:input_type -&gt; feast.serving.TransformFeaturesRequest
        3, // 5: feast.serving.TransformationService.GetTransformationServiceInfo:output_type -&gt; feast.serving.GetTransformationServiceInfoResponse
        5, // 6: feast.serving.TransformationService.TransformFeatures:output_type -&gt; feast.serving.TransformFeaturesResponse
        5, // [5:7] is the sub-list for method output_type
        3, // [3:5] is the sub-list for method input_type
        3, // [3:3] is the sub-list for extension type_name
        3, // [3:3] is the sub-list for extension extendee
        0, // [0:3] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_feast_serving_TransformationService_proto_init() }</span>
func file_feast_serving_TransformationService_proto_init() <span class="cov8" title="1">{
        if File_feast_serving_TransformationService_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_feast_serving_TransformationService_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ValueType); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_serving_TransformationService_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GetTransformationServiceInfoRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_serving_TransformationService_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*GetTransformationServiceInfoResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_serving_TransformationService_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*TransformFeaturesRequest); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_serving_TransformationService_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*TransformFeaturesResponse); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">file_feast_serving_TransformationService_proto_msgTypes[0].OneofWrappers = []interface{}{
                (*ValueType_ArrowValue)(nil),
        }
        type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_feast_serving_TransformationService_proto_rawDesc,
                        NumEnums:      1,
                        NumMessages:   5,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_feast_serving_TransformationService_proto_goTypes,
                DependencyIndexes: file_feast_serving_TransformationService_proto_depIdxs,
                EnumInfos:         file_feast_serving_TransformationService_proto_enumTypes,
                MessageInfos:      file_feast_serving_TransformationService_proto_msgTypes,
        }.Build()
        File_feast_serving_TransformationService_proto = out.File
        file_feast_serving_TransformationService_proto_rawDesc = nil
        file_feast_serving_TransformationService_proto_goTypes = nil
        file_feast_serving_TransformationService_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">//
// Copyright 2021 The Feast Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.25.1
// source: feast/serving/TransformationService.proto

package serving

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
        TransformationService_GetTransformationServiceInfo_FullMethodName = "/feast.serving.TransformationService/GetTransformationServiceInfo"
        TransformationService_TransformFeatures_FullMethodName            = "/feast.serving.TransformationService/TransformFeatures"
)

// TransformationServiceClient is the client API for TransformationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TransformationServiceClient interface {
        GetTransformationServiceInfo(ctx context.Context, in *GetTransformationServiceInfoRequest, opts ...grpc.CallOption) (*GetTransformationServiceInfoResponse, error)
        TransformFeatures(ctx context.Context, in *TransformFeaturesRequest, opts ...grpc.CallOption) (*TransformFeaturesResponse, error)
}

type transformationServiceClient struct {
        cc grpc.ClientConnInterface
}

func NewTransformationServiceClient(cc grpc.ClientConnInterface) TransformationServiceClient <span class="cov8" title="1">{
        return &amp;transformationServiceClient{cc}
}</span>

func (c *transformationServiceClient) GetTransformationServiceInfo(ctx context.Context, in *GetTransformationServiceInfoRequest, opts ...grpc.CallOption) (*GetTransformationServiceInfoResponse, error) <span class="cov0" title="0">{
        out := new(GetTransformationServiceInfoResponse)
        err := c.cc.Invoke(ctx, TransformationService_GetTransformationServiceInfo_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

func (c *transformationServiceClient) TransformFeatures(ctx context.Context, in *TransformFeaturesRequest, opts ...grpc.CallOption) (*TransformFeaturesResponse, error) <span class="cov0" title="0">{
        out := new(TransformFeaturesResponse)
        err := c.cc.Invoke(ctx, TransformationService_TransformFeatures_FullMethodName, in, out, opts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// TransformationServiceServer is the server API for TransformationService service.
// All implementations must embed UnimplementedTransformationServiceServer
// for forward compatibility
type TransformationServiceServer interface {
        GetTransformationServiceInfo(context.Context, *GetTransformationServiceInfoRequest) (*GetTransformationServiceInfoResponse, error)
        TransformFeatures(context.Context, *TransformFeaturesRequest) (*TransformFeaturesResponse, error)
        mustEmbedUnimplementedTransformationServiceServer()
}

// UnimplementedTransformationServiceServer must be embedded to have forward compatible implementations.
type UnimplementedTransformationServiceServer struct {
}

func (UnimplementedTransformationServiceServer) GetTransformationServiceInfo(context.Context, *GetTransformationServiceInfoRequest) (*GetTransformationServiceInfoResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method GetTransformationServiceInfo not implemented")
}</span>
func (UnimplementedTransformationServiceServer) TransformFeatures(context.Context, *TransformFeaturesRequest) (*TransformFeaturesResponse, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method TransformFeatures not implemented")
}</span>
func (UnimplementedTransformationServiceServer) mustEmbedUnimplementedTransformationServiceServer() {<span class="cov0" title="0">}</span>

// UnsafeTransformationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TransformationServiceServer will
// result in compilation errors.
type UnsafeTransformationServiceServer interface {
        mustEmbedUnimplementedTransformationServiceServer()
}

func RegisterTransformationServiceServer(s grpc.ServiceRegistrar, srv TransformationServiceServer) <span class="cov0" title="0">{
        s.RegisterService(&amp;TransformationService_ServiceDesc, srv)
}</span>

func _TransformationService_GetTransformationServiceInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(GetTransformationServiceInfoRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TransformationServiceServer).GetTransformationServiceInfo(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: TransformationService_GetTransformationServiceInfo_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TransformationServiceServer).GetTransformationServiceInfo(ctx, req.(*GetTransformationServiceInfoRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

func _TransformationService_TransformFeatures_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(TransformFeaturesRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(TransformationServiceServer).TransformFeatures(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: TransformationService_TransformFeatures_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(TransformationServiceServer).TransformFeatures(ctx, req.(*TransformFeaturesRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// TransformationService_ServiceDesc is the grpc.ServiceDesc for TransformationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TransformationService_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "feast.serving.TransformationService",
        HandlerType: (*TransformationServiceServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "GetTransformationServiceInfo",
                        Handler:    _TransformationService_GetTransformationServiceInfo_Handler,
                },
                {
                        MethodName: "TransformFeatures",
                        Handler:    _TransformationService_TransformFeatures_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "feast/serving/TransformationService.proto",
}
</pre>
		
		<pre class="file" id="file64" style="display: none">//
// Copyright 2019 The Feast Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.31.0
//         protoc        v4.25.1
// source: feast/storage/Redis.proto

package storage

import (
        types "github.com/feast-dev/feast/go/protos/feast/types"
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type RedisKeyV2 struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Project      string         `protobuf:"bytes,1,opt,name=project,proto3" json:"project,omitempty"`
        EntityNames  []string       `protobuf:"bytes,2,rep,name=entity_names,json=entityNames,proto3" json:"entity_names,omitempty"`
        EntityValues []*types.Value `protobuf:"bytes,3,rep,name=entity_values,json=entityValues,proto3" json:"entity_values,omitempty"`
}

func (x *RedisKeyV2) Reset() <span class="cov0" title="0">{
        *x = RedisKeyV2{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_storage_Redis_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *RedisKeyV2) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RedisKeyV2) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RedisKeyV2) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_feast_storage_Redis_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use RedisKeyV2.ProtoReflect.Descriptor instead.
func (*RedisKeyV2) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_storage_Redis_proto_rawDescGZIP(), []int{0}
}</span>

func (x *RedisKeyV2) GetProject() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Project
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *RedisKeyV2) GetEntityNames() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.EntityNames
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *RedisKeyV2) GetEntityValues() []*types.Value <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.EntityValues
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_feast_storage_Redis_proto protoreflect.FileDescriptor

var file_feast_storage_Redis_proto_rawDesc = []byte{
        0x0a, 0x19, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x73, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x2f,
        0x52, 0x65, 0x64, 0x69, 0x73, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0d, 0x66, 0x65, 0x61,
        0x73, 0x74, 0x2e, 0x73, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x1a, 0x17, 0x66, 0x65, 0x61, 0x73,
        0x74, 0x2f, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2f, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x22, 0x82, 0x01, 0x0a, 0x0a, 0x52, 0x65, 0x64, 0x69, 0x73, 0x4b, 0x65, 0x79,
        0x56, 0x32, 0x12, 0x18, 0x0a, 0x07, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x18, 0x01, 0x20,
        0x01, 0x28, 0x09, 0x52, 0x07, 0x70, 0x72, 0x6f, 0x6a, 0x65, 0x63, 0x74, 0x12, 0x21, 0x0a, 0x0c,
        0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x73, 0x18, 0x02, 0x20, 0x03,
        0x28, 0x09, 0x52, 0x0b, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x4e, 0x61, 0x6d, 0x65, 0x73, 0x12,
        0x37, 0x0a, 0x0d, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73,
        0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x74,
        0x79, 0x70, 0x65, 0x73, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x0c, 0x65, 0x6e, 0x74, 0x69,
        0x74, 0x79, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x42, 0x55, 0x0a, 0x13, 0x66, 0x65, 0x61, 0x73,
        0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x73, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x42,
        0x0a, 0x52, 0x65, 0x64, 0x69, 0x73, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x5a, 0x32, 0x67, 0x69, 0x74,
        0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2d, 0x64, 0x65,
        0x76, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x67, 0x6f, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x73, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x73, 0x74, 0x6f, 0x72, 0x61, 0x67, 0x65, 0x62,
        0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_feast_storage_Redis_proto_rawDescOnce sync.Once
        file_feast_storage_Redis_proto_rawDescData = file_feast_storage_Redis_proto_rawDesc
)

func file_feast_storage_Redis_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_feast_storage_Redis_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_feast_storage_Redis_proto_rawDescData = protoimpl.X.CompressGZIP(file_feast_storage_Redis_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_feast_storage_Redis_proto_rawDescData</span>
}

var file_feast_storage_Redis_proto_msgTypes = make([]protoimpl.MessageInfo, 1)
var file_feast_storage_Redis_proto_goTypes = []interface{}{
        (*RedisKeyV2)(nil),  // 0: feast.storage.RedisKeyV2
        (*types.Value)(nil), // 1: feast.types.Value
}
var file_feast_storage_Redis_proto_depIdxs = []int32{
        1, // 0: feast.storage.RedisKeyV2.entity_values:type_name -&gt; feast.types.Value
        1, // [1:1] is the sub-list for method output_type
        1, // [1:1] is the sub-list for method input_type
        1, // [1:1] is the sub-list for extension type_name
        1, // [1:1] is the sub-list for extension extendee
        0, // [0:1] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_feast_storage_Redis_proto_init() }</span>
func file_feast_storage_Redis_proto_init() <span class="cov0" title="0">{
        if File_feast_storage_Redis_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_feast_storage_Redis_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*RedisKeyV2); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_feast_storage_Redis_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   1,
                        NumExtensions: 0,
                        NumServices:   0,
                },
                GoTypes:           file_feast_storage_Redis_proto_goTypes,
                DependencyIndexes: file_feast_storage_Redis_proto_depIdxs,
                MessageInfos:      file_feast_storage_Redis_proto_msgTypes,
        }.Build()
        File_feast_storage_Redis_proto = out.File
        file_feast_storage_Redis_proto_rawDesc = nil
        file_feast_storage_Redis_proto_goTypes = nil
        file_feast_storage_Redis_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">//
// Copyright 2018 The Feast Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.31.0
//         protoc        v4.25.1
// source: feast/types/EntityKey.proto

package types

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type EntityKey struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        JoinKeys     []string `protobuf:"bytes,1,rep,name=join_keys,json=joinKeys,proto3" json:"join_keys,omitempty"`
        EntityValues []*Value `protobuf:"bytes,2,rep,name=entity_values,json=entityValues,proto3" json:"entity_values,omitempty"`
}

func (x *EntityKey) Reset() <span class="cov0" title="0">{
        *x = EntityKey{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_types_EntityKey_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *EntityKey) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*EntityKey) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *EntityKey) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_types_EntityKey_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov8" title="1">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov8" title="1">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov8" title="1">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use EntityKey.ProtoReflect.Descriptor instead.
func (*EntityKey) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_types_EntityKey_proto_rawDescGZIP(), []int{0}
}</span>

func (x *EntityKey) GetJoinKeys() []string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.JoinKeys
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *EntityKey) GetEntityValues() []*Value <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.EntityValues
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_feast_types_EntityKey_proto protoreflect.FileDescriptor

var file_feast_types_EntityKey_proto_rawDesc = []byte{
        0x0a, 0x1b, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2f, 0x45, 0x6e,
        0x74, 0x69, 0x74, 0x79, 0x4b, 0x65, 0x79, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0b, 0x66,
        0x65, 0x61, 0x73, 0x74, 0x2e, 0x74, 0x79, 0x70, 0x65, 0x73, 0x1a, 0x17, 0x66, 0x65, 0x61, 0x73,
        0x74, 0x2f, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2f, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x2e, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x22, 0x61, 0x0a, 0x09, 0x45, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x4b, 0x65, 0x79,
        0x12, 0x1b, 0x0a, 0x09, 0x6a, 0x6f, 0x69, 0x6e, 0x5f, 0x6b, 0x65, 0x79, 0x73, 0x18, 0x01, 0x20,
        0x03, 0x28, 0x09, 0x52, 0x08, 0x6a, 0x6f, 0x69, 0x6e, 0x4b, 0x65, 0x79, 0x73, 0x12, 0x37, 0x0a,
        0x0d, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x18, 0x02,
        0x20, 0x03, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x74, 0x79, 0x70,
        0x65, 0x73, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x0c, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79,
        0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x42, 0x55, 0x0a, 0x11, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e,
        0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x74, 0x79, 0x70, 0x65, 0x73, 0x42, 0x0e, 0x45, 0x6e, 0x74,
        0x69, 0x74, 0x79, 0x4b, 0x65, 0x79, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x5a, 0x30, 0x67, 0x69, 0x74,
        0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2d, 0x64, 0x65,
        0x76, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x67, 0x6f, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f,
        0x73, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x74, 0x79, 0x70, 0x65, 0x73, 0x62, 0x06, 0x70,
        0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_feast_types_EntityKey_proto_rawDescOnce sync.Once
        file_feast_types_EntityKey_proto_rawDescData = file_feast_types_EntityKey_proto_rawDesc
)

func file_feast_types_EntityKey_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_feast_types_EntityKey_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_feast_types_EntityKey_proto_rawDescData = protoimpl.X.CompressGZIP(file_feast_types_EntityKey_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_feast_types_EntityKey_proto_rawDescData</span>
}

var file_feast_types_EntityKey_proto_msgTypes = make([]protoimpl.MessageInfo, 1)
var file_feast_types_EntityKey_proto_goTypes = []interface{}{
        (*EntityKey)(nil), // 0: feast.types.EntityKey
        (*Value)(nil),     // 1: feast.types.Value
}
var file_feast_types_EntityKey_proto_depIdxs = []int32{
        1, // 0: feast.types.EntityKey.entity_values:type_name -&gt; feast.types.Value
        1, // [1:1] is the sub-list for method output_type
        1, // [1:1] is the sub-list for method input_type
        1, // [1:1] is the sub-list for extension type_name
        1, // [1:1] is the sub-list for extension extendee
        0, // [0:1] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_feast_types_EntityKey_proto_init() }</span>
func file_feast_types_EntityKey_proto_init() <span class="cov8" title="1">{
        if File_feast_types_EntityKey_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">file_feast_types_Value_proto_init()
        if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_feast_types_EntityKey_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*EntityKey); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_feast_types_EntityKey_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   1,
                        NumExtensions: 0,
                        NumServices:   0,
                },
                GoTypes:           file_feast_types_EntityKey_proto_goTypes,
                DependencyIndexes: file_feast_types_EntityKey_proto_depIdxs,
                MessageInfos:      file_feast_types_EntityKey_proto_msgTypes,
        }.Build()
        File_feast_types_EntityKey_proto = out.File
        file_feast_types_EntityKey_proto_rawDesc = nil
        file_feast_types_EntityKey_proto_goTypes = nil
        file_feast_types_EntityKey_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">//
// Copyright 2018 The Feast Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.31.0
//         protoc        v4.25.1
// source: feast/types/Field.proto

package types

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Field struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Name  string         `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        Value ValueType_Enum `protobuf:"varint,2,opt,name=value,proto3,enum=feast.types.ValueType_Enum" json:"value,omitempty"`
        // Tags for user defined metadata on a field
        Tags map[string]string `protobuf:"bytes,3,rep,name=tags,proto3" json:"tags,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
        // Description of the field.
        Description string `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
}

func (x *Field) Reset() <span class="cov0" title="0">{
        *x = Field{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_types_Field_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Field) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Field) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Field) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_feast_types_Field_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use Field.ProtoReflect.Descriptor instead.
func (*Field) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_types_Field_proto_rawDescGZIP(), []int{0}
}</span>

func (x *Field) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Field) GetValue() ValueType_Enum <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Value
        }</span>
        <span class="cov0" title="0">return ValueType_INVALID</span>
}

func (x *Field) GetTags() map[string]string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Tags
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Field) GetDescription() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Description
        }</span>
        <span class="cov0" title="0">return ""</span>
}

var File_feast_types_Field_proto protoreflect.FileDescriptor

var file_feast_types_Field_proto_rawDesc = []byte{
        0x0a, 0x17, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2f, 0x46, 0x69,
        0x65, 0x6c, 0x64, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0b, 0x66, 0x65, 0x61, 0x73, 0x74,
        0x2e, 0x74, 0x79, 0x70, 0x65, 0x73, 0x1a, 0x17, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x74, 0x79,
        0x70, 0x65, 0x73, 0x2f, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22,
        0xdb, 0x01, 0x0a, 0x05, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d,
        0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x31, 0x0a,
        0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x1b, 0x2e, 0x66,
        0x65, 0x61, 0x73, 0x74, 0x2e, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65,
        0x54, 0x79, 0x70, 0x65, 0x2e, 0x45, 0x6e, 0x75, 0x6d, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65,
        0x12, 0x30, 0x0a, 0x04, 0x74, 0x61, 0x67, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x1c,
        0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2e, 0x46, 0x69, 0x65,
        0x6c, 0x64, 0x2e, 0x54, 0x61, 0x67, 0x73, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x04, 0x74, 0x61,
        0x67, 0x73, 0x12, 0x20, 0x0a, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f,
        0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x64, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70,
        0x74, 0x69, 0x6f, 0x6e, 0x1a, 0x37, 0x0a, 0x09, 0x54, 0x61, 0x67, 0x73, 0x45, 0x6e, 0x74, 0x72,
        0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03,
        0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3a, 0x02, 0x38, 0x01, 0x42, 0x51, 0x0a,
        0x11, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x2e, 0x74, 0x79, 0x70,
        0x65, 0x73, 0x42, 0x0a, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x50, 0x72, 0x6f, 0x74, 0x6f, 0x5a, 0x30,
        0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74,
        0x2d, 0x64, 0x65, 0x76, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x67, 0x6f, 0x2f, 0x70, 0x72,
        0x6f, 0x74, 0x6f, 0x73, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x74, 0x79, 0x70, 0x65, 0x73,
        0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_feast_types_Field_proto_rawDescOnce sync.Once
        file_feast_types_Field_proto_rawDescData = file_feast_types_Field_proto_rawDesc
)

func file_feast_types_Field_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_feast_types_Field_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_feast_types_Field_proto_rawDescData = protoimpl.X.CompressGZIP(file_feast_types_Field_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_feast_types_Field_proto_rawDescData</span>
}

var file_feast_types_Field_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_feast_types_Field_proto_goTypes = []interface{}{
        (*Field)(nil),       // 0: feast.types.Field
        nil,                 // 1: feast.types.Field.TagsEntry
        (ValueType_Enum)(0), // 2: feast.types.ValueType.Enum
}
var file_feast_types_Field_proto_depIdxs = []int32{
        2, // 0: feast.types.Field.value:type_name -&gt; feast.types.ValueType.Enum
        1, // 1: feast.types.Field.tags:type_name -&gt; feast.types.Field.TagsEntry
        2, // [2:2] is the sub-list for method output_type
        2, // [2:2] is the sub-list for method input_type
        2, // [2:2] is the sub-list for extension type_name
        2, // [2:2] is the sub-list for extension extendee
        0, // [0:2] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_feast_types_Field_proto_init() }</span>
func file_feast_types_Field_proto_init() <span class="cov8" title="1">{
        if File_feast_types_Field_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">file_feast_types_Value_proto_init()
        if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_feast_types_Field_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Field); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_feast_types_Field_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   2,
                        NumExtensions: 0,
                        NumServices:   0,
                },
                GoTypes:           file_feast_types_Field_proto_goTypes,
                DependencyIndexes: file_feast_types_Field_proto_depIdxs,
                MessageInfos:      file_feast_types_Field_proto_msgTypes,
        }.Build()
        File_feast_types_Field_proto = out.File
        file_feast_types_Field_proto_rawDesc = nil
        file_feast_types_Field_proto_goTypes = nil
        file_feast_types_Field_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">//
// Copyright 2018 The Feast Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.31.0
//         protoc        v4.25.1
// source: feast/types/Value.proto

package types

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Null int32

const (
        Null_NULL Null = 0
)

// Enum value maps for Null.
var (
        Null_name = map[int32]string{
                0: "NULL",
        }
        Null_value = map[string]int32{
                "NULL": 0,
        }
)

func (x Null) Enum() *Null <span class="cov0" title="0">{
        p := new(Null)
        *p = x
        return p
}</span>

func (x Null) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (Null) Descriptor() protoreflect.EnumDescriptor <span class="cov0" title="0">{
        return file_feast_types_Value_proto_enumTypes[0].Descriptor()
}</span>

func (Null) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_feast_types_Value_proto_enumTypes[0]
}</span>

func (x Null) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use Null.Descriptor instead.
func (Null) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_types_Value_proto_rawDescGZIP(), []int{0}
}</span>

type ValueType_Enum int32

const (
        ValueType_INVALID             ValueType_Enum = 0
        ValueType_BYTES               ValueType_Enum = 1
        ValueType_STRING              ValueType_Enum = 2
        ValueType_INT32               ValueType_Enum = 3
        ValueType_INT64               ValueType_Enum = 4
        ValueType_DOUBLE              ValueType_Enum = 5
        ValueType_FLOAT               ValueType_Enum = 6
        ValueType_BOOL                ValueType_Enum = 7
        ValueType_UNIX_TIMESTAMP      ValueType_Enum = 8
        ValueType_BYTES_LIST          ValueType_Enum = 11
        ValueType_STRING_LIST         ValueType_Enum = 12
        ValueType_INT32_LIST          ValueType_Enum = 13
        ValueType_INT64_LIST          ValueType_Enum = 14
        ValueType_DOUBLE_LIST         ValueType_Enum = 15
        ValueType_FLOAT_LIST          ValueType_Enum = 16
        ValueType_BOOL_LIST           ValueType_Enum = 17
        ValueType_UNIX_TIMESTAMP_LIST ValueType_Enum = 18
        ValueType_NULL                ValueType_Enum = 19
)

// Enum value maps for ValueType_Enum.
var (
        ValueType_Enum_name = map[int32]string{
                0:  "INVALID",
                1:  "BYTES",
                2:  "STRING",
                3:  "INT32",
                4:  "INT64",
                5:  "DOUBLE",
                6:  "FLOAT",
                7:  "BOOL",
                8:  "UNIX_TIMESTAMP",
                11: "BYTES_LIST",
                12: "STRING_LIST",
                13: "INT32_LIST",
                14: "INT64_LIST",
                15: "DOUBLE_LIST",
                16: "FLOAT_LIST",
                17: "BOOL_LIST",
                18: "UNIX_TIMESTAMP_LIST",
                19: "NULL",
        }
        ValueType_Enum_value = map[string]int32{
                "INVALID":             0,
                "BYTES":               1,
                "STRING":              2,
                "INT32":               3,
                "INT64":               4,
                "DOUBLE":              5,
                "FLOAT":               6,
                "BOOL":                7,
                "UNIX_TIMESTAMP":      8,
                "BYTES_LIST":          11,
                "STRING_LIST":         12,
                "INT32_LIST":          13,
                "INT64_LIST":          14,
                "DOUBLE_LIST":         15,
                "FLOAT_LIST":          16,
                "BOOL_LIST":           17,
                "UNIX_TIMESTAMP_LIST": 18,
                "NULL":                19,
        }
)

func (x ValueType_Enum) Enum() *ValueType_Enum <span class="cov8" title="1">{
        p := new(ValueType_Enum)
        *p = x
        return p
}</span>

func (x ValueType_Enum) String() string <span class="cov0" title="0">{
        return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}</span>

func (ValueType_Enum) Descriptor() protoreflect.EnumDescriptor <span class="cov8" title="1">{
        return file_feast_types_Value_proto_enumTypes[1].Descriptor()
}</span>

func (ValueType_Enum) Type() protoreflect.EnumType <span class="cov0" title="0">{
        return &amp;file_feast_types_Value_proto_enumTypes[1]
}</span>

func (x ValueType_Enum) Number() protoreflect.EnumNumber <span class="cov0" title="0">{
        return protoreflect.EnumNumber(x)
}</span>

// Deprecated: Use ValueType_Enum.Descriptor instead.
func (ValueType_Enum) EnumDescriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_types_Value_proto_rawDescGZIP(), []int{0, 0}
}</span>

type ValueType struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields
}

func (x *ValueType) Reset() <span class="cov0" title="0">{
        *x = ValueType{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_types_Value_proto_msgTypes[0]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *ValueType) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*ValueType) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *ValueType) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_feast_types_Value_proto_msgTypes[0]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use ValueType.ProtoReflect.Descriptor instead.
func (*ValueType) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_types_Value_proto_rawDescGZIP(), []int{0}
}</span>

type Value struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        // ValueType is referenced by the metadata types, FeatureInfo and EntityInfo.
        // The enum values do not have to match the oneof val field ids, but they should.
        // In JSON "*_val" field can be omitted
        //
        // Types that are assignable to Val:
        //
        //        *Value_BytesVal
        //        *Value_StringVal
        //        *Value_Int32Val
        //        *Value_Int64Val
        //        *Value_DoubleVal
        //        *Value_FloatVal
        //        *Value_BoolVal
        //        *Value_UnixTimestampVal
        //        *Value_BytesListVal
        //        *Value_StringListVal
        //        *Value_Int32ListVal
        //        *Value_Int64ListVal
        //        *Value_DoubleListVal
        //        *Value_FloatListVal
        //        *Value_BoolListVal
        //        *Value_UnixTimestampListVal
        //        *Value_NullVal
        Val isValue_Val `protobuf_oneof:"val"`
}

func (x *Value) Reset() <span class="cov8" title="1">{
        *x = Value{}
        if protoimpl.UnsafeEnabled </span><span class="cov8" title="1">{
                mi := &amp;file_feast_types_Value_proto_msgTypes[1]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Value) String() string <span class="cov8" title="1">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Value) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Value) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_types_Value_proto_msgTypes[1]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov8" title="1">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov8" title="1">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov8" title="1">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use Value.ProtoReflect.Descriptor instead.
func (*Value) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_types_Value_proto_rawDescGZIP(), []int{1}
}</span>

func (m *Value) GetVal() isValue_Val <span class="cov8" title="1">{
        if m != nil </span><span class="cov8" title="1">{
                return m.Val
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Value) GetBytesVal() []byte <span class="cov8" title="1">{
        if x, ok := x.GetVal().(*Value_BytesVal); ok </span><span class="cov8" title="1">{
                return x.BytesVal
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Value) GetStringVal() string <span class="cov8" title="1">{
        if x, ok := x.GetVal().(*Value_StringVal); ok </span><span class="cov8" title="1">{
                return x.StringVal
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *Value) GetInt32Val() int32 <span class="cov8" title="1">{
        if x, ok := x.GetVal().(*Value_Int32Val); ok </span><span class="cov8" title="1">{
                return x.Int32Val
        }</span>
        <span class="cov8" title="1">return 0</span>
}

func (x *Value) GetInt64Val() int64 <span class="cov8" title="1">{
        if x, ok := x.GetVal().(*Value_Int64Val); ok </span><span class="cov8" title="1">{
                return x.Int64Val
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Value) GetDoubleVal() float64 <span class="cov8" title="1">{
        if x, ok := x.GetVal().(*Value_DoubleVal); ok </span><span class="cov8" title="1">{
                return x.DoubleVal
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Value) GetFloatVal() float32 <span class="cov8" title="1">{
        if x, ok := x.GetVal().(*Value_FloatVal); ok </span><span class="cov8" title="1">{
                return x.FloatVal
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Value) GetBoolVal() bool <span class="cov8" title="1">{
        if x, ok := x.GetVal().(*Value_BoolVal); ok </span><span class="cov8" title="1">{
                return x.BoolVal
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (x *Value) GetUnixTimestampVal() int64 <span class="cov8" title="1">{
        if x, ok := x.GetVal().(*Value_UnixTimestampVal); ok </span><span class="cov8" title="1">{
                return x.UnixTimestampVal
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func (x *Value) GetBytesListVal() *BytesList <span class="cov8" title="1">{
        if x, ok := x.GetVal().(*Value_BytesListVal); ok </span><span class="cov8" title="1">{
                return x.BytesListVal
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Value) GetStringListVal() *StringList <span class="cov8" title="1">{
        if x, ok := x.GetVal().(*Value_StringListVal); ok </span><span class="cov8" title="1">{
                return x.StringListVal
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Value) GetInt32ListVal() *Int32List <span class="cov8" title="1">{
        if x, ok := x.GetVal().(*Value_Int32ListVal); ok </span><span class="cov8" title="1">{
                return x.Int32ListVal
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Value) GetInt64ListVal() *Int64List <span class="cov8" title="1">{
        if x, ok := x.GetVal().(*Value_Int64ListVal); ok </span><span class="cov8" title="1">{
                return x.Int64ListVal
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Value) GetDoubleListVal() *DoubleList <span class="cov8" title="1">{
        if x, ok := x.GetVal().(*Value_DoubleListVal); ok </span><span class="cov8" title="1">{
                return x.DoubleListVal
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Value) GetFloatListVal() *FloatList <span class="cov8" title="1">{
        if x, ok := x.GetVal().(*Value_FloatListVal); ok </span><span class="cov8" title="1">{
                return x.FloatListVal
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Value) GetBoolListVal() *BoolList <span class="cov8" title="1">{
        if x, ok := x.GetVal().(*Value_BoolListVal); ok </span><span class="cov8" title="1">{
                return x.BoolListVal
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Value) GetUnixTimestampListVal() *Int64List <span class="cov8" title="1">{
        if x, ok := x.GetVal().(*Value_UnixTimestampListVal); ok </span><span class="cov8" title="1">{
                return x.UnixTimestampListVal
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (x *Value) GetNullVal() Null <span class="cov0" title="0">{
        if x, ok := x.GetVal().(*Value_NullVal); ok </span><span class="cov0" title="0">{
                return x.NullVal
        }</span>
        <span class="cov0" title="0">return Null_NULL</span>
}

type isValue_Val interface {
        isValue_Val()
}

type Value_BytesVal struct {
        BytesVal []byte `protobuf:"bytes,1,opt,name=bytes_val,json=bytesVal,proto3,oneof"`
}

type Value_StringVal struct {
        StringVal string `protobuf:"bytes,2,opt,name=string_val,json=stringVal,proto3,oneof"`
}

type Value_Int32Val struct {
        Int32Val int32 `protobuf:"varint,3,opt,name=int32_val,json=int32Val,proto3,oneof"`
}

type Value_Int64Val struct {
        Int64Val int64 `protobuf:"varint,4,opt,name=int64_val,json=int64Val,proto3,oneof"`
}

type Value_DoubleVal struct {
        DoubleVal float64 `protobuf:"fixed64,5,opt,name=double_val,json=doubleVal,proto3,oneof"`
}

type Value_FloatVal struct {
        FloatVal float32 `protobuf:"fixed32,6,opt,name=float_val,json=floatVal,proto3,oneof"`
}

type Value_BoolVal struct {
        BoolVal bool `protobuf:"varint,7,opt,name=bool_val,json=boolVal,proto3,oneof"`
}

type Value_UnixTimestampVal struct {
        UnixTimestampVal int64 `protobuf:"varint,8,opt,name=unix_timestamp_val,json=unixTimestampVal,proto3,oneof"`
}

type Value_BytesListVal struct {
        BytesListVal *BytesList `protobuf:"bytes,11,opt,name=bytes_list_val,json=bytesListVal,proto3,oneof"`
}

type Value_StringListVal struct {
        StringListVal *StringList `protobuf:"bytes,12,opt,name=string_list_val,json=stringListVal,proto3,oneof"`
}

type Value_Int32ListVal struct {
        Int32ListVal *Int32List `protobuf:"bytes,13,opt,name=int32_list_val,json=int32ListVal,proto3,oneof"`
}

type Value_Int64ListVal struct {
        Int64ListVal *Int64List `protobuf:"bytes,14,opt,name=int64_list_val,json=int64ListVal,proto3,oneof"`
}

type Value_DoubleListVal struct {
        DoubleListVal *DoubleList `protobuf:"bytes,15,opt,name=double_list_val,json=doubleListVal,proto3,oneof"`
}

type Value_FloatListVal struct {
        FloatListVal *FloatList `protobuf:"bytes,16,opt,name=float_list_val,json=floatListVal,proto3,oneof"`
}

type Value_BoolListVal struct {
        BoolListVal *BoolList `protobuf:"bytes,17,opt,name=bool_list_val,json=boolListVal,proto3,oneof"`
}

type Value_UnixTimestampListVal struct {
        UnixTimestampListVal *Int64List `protobuf:"bytes,18,opt,name=unix_timestamp_list_val,json=unixTimestampListVal,proto3,oneof"`
}

type Value_NullVal struct {
        NullVal Null `protobuf:"varint,19,opt,name=null_val,json=nullVal,proto3,enum=feast.types.Null,oneof"`
}

func (*Value_BytesVal) isValue_Val() {<span class="cov0" title="0">}</span>

func (*Value_StringVal) isValue_Val() {<span class="cov0" title="0">}</span>

func (*Value_Int32Val) isValue_Val() {<span class="cov0" title="0">}</span>

func (*Value_Int64Val) isValue_Val() {<span class="cov0" title="0">}</span>

func (*Value_DoubleVal) isValue_Val() {<span class="cov0" title="0">}</span>

func (*Value_FloatVal) isValue_Val() {<span class="cov0" title="0">}</span>

func (*Value_BoolVal) isValue_Val() {<span class="cov0" title="0">}</span>

func (*Value_UnixTimestampVal) isValue_Val() {<span class="cov0" title="0">}</span>

func (*Value_BytesListVal) isValue_Val() {<span class="cov0" title="0">}</span>

func (*Value_StringListVal) isValue_Val() {<span class="cov0" title="0">}</span>

func (*Value_Int32ListVal) isValue_Val() {<span class="cov0" title="0">}</span>

func (*Value_Int64ListVal) isValue_Val() {<span class="cov0" title="0">}</span>

func (*Value_DoubleListVal) isValue_Val() {<span class="cov0" title="0">}</span>

func (*Value_FloatListVal) isValue_Val() {<span class="cov0" title="0">}</span>

func (*Value_BoolListVal) isValue_Val() {<span class="cov0" title="0">}</span>

func (*Value_UnixTimestampListVal) isValue_Val() {<span class="cov0" title="0">}</span>

func (*Value_NullVal) isValue_Val() {<span class="cov0" title="0">}</span>

type BytesList struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Val [][]byte `protobuf:"bytes,1,rep,name=val,proto3" json:"val,omitempty"`
}

func (x *BytesList) Reset() <span class="cov0" title="0">{
        *x = BytesList{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_types_Value_proto_msgTypes[2]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *BytesList) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*BytesList) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *BytesList) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_types_Value_proto_msgTypes[2]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov8" title="1">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov8" title="1">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov8" title="1">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use BytesList.ProtoReflect.Descriptor instead.
func (*BytesList) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_types_Value_proto_rawDescGZIP(), []int{2}
}</span>

func (x *BytesList) GetVal() [][]byte <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.Val
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type StringList struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Val []string `protobuf:"bytes,1,rep,name=val,proto3" json:"val,omitempty"`
}

func (x *StringList) Reset() <span class="cov0" title="0">{
        *x = StringList{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_types_Value_proto_msgTypes[3]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *StringList) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*StringList) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *StringList) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_types_Value_proto_msgTypes[3]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov8" title="1">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov8" title="1">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov8" title="1">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use StringList.ProtoReflect.Descriptor instead.
func (*StringList) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_types_Value_proto_rawDescGZIP(), []int{3}
}</span>

func (x *StringList) GetVal() []string <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.Val
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Int32List struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Val []int32 `protobuf:"varint,1,rep,packed,name=val,proto3" json:"val,omitempty"`
}

func (x *Int32List) Reset() <span class="cov0" title="0">{
        *x = Int32List{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_types_Value_proto_msgTypes[4]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Int32List) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Int32List) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Int32List) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_types_Value_proto_msgTypes[4]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov8" title="1">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov8" title="1">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov8" title="1">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use Int32List.ProtoReflect.Descriptor instead.
func (*Int32List) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_types_Value_proto_rawDescGZIP(), []int{4}
}</span>

func (x *Int32List) GetVal() []int32 <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.Val
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type Int64List struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Val []int64 `protobuf:"varint,1,rep,packed,name=val,proto3" json:"val,omitempty"`
}

func (x *Int64List) Reset() <span class="cov0" title="0">{
        *x = Int64List{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_types_Value_proto_msgTypes[5]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *Int64List) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*Int64List) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *Int64List) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_types_Value_proto_msgTypes[5]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov8" title="1">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov8" title="1">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov8" title="1">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use Int64List.ProtoReflect.Descriptor instead.
func (*Int64List) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_types_Value_proto_rawDescGZIP(), []int{5}
}</span>

func (x *Int64List) GetVal() []int64 <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.Val
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type DoubleList struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Val []float64 `protobuf:"fixed64,1,rep,packed,name=val,proto3" json:"val,omitempty"`
}

func (x *DoubleList) Reset() <span class="cov0" title="0">{
        *x = DoubleList{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_types_Value_proto_msgTypes[6]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *DoubleList) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*DoubleList) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *DoubleList) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_types_Value_proto_msgTypes[6]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov8" title="1">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov8" title="1">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov8" title="1">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use DoubleList.ProtoReflect.Descriptor instead.
func (*DoubleList) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_types_Value_proto_rawDescGZIP(), []int{6}
}</span>

func (x *DoubleList) GetVal() []float64 <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.Val
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type FloatList struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Val []float32 `protobuf:"fixed32,1,rep,packed,name=val,proto3" json:"val,omitempty"`
}

func (x *FloatList) Reset() <span class="cov0" title="0">{
        *x = FloatList{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_types_Value_proto_msgTypes[7]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *FloatList) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*FloatList) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *FloatList) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_types_Value_proto_msgTypes[7]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov8" title="1">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov8" title="1">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov8" title="1">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use FloatList.ProtoReflect.Descriptor instead.
func (*FloatList) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_types_Value_proto_rawDescGZIP(), []int{7}
}</span>

func (x *FloatList) GetVal() []float32 <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.Val
        }</span>
        <span class="cov0" title="0">return nil</span>
}

type BoolList struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Val []bool `protobuf:"varint,1,rep,packed,name=val,proto3" json:"val,omitempty"`
}

func (x *BoolList) Reset() <span class="cov0" title="0">{
        *x = BoolList{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_types_Value_proto_msgTypes[8]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *BoolList) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*BoolList) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *BoolList) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_types_Value_proto_msgTypes[8]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov8" title="1">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov8" title="1">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov8" title="1">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use BoolList.ProtoReflect.Descriptor instead.
func (*BoolList) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_types_Value_proto_rawDescGZIP(), []int{8}
}</span>

func (x *BoolList) GetVal() []bool <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.Val
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// This is to avoid an issue of being unable to specify `repeated value` in oneofs or maps
// In JSON "val" field can be omitted
type RepeatedValue struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Val []*Value `protobuf:"bytes,1,rep,name=val,proto3" json:"val,omitempty"`
}

func (x *RepeatedValue) Reset() <span class="cov0" title="0">{
        *x = RepeatedValue{}
        if protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                mi := &amp;file_feast_types_Value_proto_msgTypes[9]
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                ms.StoreMessageInfo(mi)
        }</span>
}

func (x *RepeatedValue) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*RepeatedValue) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *RepeatedValue) ProtoReflect() protoreflect.Message <span class="cov8" title="1">{
        mi := &amp;file_feast_types_Value_proto_msgTypes[9]
        if protoimpl.UnsafeEnabled &amp;&amp; x != nil </span><span class="cov8" title="1">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov8" title="1">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov8" title="1">return ms</span>
        }
        <span class="cov8" title="1">return mi.MessageOf(x)</span>
}

// Deprecated: Use RepeatedValue.ProtoReflect.Descriptor instead.
func (*RepeatedValue) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_feast_types_Value_proto_rawDescGZIP(), []int{9}
}</span>

func (x *RepeatedValue) GetVal() []*Value <span class="cov8" title="1">{
        if x != nil </span><span class="cov8" title="1">{
                return x.Val
        }</span>
        <span class="cov0" title="0">return nil</span>
}

var File_feast_types_Value_proto protoreflect.FileDescriptor

var file_feast_types_Value_proto_rawDesc = []byte{
        0x0a, 0x17, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2f, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2f, 0x56, 0x61,
        0x6c, 0x75, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0b, 0x66, 0x65, 0x61, 0x73, 0x74,
        0x2e, 0x74, 0x79, 0x70, 0x65, 0x73, 0x22, 0x97, 0x02, 0x0a, 0x09, 0x56, 0x61, 0x6c, 0x75, 0x65,
        0x54, 0x79, 0x70, 0x65, 0x22, 0x89, 0x02, 0x0a, 0x04, 0x45, 0x6e, 0x75, 0x6d, 0x12, 0x0b, 0x0a,
        0x07, 0x49, 0x4e, 0x56, 0x41, 0x4c, 0x49, 0x44, 0x10, 0x00, 0x12, 0x09, 0x0a, 0x05, 0x42, 0x59,
        0x54, 0x45, 0x53, 0x10, 0x01, 0x12, 0x0a, 0x0a, 0x06, 0x53, 0x54, 0x52, 0x49, 0x4e, 0x47, 0x10,
        0x02, 0x12, 0x09, 0x0a, 0x05, 0x49, 0x4e, 0x54, 0x33, 0x32, 0x10, 0x03, 0x12, 0x09, 0x0a, 0x05,
        0x49, 0x4e, 0x54, 0x36, 0x34, 0x10, 0x04, 0x12, 0x0a, 0x0a, 0x06, 0x44, 0x4f, 0x55, 0x42, 0x4c,
        0x45, 0x10, 0x05, 0x12, 0x09, 0x0a, 0x05, 0x46, 0x4c, 0x4f, 0x41, 0x54, 0x10, 0x06, 0x12, 0x08,
        0x0a, 0x04, 0x42, 0x4f, 0x4f, 0x4c, 0x10, 0x07, 0x12, 0x12, 0x0a, 0x0e, 0x55, 0x4e, 0x49, 0x58,
        0x5f, 0x54, 0x49, 0x4d, 0x45, 0x53, 0x54, 0x41, 0x4d, 0x50, 0x10, 0x08, 0x12, 0x0e, 0x0a, 0x0a,
        0x42, 0x59, 0x54, 0x45, 0x53, 0x5f, 0x4c, 0x49, 0x53, 0x54, 0x10, 0x0b, 0x12, 0x0f, 0x0a, 0x0b,
        0x53, 0x54, 0x52, 0x49, 0x4e, 0x47, 0x5f, 0x4c, 0x49, 0x53, 0x54, 0x10, 0x0c, 0x12, 0x0e, 0x0a,
        0x0a, 0x49, 0x4e, 0x54, 0x33, 0x32, 0x5f, 0x4c, 0x49, 0x53, 0x54, 0x10, 0x0d, 0x12, 0x0e, 0x0a,
        0x0a, 0x49, 0x4e, 0x54, 0x36, 0x34, 0x5f, 0x4c, 0x49, 0x53, 0x54, 0x10, 0x0e, 0x12, 0x0f, 0x0a,
        0x0b, 0x44, 0x4f, 0x55, 0x42, 0x4c, 0x45, 0x5f, 0x4c, 0x49, 0x53, 0x54, 0x10, 0x0f, 0x12, 0x0e,
        0x0a, 0x0a, 0x46, 0x4c, 0x4f, 0x41, 0x54, 0x5f, 0x4c, 0x49, 0x53, 0x54, 0x10, 0x10, 0x12, 0x0d,
        0x0a, 0x09, 0x42, 0x4f, 0x4f, 0x4c, 0x5f, 0x4c, 0x49, 0x53, 0x54, 0x10, 0x11, 0x12, 0x17, 0x0a,
        0x13, 0x55, 0x4e, 0x49, 0x58, 0x5f, 0x54, 0x49, 0x4d, 0x45, 0x53, 0x54, 0x41, 0x4d, 0x50, 0x5f,
        0x4c, 0x49, 0x53, 0x54, 0x10, 0x12, 0x12, 0x08, 0x0a, 0x04, 0x4e, 0x55, 0x4c, 0x4c, 0x10, 0x13,
        0x22, 0xdd, 0x06, 0x0a, 0x05, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x1d, 0x0a, 0x09, 0x62, 0x79,
        0x74, 0x65, 0x73, 0x5f, 0x76, 0x61, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x48, 0x00, 0x52,
        0x08, 0x62, 0x79, 0x74, 0x65, 0x73, 0x56, 0x61, 0x6c, 0x12, 0x1f, 0x0a, 0x0a, 0x73, 0x74, 0x72,
        0x69, 0x6e, 0x67, 0x5f, 0x76, 0x61, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x48, 0x00, 0x52,
        0x09, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x56, 0x61, 0x6c, 0x12, 0x1d, 0x0a, 0x09, 0x69, 0x6e,
        0x74, 0x33, 0x32, 0x5f, 0x76, 0x61, 0x6c, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x48, 0x00, 0x52,
        0x08, 0x69, 0x6e, 0x74, 0x33, 0x32, 0x56, 0x61, 0x6c, 0x12, 0x1d, 0x0a, 0x09, 0x69, 0x6e, 0x74,
        0x36, 0x34, 0x5f, 0x76, 0x61, 0x6c, 0x18, 0x04, 0x20, 0x01, 0x28, 0x03, 0x48, 0x00, 0x52, 0x08,
        0x69, 0x6e, 0x74, 0x36, 0x34, 0x56, 0x61, 0x6c, 0x12, 0x1f, 0x0a, 0x0a, 0x64, 0x6f, 0x75, 0x62,
        0x6c, 0x65, 0x5f, 0x76, 0x61, 0x6c, 0x18, 0x05, 0x20, 0x01, 0x28, 0x01, 0x48, 0x00, 0x52, 0x09,
        0x64, 0x6f, 0x75, 0x62, 0x6c, 0x65, 0x56, 0x61, 0x6c, 0x12, 0x1d, 0x0a, 0x09, 0x66, 0x6c, 0x6f,
        0x61, 0x74, 0x5f, 0x76, 0x61, 0x6c, 0x18, 0x06, 0x20, 0x01, 0x28, 0x02, 0x48, 0x00, 0x52, 0x08,
        0x66, 0x6c, 0x6f, 0x61, 0x74, 0x56, 0x61, 0x6c, 0x12, 0x1b, 0x0a, 0x08, 0x62, 0x6f, 0x6f, 0x6c,
        0x5f, 0x76, 0x61, 0x6c, 0x18, 0x07, 0x20, 0x01, 0x28, 0x08, 0x48, 0x00, 0x52, 0x07, 0x62, 0x6f,
        0x6f, 0x6c, 0x56, 0x61, 0x6c, 0x12, 0x2e, 0x0a, 0x12, 0x75, 0x6e, 0x69, 0x78, 0x5f, 0x74, 0x69,
        0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x5f, 0x76, 0x61, 0x6c, 0x18, 0x08, 0x20, 0x01, 0x28,
        0x03, 0x48, 0x00, 0x52, 0x10, 0x75, 0x6e, 0x69, 0x78, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61,
        0x6d, 0x70, 0x56, 0x61, 0x6c, 0x12, 0x3e, 0x0a, 0x0e, 0x62, 0x79, 0x74, 0x65, 0x73, 0x5f, 0x6c,
        0x69, 0x73, 0x74, 0x5f, 0x76, 0x61, 0x6c, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e,
        0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2e, 0x42, 0x79, 0x74, 0x65,
        0x73, 0x4c, 0x69, 0x73, 0x74, 0x48, 0x00, 0x52, 0x0c, 0x62, 0x79, 0x74, 0x65, 0x73, 0x4c, 0x69,
        0x73, 0x74, 0x56, 0x61, 0x6c, 0x12, 0x41, 0x0a, 0x0f, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x5f,
        0x6c, 0x69, 0x73, 0x74, 0x5f, 0x76, 0x61, 0x6c, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17,
        0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2e, 0x53, 0x74, 0x72,
        0x69, 0x6e, 0x67, 0x4c, 0x69, 0x73, 0x74, 0x48, 0x00, 0x52, 0x0d, 0x73, 0x74, 0x72, 0x69, 0x6e,
        0x67, 0x4c, 0x69, 0x73, 0x74, 0x56, 0x61, 0x6c, 0x12, 0x3e, 0x0a, 0x0e, 0x69, 0x6e, 0x74, 0x33,
        0x32, 0x5f, 0x6c, 0x69, 0x73, 0x74, 0x5f, 0x76, 0x61, 0x6c, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x0b,
        0x32, 0x16, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2e, 0x49,
        0x6e, 0x74, 0x33, 0x32, 0x4c, 0x69, 0x73, 0x74, 0x48, 0x00, 0x52, 0x0c, 0x69, 0x6e, 0x74, 0x33,
        0x32, 0x4c, 0x69, 0x73, 0x74, 0x56, 0x61, 0x6c, 0x12, 0x3e, 0x0a, 0x0e, 0x69, 0x6e, 0x74, 0x36,
        0x34, 0x5f, 0x6c, 0x69, 0x73, 0x74, 0x5f, 0x76, 0x61, 0x6c, 0x18, 0x0e, 0x20, 0x01, 0x28, 0x0b,
        0x32, 0x16, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2e, 0x49,
        0x6e, 0x74, 0x36, 0x34, 0x4c, 0x69, 0x73, 0x74, 0x48, 0x00, 0x52, 0x0c, 0x69, 0x6e, 0x74, 0x36,
        0x34, 0x4c, 0x69, 0x73, 0x74, 0x56, 0x61, 0x6c, 0x12, 0x41, 0x0a, 0x0f, 0x64, 0x6f, 0x75, 0x62,
        0x6c, 0x65, 0x5f, 0x6c, 0x69, 0x73, 0x74, 0x5f, 0x76, 0x61, 0x6c, 0x18, 0x0f, 0x20, 0x01, 0x28,
        0x0b, 0x32, 0x17, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2e,
        0x44, 0x6f, 0x75, 0x62, 0x6c, 0x65, 0x4c, 0x69, 0x73, 0x74, 0x48, 0x00, 0x52, 0x0d, 0x64, 0x6f,
        0x75, 0x62, 0x6c, 0x65, 0x4c, 0x69, 0x73, 0x74, 0x56, 0x61, 0x6c, 0x12, 0x3e, 0x0a, 0x0e, 0x66,
        0x6c, 0x6f, 0x61, 0x74, 0x5f, 0x6c, 0x69, 0x73, 0x74, 0x5f, 0x76, 0x61, 0x6c, 0x18, 0x10, 0x20,
        0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x74, 0x79, 0x70, 0x65,
        0x73, 0x2e, 0x46, 0x6c, 0x6f, 0x61, 0x74, 0x4c, 0x69, 0x73, 0x74, 0x48, 0x00, 0x52, 0x0c, 0x66,
        0x6c, 0x6f, 0x61, 0x74, 0x4c, 0x69, 0x73, 0x74, 0x56, 0x61, 0x6c, 0x12, 0x3b, 0x0a, 0x0d, 0x62,
        0x6f, 0x6f, 0x6c, 0x5f, 0x6c, 0x69, 0x73, 0x74, 0x5f, 0x76, 0x61, 0x6c, 0x18, 0x11, 0x20, 0x01,
        0x28, 0x0b, 0x32, 0x15, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x74, 0x79, 0x70, 0x65, 0x73,
        0x2e, 0x42, 0x6f, 0x6f, 0x6c, 0x4c, 0x69, 0x73, 0x74, 0x48, 0x00, 0x52, 0x0b, 0x62, 0x6f, 0x6f,
        0x6c, 0x4c, 0x69, 0x73, 0x74, 0x56, 0x61, 0x6c, 0x12, 0x4f, 0x0a, 0x17, 0x75, 0x6e, 0x69, 0x78,
        0x5f, 0x74, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x5f, 0x6c, 0x69, 0x73, 0x74, 0x5f,
        0x76, 0x61, 0x6c, 0x18, 0x12, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x16, 0x2e, 0x66, 0x65, 0x61, 0x73,
        0x74, 0x2e, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2e, 0x49, 0x6e, 0x74, 0x36, 0x34, 0x4c, 0x69, 0x73,
        0x74, 0x48, 0x00, 0x52, 0x14, 0x75, 0x6e, 0x69, 0x78, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61,
        0x6d, 0x70, 0x4c, 0x69, 0x73, 0x74, 0x56, 0x61, 0x6c, 0x12, 0x2e, 0x0a, 0x08, 0x6e, 0x75, 0x6c,
        0x6c, 0x5f, 0x76, 0x61, 0x6c, 0x18, 0x13, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x11, 0x2e, 0x66, 0x65,
        0x61, 0x73, 0x74, 0x2e, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2e, 0x4e, 0x75, 0x6c, 0x6c, 0x48, 0x00,
        0x52, 0x07, 0x6e, 0x75, 0x6c, 0x6c, 0x56, 0x61, 0x6c, 0x42, 0x05, 0x0a, 0x03, 0x76, 0x61, 0x6c,
        0x22, 0x1d, 0x0a, 0x09, 0x42, 0x79, 0x74, 0x65, 0x73, 0x4c, 0x69, 0x73, 0x74, 0x12, 0x10, 0x0a,
        0x03, 0x76, 0x61, 0x6c, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0c, 0x52, 0x03, 0x76, 0x61, 0x6c, 0x22,
        0x1e, 0x0a, 0x0a, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x4c, 0x69, 0x73, 0x74, 0x12, 0x10, 0x0a,
        0x03, 0x76, 0x61, 0x6c, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x03, 0x76, 0x61, 0x6c, 0x22,
        0x1d, 0x0a, 0x09, 0x49, 0x6e, 0x74, 0x33, 0x32, 0x4c, 0x69, 0x73, 0x74, 0x12, 0x10, 0x0a, 0x03,
        0x76, 0x61, 0x6c, 0x18, 0x01, 0x20, 0x03, 0x28, 0x05, 0x52, 0x03, 0x76, 0x61, 0x6c, 0x22, 0x1d,
        0x0a, 0x09, 0x49, 0x6e, 0x74, 0x36, 0x34, 0x4c, 0x69, 0x73, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x76,
        0x61, 0x6c, 0x18, 0x01, 0x20, 0x03, 0x28, 0x03, 0x52, 0x03, 0x76, 0x61, 0x6c, 0x22, 0x1e, 0x0a,
        0x0a, 0x44, 0x6f, 0x75, 0x62, 0x6c, 0x65, 0x4c, 0x69, 0x73, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x76,
        0x61, 0x6c, 0x18, 0x01, 0x20, 0x03, 0x28, 0x01, 0x52, 0x03, 0x76, 0x61, 0x6c, 0x22, 0x1d, 0x0a,
        0x09, 0x46, 0x6c, 0x6f, 0x61, 0x74, 0x4c, 0x69, 0x73, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x76, 0x61,
        0x6c, 0x18, 0x01, 0x20, 0x03, 0x28, 0x02, 0x52, 0x03, 0x76, 0x61, 0x6c, 0x22, 0x1c, 0x0a, 0x08,
        0x42, 0x6f, 0x6f, 0x6c, 0x4c, 0x69, 0x73, 0x74, 0x12, 0x10, 0x0a, 0x03, 0x76, 0x61, 0x6c, 0x18,
        0x01, 0x20, 0x03, 0x28, 0x08, 0x52, 0x03, 0x76, 0x61, 0x6c, 0x22, 0x35, 0x0a, 0x0d, 0x52, 0x65,
        0x70, 0x65, 0x61, 0x74, 0x65, 0x64, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x24, 0x0a, 0x03, 0x76,
        0x61, 0x6c, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x66, 0x65, 0x61, 0x73, 0x74,
        0x2e, 0x74, 0x79, 0x70, 0x65, 0x73, 0x2e, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x52, 0x03, 0x76, 0x61,
        0x6c, 0x2a, 0x10, 0x0a, 0x04, 0x4e, 0x75, 0x6c, 0x6c, 0x12, 0x08, 0x0a, 0x04, 0x4e, 0x55, 0x4c,
        0x4c, 0x10, 0x00, 0x42, 0x51, 0x0a, 0x11, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2e, 0x70, 0x72, 0x6f,
        0x74, 0x6f, 0x2e, 0x74, 0x79, 0x70, 0x65, 0x73, 0x42, 0x0a, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x50,
        0x72, 0x6f, 0x74, 0x6f, 0x5a, 0x30, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d,
        0x2f, 0x66, 0x65, 0x61, 0x73, 0x74, 0x2d, 0x64, 0x65, 0x76, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74,
        0x2f, 0x67, 0x6f, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x73, 0x2f, 0x66, 0x65, 0x61, 0x73, 0x74,
        0x2f, 0x74, 0x79, 0x70, 0x65, 0x73, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_feast_types_Value_proto_rawDescOnce sync.Once
        file_feast_types_Value_proto_rawDescData = file_feast_types_Value_proto_rawDesc
)

func file_feast_types_Value_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_feast_types_Value_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_feast_types_Value_proto_rawDescData = protoimpl.X.CompressGZIP(file_feast_types_Value_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_feast_types_Value_proto_rawDescData</span>
}

var file_feast_types_Value_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_feast_types_Value_proto_msgTypes = make([]protoimpl.MessageInfo, 10)
var file_feast_types_Value_proto_goTypes = []interface{}{
        (Null)(0),             // 0: feast.types.Null
        (ValueType_Enum)(0),   // 1: feast.types.ValueType.Enum
        (*ValueType)(nil),     // 2: feast.types.ValueType
        (*Value)(nil),         // 3: feast.types.Value
        (*BytesList)(nil),     // 4: feast.types.BytesList
        (*StringList)(nil),    // 5: feast.types.StringList
        (*Int32List)(nil),     // 6: feast.types.Int32List
        (*Int64List)(nil),     // 7: feast.types.Int64List
        (*DoubleList)(nil),    // 8: feast.types.DoubleList
        (*FloatList)(nil),     // 9: feast.types.FloatList
        (*BoolList)(nil),      // 10: feast.types.BoolList
        (*RepeatedValue)(nil), // 11: feast.types.RepeatedValue
}
var file_feast_types_Value_proto_depIdxs = []int32{
        4,  // 0: feast.types.Value.bytes_list_val:type_name -&gt; feast.types.BytesList
        5,  // 1: feast.types.Value.string_list_val:type_name -&gt; feast.types.StringList
        6,  // 2: feast.types.Value.int32_list_val:type_name -&gt; feast.types.Int32List
        7,  // 3: feast.types.Value.int64_list_val:type_name -&gt; feast.types.Int64List
        8,  // 4: feast.types.Value.double_list_val:type_name -&gt; feast.types.DoubleList
        9,  // 5: feast.types.Value.float_list_val:type_name -&gt; feast.types.FloatList
        10, // 6: feast.types.Value.bool_list_val:type_name -&gt; feast.types.BoolList
        7,  // 7: feast.types.Value.unix_timestamp_list_val:type_name -&gt; feast.types.Int64List
        0,  // 8: feast.types.Value.null_val:type_name -&gt; feast.types.Null
        3,  // 9: feast.types.RepeatedValue.val:type_name -&gt; feast.types.Value
        10, // [10:10] is the sub-list for method output_type
        10, // [10:10] is the sub-list for method input_type
        10, // [10:10] is the sub-list for extension type_name
        10, // [10:10] is the sub-list for extension extendee
        0,  // [0:10] is the sub-list for field type_name
}

func init() <span class="cov8" title="1">{ file_feast_types_Value_proto_init() }</span>
func file_feast_types_Value_proto_init() <span class="cov8" title="1">{
        if File_feast_types_Value_proto != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if !protoimpl.UnsafeEnabled </span><span class="cov0" title="0">{
                file_feast_types_Value_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*ValueType); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_types_Value_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Value); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_types_Value_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*BytesList); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_types_Value_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*StringList); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_types_Value_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Int32List); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_types_Value_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*Int64List); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_types_Value_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*DoubleList); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_types_Value_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*FloatList); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_types_Value_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*BoolList); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
                <span class="cov0" title="0">file_feast_types_Value_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} </span><span class="cov0" title="0">{
                        switch v := v.(*RepeatedValue); i </span>{
                        case 0:<span class="cov0" title="0">
                                return &amp;v.state</span>
                        case 1:<span class="cov0" title="0">
                                return &amp;v.sizeCache</span>
                        case 2:<span class="cov0" title="0">
                                return &amp;v.unknownFields</span>
                        default:<span class="cov0" title="0">
                                return nil</span>
                        }
                }
        }
        <span class="cov8" title="1">file_feast_types_Value_proto_msgTypes[1].OneofWrappers = []interface{}{
                (*Value_BytesVal)(nil),
                (*Value_StringVal)(nil),
                (*Value_Int32Val)(nil),
                (*Value_Int64Val)(nil),
                (*Value_DoubleVal)(nil),
                (*Value_FloatVal)(nil),
                (*Value_BoolVal)(nil),
                (*Value_UnixTimestampVal)(nil),
                (*Value_BytesListVal)(nil),
                (*Value_StringListVal)(nil),
                (*Value_Int32ListVal)(nil),
                (*Value_Int64ListVal)(nil),
                (*Value_DoubleListVal)(nil),
                (*Value_FloatListVal)(nil),
                (*Value_BoolListVal)(nil),
                (*Value_UnixTimestampListVal)(nil),
                (*Value_NullVal)(nil),
        }
        type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_feast_types_Value_proto_rawDesc,
                        NumEnums:      2,
                        NumMessages:   10,
                        NumExtensions: 0,
                        NumServices:   0,
                },
                GoTypes:           file_feast_types_Value_proto_goTypes,
                DependencyIndexes: file_feast_types_Value_proto_depIdxs,
                EnumInfos:         file_feast_types_Value_proto_enumTypes,
                MessageInfos:      file_feast_types_Value_proto_msgTypes,
        }.Build()
        File_feast_types_Value_proto = out.File
        file_feast_types_Value_proto_rawDesc = nil
        file_feast_types_Value_proto_goTypes = nil
        file_feast_types_Value_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file68" style="display: none">package types

import (
        "fmt"

        "github.com/apache/arrow/go/v17/arrow"
        "github.com/apache/arrow/go/v17/arrow/array"
        "github.com/apache/arrow/go/v17/arrow/memory"

        "github.com/feast-dev/feast/go/protos/feast/types"
)

func ProtoTypeToArrowType(sample *types.Value) (arrow.DataType, error) <span class="cov8" title="1">{
        if sample.Val == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">switch sample.Val.(type) </span>{
        case *types.Value_BytesVal:<span class="cov8" title="1">
                return arrow.BinaryTypes.Binary, nil</span>
        case *types.Value_StringVal:<span class="cov8" title="1">
                return arrow.BinaryTypes.String, nil</span>
        case *types.Value_Int32Val:<span class="cov8" title="1">
                return arrow.PrimitiveTypes.Int32, nil</span>
        case *types.Value_Int64Val:<span class="cov8" title="1">
                return arrow.PrimitiveTypes.Int64, nil</span>
        case *types.Value_FloatVal:<span class="cov8" title="1">
                return arrow.PrimitiveTypes.Float32, nil</span>
        case *types.Value_DoubleVal:<span class="cov8" title="1">
                return arrow.PrimitiveTypes.Float64, nil</span>
        case *types.Value_BoolVal:<span class="cov8" title="1">
                return arrow.FixedWidthTypes.Boolean, nil</span>
        case *types.Value_BoolListVal:<span class="cov8" title="1">
                return arrow.ListOf(arrow.FixedWidthTypes.Boolean), nil</span>
        case *types.Value_StringListVal:<span class="cov8" title="1">
                return arrow.ListOf(arrow.BinaryTypes.String), nil</span>
        case *types.Value_BytesListVal:<span class="cov8" title="1">
                return arrow.ListOf(arrow.BinaryTypes.Binary), nil</span>
        case *types.Value_Int32ListVal:<span class="cov8" title="1">
                return arrow.ListOf(arrow.PrimitiveTypes.Int32), nil</span>
        case *types.Value_Int64ListVal:<span class="cov8" title="1">
                return arrow.ListOf(arrow.PrimitiveTypes.Int64), nil</span>
        case *types.Value_FloatListVal:<span class="cov8" title="1">
                return arrow.ListOf(arrow.PrimitiveTypes.Float32), nil</span>
        case *types.Value_DoubleListVal:<span class="cov8" title="1">
                return arrow.ListOf(arrow.PrimitiveTypes.Float64), nil</span>
        case *types.Value_UnixTimestampVal:<span class="cov8" title="1">
                return arrow.FixedWidthTypes.Timestamp_s, nil</span>
        case *types.Value_UnixTimestampListVal:<span class="cov8" title="1">
                return arrow.ListOf(arrow.FixedWidthTypes.Timestamp_s), nil</span>
        default:<span class="cov0" title="0">
                return nil,
                        fmt.Errorf("unsupported proto type in proto to arrow conversion: %s", sample.Val)</span>
        }
}

func ValueTypeEnumToArrowType(t types.ValueType_Enum) (arrow.DataType, error) <span class="cov0" title="0">{
        switch t </span>{
        case types.ValueType_BYTES:<span class="cov0" title="0">
                return arrow.BinaryTypes.Binary, nil</span>
        case types.ValueType_STRING:<span class="cov0" title="0">
                return arrow.BinaryTypes.String, nil</span>
        case types.ValueType_INT32:<span class="cov0" title="0">
                return arrow.PrimitiveTypes.Int32, nil</span>
        case types.ValueType_INT64:<span class="cov0" title="0">
                return arrow.PrimitiveTypes.Int64, nil</span>
        case types.ValueType_FLOAT:<span class="cov0" title="0">
                return arrow.PrimitiveTypes.Float32, nil</span>
        case types.ValueType_DOUBLE:<span class="cov0" title="0">
                return arrow.PrimitiveTypes.Float64, nil</span>
        case types.ValueType_BOOL:<span class="cov0" title="0">
                return arrow.FixedWidthTypes.Boolean, nil</span>
        case types.ValueType_BOOL_LIST:<span class="cov0" title="0">
                return arrow.ListOf(arrow.FixedWidthTypes.Boolean), nil</span>
        case types.ValueType_STRING_LIST:<span class="cov0" title="0">
                return arrow.ListOf(arrow.BinaryTypes.String), nil</span>
        case types.ValueType_BYTES_LIST:<span class="cov0" title="0">
                return arrow.ListOf(arrow.BinaryTypes.Binary), nil</span>
        case types.ValueType_INT32_LIST:<span class="cov0" title="0">
                return arrow.ListOf(arrow.PrimitiveTypes.Int32), nil</span>
        case types.ValueType_INT64_LIST:<span class="cov0" title="0">
                return arrow.ListOf(arrow.PrimitiveTypes.Int64), nil</span>
        case types.ValueType_FLOAT_LIST:<span class="cov0" title="0">
                return arrow.ListOf(arrow.PrimitiveTypes.Float32), nil</span>
        case types.ValueType_DOUBLE_LIST:<span class="cov0" title="0">
                return arrow.ListOf(arrow.PrimitiveTypes.Float64), nil</span>
        case types.ValueType_UNIX_TIMESTAMP:<span class="cov0" title="0">
                return arrow.FixedWidthTypes.Timestamp_s, nil</span>
        case types.ValueType_UNIX_TIMESTAMP_LIST:<span class="cov0" title="0">
                return arrow.ListOf(arrow.FixedWidthTypes.Timestamp_s), nil</span>
        default:<span class="cov0" title="0">
                return nil,
                        fmt.Errorf("unsupported value type enum in enum to arrow type conversion: %s", t)</span>
        }
}

func CopyProtoValuesToArrowArray(builder array.Builder, values []*types.Value) error <span class="cov8" title="1">{
        for _, value := range values </span><span class="cov8" title="1">{
                if value == nil || value.Val == nil </span><span class="cov8" title="1">{
                        builder.AppendNull()
                        continue</span>
                }

                <span class="cov8" title="1">switch fieldBuilder := builder.(type) </span>{

                case *array.BooleanBuilder:<span class="cov8" title="1">
                        fieldBuilder.Append(value.GetBoolVal())</span>
                case *array.BinaryBuilder:<span class="cov8" title="1">
                        fieldBuilder.Append(value.GetBytesVal())</span>
                case *array.StringBuilder:<span class="cov8" title="1">
                        fieldBuilder.Append(value.GetStringVal())</span>
                case *array.Int32Builder:<span class="cov8" title="1">
                        fieldBuilder.Append(value.GetInt32Val())</span>
                case *array.Int64Builder:<span class="cov8" title="1">
                        fieldBuilder.Append(value.GetInt64Val())</span>
                case *array.Float32Builder:<span class="cov8" title="1">
                        fieldBuilder.Append(value.GetFloatVal())</span>
                case *array.Float64Builder:<span class="cov8" title="1">
                        fieldBuilder.Append(value.GetDoubleVal())</span>
                case *array.TimestampBuilder:<span class="cov8" title="1">
                        fieldBuilder.Append(arrow.Timestamp(value.GetUnixTimestampVal()))</span>
                case *array.ListBuilder:<span class="cov8" title="1">
                        fieldBuilder.Append(true)

                        switch valueBuilder := fieldBuilder.ValueBuilder().(type) </span>{

                        case *array.BooleanBuilder:<span class="cov8" title="1">
                                for _, v := range value.GetBoolListVal().GetVal() </span><span class="cov8" title="1">{
                                        valueBuilder.Append(v)
                                }</span>
                        case *array.BinaryBuilder:<span class="cov8" title="1">
                                for _, v := range value.GetBytesListVal().GetVal() </span><span class="cov8" title="1">{
                                        valueBuilder.Append(v)
                                }</span>
                        case *array.StringBuilder:<span class="cov8" title="1">
                                for _, v := range value.GetStringListVal().GetVal() </span><span class="cov8" title="1">{
                                        valueBuilder.Append(v)
                                }</span>
                        case *array.Int32Builder:<span class="cov8" title="1">
                                for _, v := range value.GetInt32ListVal().GetVal() </span><span class="cov8" title="1">{
                                        valueBuilder.Append(v)
                                }</span>
                        case *array.Int64Builder:<span class="cov8" title="1">
                                for _, v := range value.GetInt64ListVal().GetVal() </span><span class="cov8" title="1">{
                                        valueBuilder.Append(v)
                                }</span>
                        case *array.Float32Builder:<span class="cov8" title="1">
                                for _, v := range value.GetFloatListVal().GetVal() </span><span class="cov8" title="1">{
                                        valueBuilder.Append(v)
                                }</span>
                        case *array.Float64Builder:<span class="cov8" title="1">
                                for _, v := range value.GetDoubleListVal().GetVal() </span><span class="cov8" title="1">{
                                        valueBuilder.Append(v)
                                }</span>
                        case *array.TimestampBuilder:<span class="cov8" title="1">
                                for _, v := range value.GetUnixTimestampListVal().GetVal() </span><span class="cov8" title="1">{
                                        valueBuilder.Append(arrow.Timestamp(v))
                                }</span>
                        }
                default:<span class="cov0" title="0">
                        return fmt.Errorf("unsupported array builder: %s", builder)</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func ArrowValuesToProtoValues(arr arrow.Array) ([]*types.Value, error) <span class="cov8" title="1">{
        values := make([]*types.Value, 0)

        if listArr, ok := arr.(*array.List); ok </span><span class="cov8" title="1">{
                listValues := listArr.ListValues()
                offsets := listArr.Offsets()[1:]
                pos := 0
                for idx := 0; idx &lt; listArr.Len(); idx++ </span><span class="cov8" title="1">{
                        switch listValues.DataType() </span>{
                        case arrow.PrimitiveTypes.Int32:<span class="cov8" title="1">
                                vals := make([]int32, int(offsets[idx])-pos)
                                for j := pos; j &lt; int(offsets[idx]); j++ </span><span class="cov8" title="1">{
                                        vals[j-pos] = listValues.(*array.Int32).Value(j)
                                }</span>
                                <span class="cov8" title="1">values = append(values,
                                        &amp;types.Value{Val: &amp;types.Value_Int32ListVal{Int32ListVal: &amp;types.Int32List{Val: vals}}})</span>
                        case arrow.PrimitiveTypes.Int64:<span class="cov8" title="1">
                                vals := make([]int64, int(offsets[idx])-pos)
                                for j := pos; j &lt; int(offsets[idx]); j++ </span><span class="cov8" title="1">{
                                        vals[j-pos] = listValues.(*array.Int64).Value(j)
                                }</span>
                                <span class="cov8" title="1">values = append(values,
                                        &amp;types.Value{Val: &amp;types.Value_Int64ListVal{Int64ListVal: &amp;types.Int64List{Val: vals}}})</span>
                        case arrow.PrimitiveTypes.Float32:<span class="cov8" title="1">
                                vals := make([]float32, int(offsets[idx])-pos)
                                for j := pos; j &lt; int(offsets[idx]); j++ </span><span class="cov8" title="1">{
                                        vals[j-pos] = listValues.(*array.Float32).Value(j)
                                }</span>
                                <span class="cov8" title="1">values = append(values,
                                        &amp;types.Value{Val: &amp;types.Value_FloatListVal{FloatListVal: &amp;types.FloatList{Val: vals}}})</span>
                        case arrow.PrimitiveTypes.Float64:<span class="cov8" title="1">
                                vals := make([]float64, int(offsets[idx])-pos)
                                for j := pos; j &lt; int(offsets[idx]); j++ </span><span class="cov8" title="1">{
                                        vals[j-pos] = listValues.(*array.Float64).Value(j)
                                }</span>
                                <span class="cov8" title="1">values = append(values,
                                        &amp;types.Value{Val: &amp;types.Value_DoubleListVal{DoubleListVal: &amp;types.DoubleList{Val: vals}}})</span>
                        case arrow.BinaryTypes.Binary:<span class="cov8" title="1">
                                vals := make([][]byte, int(offsets[idx])-pos)
                                for j := pos; j &lt; int(offsets[idx]); j++ </span><span class="cov8" title="1">{
                                        vals[j-pos] = listValues.(*array.Binary).Value(j)
                                }</span>
                                <span class="cov8" title="1">values = append(values,
                                        &amp;types.Value{Val: &amp;types.Value_BytesListVal{BytesListVal: &amp;types.BytesList{Val: vals}}})</span>
                        case arrow.BinaryTypes.String:<span class="cov8" title="1">
                                vals := make([]string, int(offsets[idx])-pos)
                                for j := pos; j &lt; int(offsets[idx]); j++ </span><span class="cov8" title="1">{
                                        vals[j-pos] = listValues.(*array.String).Value(j)
                                }</span>
                                <span class="cov8" title="1">values = append(values,
                                        &amp;types.Value{Val: &amp;types.Value_StringListVal{StringListVal: &amp;types.StringList{Val: vals}}})</span>
                        case arrow.FixedWidthTypes.Boolean:<span class="cov8" title="1">
                                vals := make([]bool, int(offsets[idx])-pos)
                                for j := pos; j &lt; int(offsets[idx]); j++ </span><span class="cov8" title="1">{
                                        vals[j-pos] = listValues.(*array.Boolean).Value(j)
                                }</span>
                                <span class="cov8" title="1">values = append(values,
                                        &amp;types.Value{Val: &amp;types.Value_BoolListVal{BoolListVal: &amp;types.BoolList{Val: vals}}})</span>
                        case arrow.FixedWidthTypes.Timestamp_s:<span class="cov8" title="1">
                                vals := make([]int64, int(offsets[idx])-pos)
                                for j := pos; j &lt; int(offsets[idx]); j++ </span><span class="cov8" title="1">{
                                        vals[j-pos] = int64(listValues.(*array.Timestamp).Value(j))
                                }</span>

                                <span class="cov8" title="1">values = append(values,
                                        &amp;types.Value{Val: &amp;types.Value_UnixTimestampListVal{
                                                UnixTimestampListVal: &amp;types.Int64List{Val: vals}}})</span>

                        }

                        // set the end of current element as start of the next
                        <span class="cov8" title="1">pos = int(offsets[idx])</span>
                }

                <span class="cov8" title="1">return values, nil</span>
        }

        <span class="cov8" title="1">switch arr.DataType() </span>{
        case arrow.PrimitiveTypes.Int32:<span class="cov8" title="1">
                for idx := 0; idx &lt; arr.Len(); idx++ </span><span class="cov8" title="1">{
                        if arr.IsNull(idx) </span><span class="cov8" title="1">{
                                values = append(values, &amp;types.Value{})
                        }</span> else<span class="cov8" title="1"> {
                                values = append(values, &amp;types.Value{Val: &amp;types.Value_Int32Val{Int32Val: arr.(*array.Int32).Value(idx)}})
                        }</span>
                }
        case arrow.PrimitiveTypes.Int64:<span class="cov8" title="1">
                for idx := 0; idx &lt; arr.Len(); idx++ </span><span class="cov8" title="1">{
                        if arr.IsNull(idx) </span><span class="cov8" title="1">{
                                values = append(values, &amp;types.Value{})
                        }</span> else<span class="cov8" title="1"> {
                                values = append(values, &amp;types.Value{Val: &amp;types.Value_Int64Val{Int64Val: arr.(*array.Int64).Value(idx)}})
                        }</span>
                }
        case arrow.PrimitiveTypes.Float32:<span class="cov8" title="1">
                for idx := 0; idx &lt; arr.Len(); idx++ </span><span class="cov8" title="1">{
                        if arr.IsNull(idx) </span><span class="cov8" title="1">{
                                values = append(values, &amp;types.Value{})
                        }</span> else<span class="cov8" title="1"> {
                                values = append(values, &amp;types.Value{Val: &amp;types.Value_FloatVal{FloatVal: arr.(*array.Float32).Value(idx)}})
                        }</span>
                }
        case arrow.PrimitiveTypes.Float64:<span class="cov8" title="1">
                for idx := 0; idx &lt; arr.Len(); idx++ </span><span class="cov8" title="1">{
                        if arr.IsNull(idx) </span><span class="cov8" title="1">{
                                values = append(values, &amp;types.Value{})
                        }</span> else<span class="cov8" title="1"> {
                                values = append(values, &amp;types.Value{Val: &amp;types.Value_DoubleVal{DoubleVal: arr.(*array.Float64).Value(idx)}})
                        }</span>
                }
        case arrow.FixedWidthTypes.Boolean:<span class="cov8" title="1">
                for idx := 0; idx &lt; arr.Len(); idx++ </span><span class="cov8" title="1">{
                        if arr.IsNull(idx) </span><span class="cov8" title="1">{
                                values = append(values, &amp;types.Value{})
                        }</span> else<span class="cov8" title="1"> {
                                values = append(values, &amp;types.Value{Val: &amp;types.Value_BoolVal{BoolVal: arr.(*array.Boolean).Value(idx)}})
                        }</span>
                }
        case arrow.BinaryTypes.Binary:<span class="cov8" title="1">
                for idx := 0; idx &lt; arr.Len(); idx++ </span><span class="cov8" title="1">{
                        if arr.IsNull(idx) </span><span class="cov8" title="1">{
                                values = append(values, &amp;types.Value{})
                        }</span> else<span class="cov8" title="1"> {
                                values = append(values, &amp;types.Value{Val: &amp;types.Value_BytesVal{BytesVal: arr.(*array.Binary).Value(idx)}})
                        }</span>
                }
        case arrow.BinaryTypes.String:<span class="cov8" title="1">
                for idx := 0; idx &lt; arr.Len(); idx++ </span><span class="cov8" title="1">{
                        if arr.IsNull(idx) </span><span class="cov8" title="1">{
                                values = append(values, &amp;types.Value{})
                        }</span> else<span class="cov8" title="1"> {
                                values = append(values, &amp;types.Value{Val: &amp;types.Value_StringVal{StringVal: arr.(*array.String).Value(idx)}})
                        }</span>
                }
        case arrow.FixedWidthTypes.Timestamp_s:<span class="cov8" title="1">
                for idx := 0; idx &lt; arr.Len(); idx++ </span><span class="cov8" title="1">{
                        if arr.IsNull(idx) </span><span class="cov8" title="1">{
                                values = append(values, &amp;types.Value{})
                        }</span> else<span class="cov8" title="1"> {
                                values = append(values, &amp;types.Value{Val: &amp;types.Value_UnixTimestampVal{UnixTimestampVal: int64(arr.(*array.Timestamp).Value(idx))}})
                        }</span>
                }
        case arrow.Null:<span class="cov8" title="1">
                for idx := 0; idx &lt; arr.Len(); idx++ </span><span class="cov8" title="1">{
                        values = append(values, &amp;types.Value{})
                }</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported arrow to proto conversion for type %s", arr.DataType())</span>
        }

        <span class="cov8" title="1">return values, nil</span>
}

func ProtoValuesToArrowArray(protoValues []*types.Value, arrowAllocator memory.Allocator, numRows int) (arrow.Array, error) <span class="cov8" title="1">{
        var fieldType arrow.DataType
        var err error

        for _, val := range protoValues </span><span class="cov8" title="1">{
                if val != nil </span><span class="cov8" title="1">{
                        fieldType, err = ProtoTypeToArrowType(val)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">if fieldType != nil </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">if fieldType != nil </span><span class="cov8" title="1">{
                builder := array.NewBuilder(arrowAllocator, fieldType)
                err = CopyProtoValuesToArrowArray(builder, protoValues)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">return builder.NewArray(), nil</span>
        } else<span class="cov8" title="1"> {
                return array.NewNull(numRows), nil
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
