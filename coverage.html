
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>feast: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/feast-dev/feast/go/internal/feast/featurestore.go (11.4%)</option>
				
				<option value="file1">github.com/feast-dev/feast/go/internal/feast/onlineserving/serving.go (49.1%)</option>
				
				<option value="file2">github.com/feast-dev/feast/go/internal/feast/onlinestore/onlinestore.go (0.0%)</option>
				
				<option value="file3">github.com/feast-dev/feast/go/internal/feast/onlinestore/redisonlinestore.go (53.5%)</option>
				
				<option value="file4">github.com/feast-dev/feast/go/internal/feast/onlinestore/sqliteonlinestore.go (78.4%)</option>
				
				<option value="file5">github.com/feast-dev/feast/go/internal/feast/registry/http.go (67.4%)</option>
				
				<option value="file6">github.com/feast-dev/feast/go/internal/feast/registry/local.go (0.0%)</option>
				
				<option value="file7">github.com/feast-dev/feast/go/internal/feast/registry/registry.go (0.0%)</option>
				
				<option value="file8">github.com/feast-dev/feast/go/internal/feast/registry/repoconfig.go (88.5%)</option>
				
				<option value="file9">github.com/feast-dev/feast/go/internal/feast/server/grpc_server.go (75.0%)</option>
				
				<option value="file10">github.com/feast-dev/feast/go/internal/feast/server/http_server.go (22.4%)</option>
				
				<option value="file11">github.com/feast-dev/feast/go/internal/feast/server/logging/featureserviceschema.go (78.0%)</option>
				
				<option value="file12">github.com/feast-dev/feast/go/internal/feast/server/logging/filelogsink.go (75.0%)</option>
				
				<option value="file13">github.com/feast-dev/feast/go/internal/feast/server/logging/logger.go (71.0%)</option>
				
				<option value="file14">github.com/feast-dev/feast/go/internal/feast/server/logging/memorybuffer.go (82.4%)</option>
				
				<option value="file15">github.com/feast-dev/feast/go/internal/feast/server/logging/offlinestoresink.go (0.0%)</option>
				
				<option value="file16">github.com/feast-dev/feast/go/internal/feast/server/logging/service.go (0.0%)</option>
				
				<option value="file17">github.com/feast-dev/feast/go/internal/feast/server/server_commons.go (100.0%)</option>
				
				<option value="file18">github.com/feast-dev/feast/go/main.go (3.7%)</option>
				
				<option value="file19">github.com/feast-dev/feast/go/types/typeconversion.go (86.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package feast

import (
        "context"
        "errors"
        "fmt"
        "os"
        "strings"

        "github.com/apache/arrow/go/v8/arrow/memory"
        "gopkg.in/DataDog/dd-trace-go.v1/ddtrace/tracer"

        "github.com/feast-dev/feast/go/internal/feast/model"
        "github.com/feast-dev/feast/go/internal/feast/onlineserving"
        "github.com/feast-dev/feast/go/internal/feast/onlinestore"
        "github.com/feast-dev/feast/go/internal/feast/registry"
        "github.com/feast-dev/feast/go/internal/feast/transformation"
        "github.com/feast-dev/feast/go/protos/feast/serving"
        prototypes "github.com/feast-dev/feast/go/protos/feast/types"
)

type FeatureStoreInterface interface {
        GetOnlineFeatures(
                ctx context.Context,
                featureRefs []string,
                featureService *model.FeatureService,
                joinKeyToEntityValues map[string]*prototypes.RepeatedValue,
                requestData map[string]*prototypes.RepeatedValue,
                fullFeatureNames bool) ([]*onlineserving.FeatureVector, error)
}
type FeatureStore struct {
        config                 *registry.RepoConfig
        registry               *registry.Registry
        onlineStore            onlinestore.OnlineStore
        transformationCallback transformation.TransformationCallback
        transformationService  *transformation.GrpcTransformationService
}

// A Features struct specifies a list of features to be retrieved from the online store. These features
// can be specified either as a list of string feature references or as a feature service. String
// feature references must have format "feature_view:feature", e.g. "customer_fv:daily_transactions".
type Features struct {
        FeaturesRefs   []string
        FeatureService *model.FeatureService
}

func (fs *FeatureStore) Registry() *registry.Registry <span class="cov0" title="0">{
        return fs.registry
}</span>

func (fs *FeatureStore) GetRepoConfig() *registry.RepoConfig <span class="cov0" title="0">{
        return fs.config
}</span>

// NewFeatureStore constructs a feature store fat client using the
// repo config (contents of feature_store.yaml converted to JSON map).
func NewFeatureStore(config *registry.RepoConfig, callback transformation.TransformationCallback) (*FeatureStore, error) <span class="cov8" title="1">{
        onlineStore, err := onlinestore.NewOnlineStore(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">registryConfig, err := config.GetRegistryConfig()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">registry, err := registry.NewRegistry(registryConfig, config.RepoPath, config.Project)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">err = registry.InitializeRegistry()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">sanitizedProjectName := strings.Replace(config.Project, "_", "-", -1)
        productName := os.Getenv("PRODUCT")
        endpoint := fmt.Sprintf("%s-transformations.%s.svc.cluster.local:80", sanitizedProjectName, productName)
        transformationService, _ := transformation.NewGrpcTransformationService(config, endpoint)

        return &amp;FeatureStore{
                config:                 config,
                registry:               registry,
                onlineStore:            onlineStore,
                transformationCallback: callback,
                transformationService:  transformationService,
        }, nil</span>
}

// TODO: Review all functions that use ODFV and Request FV since these have not been tested
// ToDo: Split GetOnlineFeatures interface into two: GetOnlinFeaturesByFeatureService and GetOnlineFeaturesByFeatureRefs
func (fs *FeatureStore) GetOnlineFeatures(
        ctx context.Context,
        featureRefs []string,
        featureService *model.FeatureService,
        joinKeyToEntityValues map[string]*prototypes.RepeatedValue,
        requestData map[string]*prototypes.RepeatedValue,
        fullFeatureNames bool) ([]*onlineserving.FeatureVector, error) <span class="cov0" title="0">{
        fvs, odFvs, err := fs.ListAllViews()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">entities, err := fs.ListEntities(false)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var requestedFeatureViews []*onlineserving.FeatureViewAndRefs
        var requestedOnDemandFeatureViews []*model.OnDemandFeatureView
        if featureService != nil </span><span class="cov0" title="0">{
                requestedFeatureViews, requestedOnDemandFeatureViews, err =
                        onlineserving.GetFeatureViewsToUseByService(featureService, fvs, odFvs)
        }</span> else<span class="cov0" title="0"> {
                requestedFeatureViews, requestedOnDemandFeatureViews, err =
                        onlineserving.GetFeatureViewsToUseByFeatureRefs(featureRefs, fvs, odFvs)
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">entityNameToJoinKeyMap, expectedJoinKeysSet, err := onlineserving.GetEntityMaps(requestedFeatureViews, entities)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">err = onlineserving.ValidateFeatureRefs(requestedFeatureViews, fullFeatureNames)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">numRows, err := onlineserving.ValidateEntityValues(joinKeyToEntityValues, requestData, expectedJoinKeysSet)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">err = transformation.EnsureRequestedDataExist(requestedOnDemandFeatureViews, requestData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">result := make([]*onlineserving.FeatureVector, 0)
        arrowMemory := memory.NewGoAllocator()
        featureViews := make([]*model.FeatureView, len(requestedFeatureViews))
        index := 0
        for _, featuresAndView := range requestedFeatureViews </span><span class="cov0" title="0">{
                featureViews[index] = featuresAndView.View
                index += 1
        }</span>

        <span class="cov0" title="0">entitylessCase := false
        for _, featureView := range featureViews </span><span class="cov0" title="0">{
                if featureView.HasEntity(model.DUMMY_ENTITY_NAME) </span><span class="cov0" title="0">{
                        entitylessCase = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if entitylessCase </span><span class="cov0" title="0">{
                dummyEntityColumn := &amp;prototypes.RepeatedValue{Val: make([]*prototypes.Value, numRows)}
                for index := 0; index &lt; numRows; index++ </span><span class="cov0" title="0">{
                        dummyEntityColumn.Val[index] = &amp;model.DUMMY_ENTITY_VALUE
                }</span>
                <span class="cov0" title="0">joinKeyToEntityValues[model.DUMMY_ENTITY_ID] = dummyEntityColumn</span>
        }

        <span class="cov0" title="0">groupedRefs, err := onlineserving.GroupFeatureRefs(requestedFeatureViews, joinKeyToEntityValues, entityNameToJoinKeyMap, fullFeatureNames)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">for _, groupRef := range groupedRefs </span><span class="cov0" title="0">{
                featureData, err := fs.readFromOnlineStore(ctx, groupRef.EntityKeys, groupRef.FeatureViewNames, groupRef.FeatureNames)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">vectors, err := onlineserving.TransposeFeatureRowsIntoColumns(
                        featureData,
                        groupRef,
                        requestedFeatureViews,
                        arrowMemory,
                        numRows,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">result = append(result, vectors...)</span>
        }

        <span class="cov0" title="0">if fs.transformationCallback != nil || fs.transformationService != nil </span><span class="cov0" title="0">{
                onDemandFeatures, err := transformation.AugmentResponseWithOnDemandTransforms(
                        ctx,
                        requestedOnDemandFeatureViews,
                        requestData,
                        joinKeyToEntityValues,
                        result,
                        fs.transformationCallback,
                        fs.transformationService,
                        arrowMemory,
                        numRows,
                        fullFeatureNames,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">result = append(result, onDemandFeatures...)</span>
        }

        <span class="cov0" title="0">result, err = onlineserving.KeepOnlyRequestedFeatures(result, featureRefs, featureService, fullFeatureNames)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">entityColumns, err := onlineserving.EntitiesToFeatureVectors(joinKeyToEntityValues, arrowMemory, numRows)
        result = append(entityColumns, result...)
        return result, nil</span>
}

func (fs *FeatureStore) DestructOnlineStore() <span class="cov0" title="0">{
        fs.onlineStore.Destruct()
}</span>

// ParseFeatures parses the kind field of a GetOnlineFeaturesRequest protobuf message
// and populates a Features struct with the result.
func (fs *FeatureStore) ParseFeatures(kind interface{}) (*Features, error) <span class="cov0" title="0">{
        if featureList, ok := kind.(*serving.GetOnlineFeaturesRequest_Features); ok </span><span class="cov0" title="0">{
                return &amp;Features{FeaturesRefs: featureList.Features.GetVal(), FeatureService: nil}, nil
        }</span>
        <span class="cov0" title="0">if featureServiceRequest, ok := kind.(*serving.GetOnlineFeaturesRequest_FeatureService); ok </span><span class="cov0" title="0">{
                featureService, err := fs.registry.GetFeatureService(fs.config.Project, featureServiceRequest.FeatureService)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">return &amp;Features{FeaturesRefs: nil, FeatureService: featureService}, nil</span>
        }
        <span class="cov0" title="0">return nil, errors.New("cannot parse kind from GetOnlineFeaturesRequest")</span>
}

func (fs *FeatureStore) GetFeatureService(name string) (*model.FeatureService, error) <span class="cov0" title="0">{
        return fs.registry.GetFeatureService(fs.config.Project, name)
}</span>

func (fs *FeatureStore) ListAllViews() (map[string]*model.FeatureView, map[string]*model.OnDemandFeatureView, error) <span class="cov0" title="0">{
        fvs := make(map[string]*model.FeatureView)
        odFvs := make(map[string]*model.OnDemandFeatureView)

        featureViews, err := fs.ListFeatureViews()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">for _, featureView := range featureViews </span><span class="cov0" title="0">{
                fvs[featureView.Base.Name] = featureView
        }</span>

        <span class="cov0" title="0">streamFeatureViews, err := fs.ListStreamFeatureViews()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">for _, streamFeatureView := range streamFeatureViews </span><span class="cov0" title="0">{
                fvs[streamFeatureView.Base.Name] = streamFeatureView
        }</span>

        <span class="cov0" title="0">onDemandFeatureViews, err := fs.registry.ListOnDemandFeatureViews(fs.config.Project)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov0" title="0">for _, onDemandFeatureView := range onDemandFeatureViews </span><span class="cov0" title="0">{
                odFvs[onDemandFeatureView.Base.Name] = onDemandFeatureView
        }</span>
        <span class="cov0" title="0">return fvs, odFvs, nil</span>
}

func (fs *FeatureStore) ListFeatureViews() ([]*model.FeatureView, error) <span class="cov0" title="0">{
        featureViews, err := fs.registry.ListFeatureViews(fs.config.Project)
        if err != nil </span><span class="cov0" title="0">{
                return featureViews, err
        }</span>
        <span class="cov0" title="0">return featureViews, nil</span>
}

func (fs *FeatureStore) ListStreamFeatureViews() ([]*model.FeatureView, error) <span class="cov0" title="0">{
        streamFeatureViews, err := fs.registry.ListStreamFeatureViews(fs.config.Project)
        if err != nil </span><span class="cov0" title="0">{
                return streamFeatureViews, err
        }</span>
        <span class="cov0" title="0">return streamFeatureViews, nil</span>
}

func (fs *FeatureStore) ListEntities(hideDummyEntity bool) ([]*model.Entity, error) <span class="cov0" title="0">{

        allEntities, err := fs.registry.ListEntities(fs.config.Project)
        if err != nil </span><span class="cov0" title="0">{
                return allEntities, err
        }</span>
        <span class="cov0" title="0">entities := make([]*model.Entity, 0)
        for _, entity := range allEntities </span><span class="cov0" title="0">{
                if entity.Name != model.DUMMY_ENTITY_NAME || !hideDummyEntity </span><span class="cov0" title="0">{
                        entities = append(entities, entity)
                }</span>
        }
        <span class="cov0" title="0">return entities, nil</span>
}

func (fs *FeatureStore) GetEntity(entityName string, hideDummyEntity bool) (*model.Entity, error) <span class="cov0" title="0">{

        entity, err := fs.registry.GetEntity(fs.config.Project, entityName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return entity, nil</span>
}
func (fs *FeatureStore) GetRequestSources(odfvList []*model.OnDemandFeatureView) (map[string]prototypes.ValueType_Enum, error) <span class="cov8" title="1">{

        requestSources := make(map[string]prototypes.ValueType_Enum, 0)
        if len(odfvList) &gt; 0 </span><span class="cov8" title="1">{
                for _, odfv := range odfvList </span><span class="cov8" title="1">{
                        schema := odfv.GetRequestDataSchema()
                        for name, dtype := range schema </span><span class="cov8" title="1">{
                                requestSources[name] = dtype
                        }</span>
                }
        }
        <span class="cov8" title="1">return requestSources, nil</span>
}

func (fs *FeatureStore) ListOnDemandFeatureViews() ([]*model.OnDemandFeatureView, error) <span class="cov0" title="0">{
        return fs.registry.ListOnDemandFeatureViews(fs.config.Project)
}</span>

/*
Group feature views that share the same set of join keys. For each group, we store only unique rows and save indices to retrieve those
rows for each requested feature
*/

func (fs *FeatureStore) GetFeatureView(featureViewName string, hideDummyEntity bool) (*model.FeatureView, error) <span class="cov0" title="0">{
        fv, err := fs.registry.GetFeatureView(fs.config.Project, featureViewName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if fv.HasEntity(model.DUMMY_ENTITY_NAME) &amp;&amp; hideDummyEntity </span><span class="cov0" title="0">{
                fv.EntityNames = []string{}
        }</span>
        <span class="cov0" title="0">return fv, nil</span>
}

func (fs *FeatureStore) GetOnDemandFeatureView(featureViewName string) (*model.OnDemandFeatureView, error) <span class="cov0" title="0">{
        fv, err := fs.registry.GetOnDemandFeatureView(fs.config.Project, featureViewName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return fv, nil</span>
}

func (fs *FeatureStore) readFromOnlineStore(ctx context.Context, entityRows []*prototypes.EntityKey,
        requestedFeatureViewNames []string,
        requestedFeatureNames []string,
) ([][]onlinestore.FeatureData, error) <span class="cov0" title="0">{
        // Create a Datadog span from context
        span, _ := tracer.StartSpanFromContext(ctx, "fs.readFromOnlineStore")
        defer span.Finish()

        numRows := len(entityRows)
        entityRowsValue := make([]*prototypes.EntityKey, numRows)
        for index, entityKey := range entityRows </span><span class="cov0" title="0">{
                entityRowsValue[index] = &amp;prototypes.EntityKey{JoinKeys: entityKey.JoinKeys, EntityValues: entityKey.EntityValues}
        }</span>
        <span class="cov0" title="0">return fs.onlineStore.OnlineRead(ctx, entityRowsValue, requestedFeatureViewNames, requestedFeatureNames)</span>
}

func (fs *FeatureStore) GetFcosMap() (map[string]*model.Entity, map[string]*model.FeatureView, map[string]*model.OnDemandFeatureView, error) <span class="cov0" title="0">{
        odfvs, err := fs.ListOnDemandFeatureViews()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, err
        }</span>
        <span class="cov0" title="0">fvs, err := fs.ListFeatureViews()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, err
        }</span>
        <span class="cov0" title="0">entities, err := fs.ListEntities(true)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, err
        }</span>

        <span class="cov0" title="0">entityMap := make(map[string]*model.Entity)
        for _, entity := range entities </span><span class="cov0" title="0">{
                entityMap[entity.Name] = entity
        }</span>
        <span class="cov0" title="0">fvMap := make(map[string]*model.FeatureView)
        for _, fv := range fvs </span><span class="cov0" title="0">{
                fvMap[fv.Base.Name] = fv
        }</span>
        <span class="cov0" title="0">odfvMap := make(map[string]*model.OnDemandFeatureView)
        for _, odfv := range odfvs </span><span class="cov0" title="0">{
                odfvMap[odfv.Base.Name] = odfv
        }</span>
        <span class="cov0" title="0">return entityMap, fvMap, odfvMap, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package onlineserving

import (
        "crypto/sha256"
        "errors"
        "fmt"
        "sort"
        "strings"

        "github.com/apache/arrow/go/v8/arrow"
        "github.com/apache/arrow/go/v8/arrow/memory"
        "google.golang.org/protobuf/proto"
        "google.golang.org/protobuf/types/known/durationpb"
        "google.golang.org/protobuf/types/known/timestamppb"

        "github.com/feast-dev/feast/go/internal/feast/model"
        "github.com/feast-dev/feast/go/internal/feast/onlinestore"
        "github.com/feast-dev/feast/go/protos/feast/serving"
        prototypes "github.com/feast-dev/feast/go/protos/feast/types"
        "github.com/feast-dev/feast/go/types"
)

/*
FeatureVector type represent result of retrieving single feature for multiple rows.
It can be imagined as a column in output dataframe / table.
It contains of feature name, list of values (across all rows),
list of statuses and list of timestamp. All these lists have equal length.
And this length is also equal to number of entity rows received in request.
*/
type FeatureVector struct {
        Name       string
        Values     arrow.Array
        Statuses   []serving.FieldStatus
        Timestamps []*timestamppb.Timestamp
}

type FeatureViewAndRefs struct {
        View        *model.FeatureView
        FeatureRefs []string
}

/*
We group all features from a single request by entities they attached to.
Thus, we will be able to call online retrieval per entity and not per each feature View.
In this struct we collect all features and views that belongs to a group.
We also store here projected entity keys (only ones that needed to retrieve these features)
and indexes to map result of retrieval into output response.
*/
type GroupedFeaturesPerEntitySet struct {
        // A list of requested feature references of the form featureViewName:featureName that share this entity set
        FeatureNames     []string
        FeatureViewNames []string
        // full feature references as they supposed to appear in response
        AliasedFeatureNames []string
        // Entity set as a list of EntityKeys to pass to OnlineRead
        EntityKeys []*prototypes.EntityKey
        // Reversed mapping to project result of retrieval from storage to response
        Indices [][]int
}

/*
Return

        (1) requested feature views and features grouped per View
        (2) requested on demand feature views

existed in the registry
*/
func GetFeatureViewsToUseByService(
        featureService *model.FeatureService,
        featureViews map[string]*model.FeatureView,
        onDemandFeatureViews map[string]*model.OnDemandFeatureView) ([]*FeatureViewAndRefs, []*model.OnDemandFeatureView, error) <span class="cov8" title="1">{

        viewNameToViewAndRefs := make(map[string]*FeatureViewAndRefs)
        odFvsToUse := make([]*model.OnDemandFeatureView, 0)

        for _, featureProjection := range featureService.Projections </span><span class="cov8" title="1">{
                // Create copies of FeatureView that may contains the same *FeatureView but
                // each differentiated by a *FeatureViewProjection
                featureViewName := featureProjection.Name
                if fv, ok := featureViews[featureViewName]; ok </span><span class="cov8" title="1">{
                        base, err := fv.Base.WithProjection(featureProjection)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, err
                        }</span>
                        <span class="cov8" title="1">if _, ok := viewNameToViewAndRefs[featureProjection.NameToUse()]; !ok </span><span class="cov8" title="1">{
                                viewNameToViewAndRefs[featureProjection.NameToUse()] = &amp;FeatureViewAndRefs{
                                        View:        fv.NewFeatureViewFromBase(base),
                                        FeatureRefs: []string{},
                                }
                        }</span>

                        <span class="cov8" title="1">for _, feature := range featureProjection.Features </span><span class="cov8" title="1">{
                                viewNameToViewAndRefs[featureProjection.NameToUse()].FeatureRefs =
                                        addStringIfNotContains(viewNameToViewAndRefs[featureProjection.NameToUse()].FeatureRefs,
                                                feature.Name)
                        }</span>

                } else<span class="cov8" title="1"> if odFv, ok := onDemandFeatureViews[featureViewName]; ok </span><span class="cov8" title="1">{
                        projectedOdFv, err := odFv.NewWithProjection(featureProjection)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, err
                        }</span>
                        <span class="cov8" title="1">odFvsToUse = append(odFvsToUse, projectedOdFv)
                        err = extractOdFvDependencies(
                                projectedOdFv,
                                featureViews,
                                viewNameToViewAndRefs)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, nil, err
                        }</span>
                } else<span class="cov0" title="0"> {
                        return nil, nil, fmt.Errorf("the provided feature service %s contains a reference to a feature View"+
                                "%s which doesn't exist, please make sure that you have created the feature View"+
                                "%s and that you have registered it by running \"apply\"", featureService.Name, featureViewName, featureViewName)
                }</span>
        }

        <span class="cov8" title="1">fvsToUse := make([]*FeatureViewAndRefs, 0)
        for _, viewAndRef := range viewNameToViewAndRefs </span><span class="cov8" title="1">{
                fvsToUse = append(fvsToUse, viewAndRef)
        }</span>

        <span class="cov8" title="1">return fvsToUse, odFvsToUse, nil</span>
}

/*
Return

        (1) requested feature views and features grouped per View
        (2) requested on demand feature views

existed in the registry
*/
func GetFeatureViewsToUseByFeatureRefs(
        features []string,
        featureViews map[string]*model.FeatureView,
        onDemandFeatureViews map[string]*model.OnDemandFeatureView) ([]*FeatureViewAndRefs, []*model.OnDemandFeatureView, error) <span class="cov8" title="1">{
        viewNameToViewAndRefs := make(map[string]*FeatureViewAndRefs)
        odFvToFeatures := make(map[string][]string)

        for _, featureRef := range features </span><span class="cov8" title="1">{
                featureViewName, featureName, err := ParseFeatureReference(featureRef)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
                <span class="cov8" title="1">if fv, ok := featureViews[featureViewName]; ok </span><span class="cov8" title="1">{
                        if viewAndRef, ok := viewNameToViewAndRefs[fv.Base.Name]; ok </span><span class="cov8" title="1">{
                                viewAndRef.FeatureRefs = addStringIfNotContains(viewAndRef.FeatureRefs, featureName)
                        }</span> else<span class="cov8" title="1"> {
                                viewNameToViewAndRefs[fv.Base.Name] = &amp;FeatureViewAndRefs{
                                        View:        fv,
                                        FeatureRefs: []string{featureName},
                                }
                        }</span>
                } else<span class="cov8" title="1"> if odfv, ok := onDemandFeatureViews[featureViewName]; ok </span><span class="cov8" title="1">{
                        if _, ok := odFvToFeatures[odfv.Base.Name]; !ok </span><span class="cov8" title="1">{
                                odFvToFeatures[odfv.Base.Name] = []string{featureName}
                        }</span> else<span class="cov0" title="0"> {
                                odFvToFeatures[odfv.Base.Name] = append(
                                        odFvToFeatures[odfv.Base.Name], featureName)
                        }</span>
                } else<span class="cov0" title="0"> {
                        return nil, nil, fmt.Errorf("feature View %s doesn't exist, please make sure that you have created the"+
                                " feature View %s and that you have registered it by running \"apply\"", featureViewName, featureViewName)
                }</span>
        }

        <span class="cov8" title="1">odFvsToUse := make([]*model.OnDemandFeatureView, 0)

        for odFvName, featureNames := range odFvToFeatures </span><span class="cov8" title="1">{
                projectedOdFv, err := onDemandFeatureViews[odFvName].ProjectWithFeatures(featureNames)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>

                <span class="cov8" title="1">err = extractOdFvDependencies(
                        projectedOdFv,
                        featureViews,
                        viewNameToViewAndRefs)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
                <span class="cov8" title="1">odFvsToUse = append(odFvsToUse, projectedOdFv)</span>
        }

        <span class="cov8" title="1">fvsToUse := make([]*FeatureViewAndRefs, 0)
        for _, viewAndRefs := range viewNameToViewAndRefs </span><span class="cov8" title="1">{
                fvsToUse = append(fvsToUse, viewAndRefs)
        }</span>

        <span class="cov8" title="1">return fvsToUse, odFvsToUse, nil</span>
}

func extractOdFvDependencies(
        odFv *model.OnDemandFeatureView,
        sourceFvs map[string]*model.FeatureView,
        requestedFeatures map[string]*FeatureViewAndRefs,
) error <span class="cov8" title="1">{

        for _, sourceFvProjection := range odFv.SourceFeatureViewProjections </span><span class="cov8" title="1">{
                fv := sourceFvs[sourceFvProjection.Name]
                base, err := fv.Base.WithProjection(sourceFvProjection)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">newFv := fv.NewFeatureViewFromBase(base)

                if _, ok := requestedFeatures[sourceFvProjection.NameToUse()]; !ok </span><span class="cov8" title="1">{
                        requestedFeatures[sourceFvProjection.NameToUse()] = &amp;FeatureViewAndRefs{
                                View:        newFv,
                                FeatureRefs: []string{},
                        }
                }</span>

                <span class="cov8" title="1">for _, feature := range sourceFvProjection.Features </span><span class="cov8" title="1">{
                        requestedFeatures[sourceFvProjection.NameToUse()].FeatureRefs = addStringIfNotContains(
                                requestedFeatures[sourceFvProjection.NameToUse()].FeatureRefs, feature.Name)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func addStringIfNotContains(slice []string, element string) []string <span class="cov8" title="1">{
        found := false
        for _, item := range slice </span><span class="cov8" title="1">{
                if element == item </span><span class="cov8" title="1">{
                        found = true
                }</span>
        }
        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                slice = append(slice, element)
        }</span>
        <span class="cov8" title="1">return slice</span>
}

func GetEntityMaps(requestedFeatureViews []*FeatureViewAndRefs, entities []*model.Entity) (map[string]string, map[string]interface{}, error) <span class="cov0" title="0">{
        entityNameToJoinKeyMap := make(map[string]string)
        expectedJoinKeysSet := make(map[string]interface{})

        entitiesByName := make(map[string]*model.Entity)

        for _, entity := range entities </span><span class="cov0" title="0">{
                entitiesByName[entity.Name] = entity
        }</span>

        <span class="cov0" title="0">for _, featuresAndView := range requestedFeatureViews </span><span class="cov0" title="0">{
                featureView := featuresAndView.View
                var joinKeyToAliasMap map[string]string
                if featureView.Base.Projection != nil &amp;&amp; featureView.Base.Projection.JoinKeyMap != nil </span><span class="cov0" title="0">{
                        joinKeyToAliasMap = featureView.Base.Projection.JoinKeyMap
                }</span> else<span class="cov0" title="0"> {
                        joinKeyToAliasMap = map[string]string{}
                }</span>

                <span class="cov0" title="0">for _, entityName := range featureView.EntityNames </span><span class="cov0" title="0">{
                        joinKey := entitiesByName[entityName].JoinKey
                        entityNameToJoinKeyMap[entityName] = joinKey

                        if alias, ok := joinKeyToAliasMap[joinKey]; ok </span><span class="cov0" title="0">{
                                expectedJoinKeysSet[alias] = nil
                        }</span> else<span class="cov0" title="0"> {
                                expectedJoinKeysSet[joinKey] = nil
                        }</span>
                }
        }
        <span class="cov0" title="0">return entityNameToJoinKeyMap, expectedJoinKeysSet, nil</span>
}

func ValidateEntityValues(joinKeyValues map[string]*prototypes.RepeatedValue,
        requestData map[string]*prototypes.RepeatedValue,
        expectedJoinKeysSet map[string]interface{}) (int, error) <span class="cov0" title="0">{
        numRows := -1

        for joinKey, values := range joinKeyValues </span><span class="cov0" title="0">{
                if _, ok := expectedJoinKeysSet[joinKey]; !ok </span><span class="cov0" title="0">{
                        requestData[joinKey] = values
                        delete(joinKeyValues, joinKey)
                        // ToDo: when request data will be passed correctly (not as part of entity rows)
                        // ToDo: throw this error instead
                        // return 0, fmt.Errorf("JoinKey is not expected in this request: %s\n%v", JoinKey, expectedJoinKeysSet)
                }</span> else<span class="cov0" title="0"> {
                        if numRows &lt; 0 </span><span class="cov0" title="0">{
                                numRows = len(values.Val)
                        }</span> else<span class="cov0" title="0"> if len(values.Val) != numRows </span><span class="cov0" title="0">{
                                return -1, errors.New("valueError: All entity rows must have the same columns")
                        }</span>

                }
        }

        <span class="cov0" title="0">return numRows, nil</span>
}

func ValidateFeatureRefs(requestedFeatures []*FeatureViewAndRefs, fullFeatureNames bool) error <span class="cov0" title="0">{
        featureRefCounter := make(map[string]int)
        featureRefs := make([]string, 0)
        for _, viewAndFeatures := range requestedFeatures </span><span class="cov0" title="0">{
                for _, feature := range viewAndFeatures.FeatureRefs </span><span class="cov0" title="0">{
                        projectedViewName := viewAndFeatures.View.Base.Name
                        if viewAndFeatures.View.Base.Projection != nil </span><span class="cov0" title="0">{
                                projectedViewName = viewAndFeatures.View.Base.Projection.NameToUse()
                        }</span>

                        <span class="cov0" title="0">featureRefs = append(featureRefs,
                                fmt.Sprintf("%s:%s", projectedViewName, feature))</span>
                }
        }

        <span class="cov0" title="0">for _, featureRef := range featureRefs </span><span class="cov0" title="0">{
                if fullFeatureNames </span><span class="cov0" title="0">{
                        featureRefCounter[featureRef]++
                }</span> else<span class="cov0" title="0"> {
                        _, featureName, _ := ParseFeatureReference(featureRef)
                        featureRefCounter[featureName]++
                }</span>

        }
        <span class="cov0" title="0">for featureName, occurrences := range featureRefCounter </span><span class="cov0" title="0">{
                if occurrences == 1 </span><span class="cov0" title="0">{
                        delete(featureRefCounter, featureName)
                }</span>
        }
        <span class="cov0" title="0">if len(featureRefCounter) &gt;= 1 </span><span class="cov0" title="0">{
                collidedFeatureRefs := make([]string, 0)
                for collidedFeatureRef := range featureRefCounter </span><span class="cov0" title="0">{
                        if fullFeatureNames </span><span class="cov0" title="0">{
                                collidedFeatureRefs = append(collidedFeatureRefs, collidedFeatureRef)
                        }</span> else<span class="cov0" title="0"> {
                                for _, featureRef := range featureRefs </span><span class="cov0" title="0">{
                                        _, featureName, _ := ParseFeatureReference(featureRef)
                                        if featureName == collidedFeatureRef </span><span class="cov0" title="0">{
                                                collidedFeatureRefs = append(collidedFeatureRefs, featureRef)
                                        }</span>
                                }
                        }
                }
                <span class="cov0" title="0">return featureNameCollisionError{collidedFeatureRefs, fullFeatureNames}</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func TransposeFeatureRowsIntoColumns(featureData2D [][]onlinestore.FeatureData,
        groupRef *GroupedFeaturesPerEntitySet,
        requestedFeatureViews []*FeatureViewAndRefs,
        arrowAllocator memory.Allocator,
        numRows int) ([]*FeatureVector, error) <span class="cov0" title="0">{

        numFeatures := len(groupRef.AliasedFeatureNames)
        fvs := make(map[string]*model.FeatureView)
        for _, viewAndRefs := range requestedFeatureViews </span><span class="cov0" title="0">{
                fvs[viewAndRefs.View.Base.Name] = viewAndRefs.View
        }</span>

        <span class="cov0" title="0">var value *prototypes.Value
        var status serving.FieldStatus
        var eventTimeStamp *timestamppb.Timestamp
        var featureData *onlinestore.FeatureData
        var fv *model.FeatureView
        var featureViewName string

        vectors := make([]*FeatureVector, 0)

        for featureIndex := 0; featureIndex &lt; numFeatures; featureIndex++ </span><span class="cov0" title="0">{
                currentVector := &amp;FeatureVector{
                        Name:       groupRef.AliasedFeatureNames[featureIndex],
                        Statuses:   make([]serving.FieldStatus, numRows),
                        Timestamps: make([]*timestamppb.Timestamp, numRows),
                }
                vectors = append(vectors, currentVector)
                protoValues := make([]*prototypes.Value, numRows)

                for rowEntityIndex, outputIndexes := range groupRef.Indices </span><span class="cov0" title="0">{
                        if featureData2D[rowEntityIndex] == nil </span><span class="cov0" title="0">{
                                value = nil
                                status = serving.FieldStatus_NOT_FOUND
                                eventTimeStamp = &amp;timestamppb.Timestamp{}
                        }</span> else<span class="cov0" title="0"> {
                                featureData = &amp;featureData2D[rowEntityIndex][featureIndex]
                                eventTimeStamp = &amp;timestamppb.Timestamp{Seconds: featureData.Timestamp.Seconds, Nanos: featureData.Timestamp.Nanos}
                                featureViewName = featureData.Reference.FeatureViewName
                                fv = fvs[featureViewName]
                                if _, ok := featureData.Value.Val.(*prototypes.Value_NullVal); ok </span><span class="cov0" title="0">{
                                        value = nil
                                        status = serving.FieldStatus_NOT_FOUND
                                }</span> else<span class="cov0" title="0"> if checkOutsideTtl(eventTimeStamp, timestamppb.Now(), fv.Ttl) </span><span class="cov0" title="0">{
                                        value = &amp;prototypes.Value{Val: featureData.Value.Val}
                                        status = serving.FieldStatus_OUTSIDE_MAX_AGE
                                }</span> else<span class="cov0" title="0"> {
                                        value = &amp;prototypes.Value{Val: featureData.Value.Val}
                                        status = serving.FieldStatus_PRESENT
                                }</span>
                        }
                        <span class="cov0" title="0">for _, rowIndex := range outputIndexes </span><span class="cov0" title="0">{
                                protoValues[rowIndex] = value
                                currentVector.Statuses[rowIndex] = status
                                currentVector.Timestamps[rowIndex] = eventTimeStamp
                        }</span>
                }
                <span class="cov0" title="0">arrowValues, err := types.ProtoValuesToArrowArray(protoValues, arrowAllocator, numRows)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">currentVector.Values = arrowValues</span>
        }

        <span class="cov0" title="0">return vectors, nil</span>

}

func KeepOnlyRequestedFeatures(
        vectors []*FeatureVector,
        requestedFeatureRefs []string,
        featureService *model.FeatureService,
        fullFeatureNames bool) ([]*FeatureVector, error) <span class="cov0" title="0">{
        vectorsByName := make(map[string]*FeatureVector)
        expectedVectors := make([]*FeatureVector, 0)

        usedVectors := make(map[string]bool)

        for _, vector := range vectors </span><span class="cov0" title="0">{
                vectorsByName[vector.Name] = vector
        }</span>

        <span class="cov0" title="0">if featureService != nil </span><span class="cov0" title="0">{
                for _, projection := range featureService.Projections </span><span class="cov0" title="0">{
                        for _, f := range projection.Features </span><span class="cov0" title="0">{
                                requestedFeatureRefs = append(requestedFeatureRefs,
                                        fmt.Sprintf("%s:%s", projection.NameToUse(), f.Name))
                        }</span>
                }
        }

        <span class="cov0" title="0">for _, featureRef := range requestedFeatureRefs </span><span class="cov0" title="0">{
                viewName, featureName, err := ParseFeatureReference(featureRef)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">qualifiedName := getQualifiedFeatureName(viewName, featureName, fullFeatureNames)
                if _, ok := vectorsByName[qualifiedName]; !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("requested feature %s can't be retrieved", featureRef)
                }</span>
                <span class="cov0" title="0">expectedVectors = append(expectedVectors, vectorsByName[qualifiedName])
                usedVectors[qualifiedName] = true</span>
        }

        // Free arrow arrays for vectors that were not used.
        <span class="cov0" title="0">for _, vector := range vectors </span><span class="cov0" title="0">{
                if _, ok := usedVectors[vector.Name]; !ok </span><span class="cov0" title="0">{
                        vector.Values.Release()
                }</span>
        }

        <span class="cov0" title="0">return expectedVectors, nil</span>
}

func EntitiesToFeatureVectors(entityColumns map[string]*prototypes.RepeatedValue, arrowAllocator memory.Allocator, numRows int) ([]*FeatureVector, error) <span class="cov0" title="0">{
        vectors := make([]*FeatureVector, 0)
        presentVector := make([]serving.FieldStatus, numRows)
        timestampVector := make([]*timestamppb.Timestamp, numRows)
        for idx := 0; idx &lt; numRows; idx++ </span><span class="cov0" title="0">{
                presentVector[idx] = serving.FieldStatus_PRESENT
                timestampVector[idx] = timestamppb.Now()
        }</span>
        <span class="cov0" title="0">for entityName, values := range entityColumns </span><span class="cov0" title="0">{
                arrowColumn, err := types.ProtoValuesToArrowArray(values.Val, arrowAllocator, numRows)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">vectors = append(vectors, &amp;FeatureVector{
                        Name:       entityName,
                        Values:     arrowColumn,
                        Statuses:   presentVector,
                        Timestamps: timestampVector,
                })</span>
        }
        <span class="cov0" title="0">return vectors, nil</span>
}

func ParseFeatureReference(featureRef string) (featureViewName, featureName string, e error) <span class="cov8" title="1">{
        parsedFeatureName := strings.Split(featureRef, ":")

        if len(parsedFeatureName) == 0 </span><span class="cov0" title="0">{
                e = errors.New("featureReference should be in the format: 'FeatureViewName:FeatureName'")
        }</span> else<span class="cov8" title="1"> if len(parsedFeatureName) == 1 </span><span class="cov0" title="0">{
                featureName = parsedFeatureName[0]
        }</span> else<span class="cov8" title="1"> {
                featureViewName = parsedFeatureName[0]
                featureName = parsedFeatureName[1]
        }</span>
        <span class="cov8" title="1">return</span>
}

func entityKeysToProtos(joinKeyValues map[string]*prototypes.RepeatedValue) []*prototypes.EntityKey <span class="cov8" title="1">{
        keys := make([]string, len(joinKeyValues))
        index := 0
        var numRows int
        for k, v := range joinKeyValues </span><span class="cov8" title="1">{
                keys[index] = k
                index += 1
                numRows = len(v.Val)
        }</span>
        <span class="cov8" title="1">sort.Strings(keys)
        entityKeys := make([]*prototypes.EntityKey, numRows)
        numJoinKeys := len(keys)
        // Construct each EntityKey object
        for index = 0; index &lt; numRows; index++ </span><span class="cov8" title="1">{
                entityKeys[index] = &amp;prototypes.EntityKey{JoinKeys: keys, EntityValues: make([]*prototypes.Value, numJoinKeys)}
        }</span>

        <span class="cov8" title="1">for colIndex, key := range keys </span><span class="cov8" title="1">{
                for index, value := range joinKeyValues[key].GetVal() </span><span class="cov8" title="1">{
                        entityKeys[index].EntityValues[colIndex] = value
                }</span>
        }
        <span class="cov8" title="1">return entityKeys</span>
}

func GroupFeatureRefs(requestedFeatureViews []*FeatureViewAndRefs,
        joinKeyValues map[string]*prototypes.RepeatedValue,
        entityNameToJoinKeyMap map[string]string,
        fullFeatureNames bool,
) (map[string]*GroupedFeaturesPerEntitySet,
        error,
) <span class="cov8" title="1">{
        groups := make(map[string]*GroupedFeaturesPerEntitySet)

        for _, featuresAndView := range requestedFeatureViews </span><span class="cov8" title="1">{
                joinKeys := make([]string, 0)
                fv := featuresAndView.View
                featureNames := featuresAndView.FeatureRefs
                for _, entityName := range fv.EntityNames </span><span class="cov8" title="1">{
                        joinKeys = append(joinKeys, entityNameToJoinKeyMap[entityName])
                }</span>

                <span class="cov8" title="1">groupKeyBuilder := make([]string, 0)
                joinKeysValuesProjection := make(map[string]*prototypes.RepeatedValue)

                joinKeyToAliasMap := make(map[string]string)
                if fv.Base.Projection != nil &amp;&amp; fv.Base.Projection.JoinKeyMap != nil </span><span class="cov8" title="1">{
                        joinKeyToAliasMap = fv.Base.Projection.JoinKeyMap
                }</span>

                <span class="cov8" title="1">for _, joinKey := range joinKeys </span><span class="cov8" title="1">{
                        var joinKeyOrAlias string

                        if alias, ok := joinKeyToAliasMap[joinKey]; ok </span><span class="cov8" title="1">{
                                groupKeyBuilder = append(groupKeyBuilder, fmt.Sprintf("%s[%s]", joinKey, alias))
                                joinKeyOrAlias = alias
                        }</span> else<span class="cov8" title="1"> {
                                groupKeyBuilder = append(groupKeyBuilder, joinKey)
                                joinKeyOrAlias = joinKey
                        }</span>

                        <span class="cov8" title="1">if _, ok := joinKeyValues[joinKeyOrAlias]; !ok </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("key %s is missing in provided entity rows", joinKey)
                        }</span>
                        <span class="cov8" title="1">joinKeysValuesProjection[joinKey] = joinKeyValues[joinKeyOrAlias]</span>
                }

                <span class="cov8" title="1">sort.Strings(groupKeyBuilder)
                groupKey := strings.Join(groupKeyBuilder, ",")

                aliasedFeatureNames := make([]string, 0)
                featureViewNames := make([]string, 0)
                var viewNameToUse string
                if fv.Base.Projection != nil </span><span class="cov8" title="1">{
                        viewNameToUse = fv.Base.Projection.NameToUse()
                }</span> else<span class="cov8" title="1"> {
                        viewNameToUse = fv.Base.Name
                }</span>

                <span class="cov8" title="1">for _, featureName := range featureNames </span><span class="cov8" title="1">{
                        aliasedFeatureNames = append(aliasedFeatureNames,
                                getQualifiedFeatureName(viewNameToUse, featureName, fullFeatureNames))
                        featureViewNames = append(featureViewNames, fv.Base.Name)
                }</span>

                <span class="cov8" title="1">if _, ok := groups[groupKey]; !ok </span><span class="cov8" title="1">{
                        joinKeysProto := entityKeysToProtos(joinKeysValuesProjection)
                        uniqueEntityRows, mappingIndices, err := getUniqueEntityRows(joinKeysProto)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov8" title="1">groups[groupKey] = &amp;GroupedFeaturesPerEntitySet{
                                FeatureNames:        featureNames,
                                FeatureViewNames:    featureViewNames,
                                AliasedFeatureNames: aliasedFeatureNames,
                                Indices:             mappingIndices,
                                EntityKeys:          uniqueEntityRows,
                        }</span>

                } else<span class="cov8" title="1"> {
                        groups[groupKey].FeatureNames = append(groups[groupKey].FeatureNames, featureNames...)
                        groups[groupKey].AliasedFeatureNames = append(groups[groupKey].AliasedFeatureNames, aliasedFeatureNames...)
                        groups[groupKey].FeatureViewNames = append(groups[groupKey].FeatureViewNames, featureViewNames...)
                }</span>
        }
        <span class="cov8" title="1">return groups, nil</span>
}

func getUniqueEntityRows(joinKeysProto []*prototypes.EntityKey) ([]*prototypes.EntityKey, [][]int, error) <span class="cov8" title="1">{
        uniqueValues := make(map[[sha256.Size]byte]*prototypes.EntityKey, 0)
        positions := make(map[[sha256.Size]byte][]int, 0)

        for index, entityKey := range joinKeysProto </span><span class="cov8" title="1">{
                serializedRow, err := proto.Marshal(entityKey)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>

                <span class="cov8" title="1">rowHash := sha256.Sum256(serializedRow)
                if _, ok := uniqueValues[rowHash]; !ok </span><span class="cov8" title="1">{
                        uniqueValues[rowHash] = entityKey
                        positions[rowHash] = []int{index}
                }</span> else<span class="cov8" title="1"> {
                        positions[rowHash] = append(positions[rowHash], index)
                }</span>
        }

        <span class="cov8" title="1">mappingIndices := make([][]int, len(uniqueValues))
        uniqueEntityRows := make([]*prototypes.EntityKey, 0)
        for rowHash, row := range uniqueValues </span><span class="cov8" title="1">{
                nextIdx := len(uniqueEntityRows)

                mappingIndices[nextIdx] = positions[rowHash]
                uniqueEntityRows = append(uniqueEntityRows, row)
        }</span>
        <span class="cov8" title="1">return uniqueEntityRows, mappingIndices, nil</span>
}

func checkOutsideTtl(featureTimestamp *timestamppb.Timestamp, currentTimestamp *timestamppb.Timestamp, ttl *durationpb.Duration) bool <span class="cov0" title="0">{
        if ttl.Seconds == 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return currentTimestamp.GetSeconds()-featureTimestamp.GetSeconds() &gt; ttl.Seconds</span>
}

func getQualifiedFeatureName(viewName string, featureName string, fullFeatureNames bool) string <span class="cov8" title="1">{
        if fullFeatureNames </span><span class="cov8" title="1">{
                return fmt.Sprintf("%s__%s", viewName, featureName)
        }</span> else<span class="cov0" title="0"> {
                return featureName
        }</span>
}

type featureNameCollisionError struct {
        featureRefCollisions []string
        fullFeatureNames     bool
}

func (e featureNameCollisionError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("featureNameCollisionError: %s; %t", strings.Join(e.featureRefCollisions, ", "), e.fullFeatureNames)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package onlinestore

import (
        "context"
        "fmt"

        "github.com/feast-dev/feast/go/internal/feast/registry"
        "github.com/feast-dev/feast/go/protos/feast/serving"
        "github.com/feast-dev/feast/go/protos/feast/types"
        "github.com/golang/protobuf/ptypes/timestamp"
)

type FeatureData struct {
        Reference serving.FeatureReferenceV2
        Timestamp timestamp.Timestamp
        Value     types.Value
}

type OnlineStore interface {
        // OnlineRead reads multiple features (specified in featureReferences) for multiple
        // entity keys (specified in entityKeys) and returns an array of array of features,
        // where each feature contains 3 fields:
        //   1. feature Reference
        //   2. feature event timestamp
        //   3. feature value
        // The inner array will have the same size as featureReferences,
        // while the outer array will have the same size as entityKeys.

        // TODO: Can we return [][]FeatureData, []timstamps, error
        // instead and remove timestamp from FeatureData struct to mimic Python's code
        // and reduces repeated memory storage for the same timstamp (which is stored as value and not as a pointer).
        // Should each attribute in FeatureData be stored as a pointer instead since the current
        // design forces value copied in OnlineRead + GetOnlineFeatures
        // (array is destructed so we cannot use the same fields in each
        // Feature object as pointers in GetOnlineFeaturesResponse)
        // =&gt; allocate memory for each field once in OnlineRead
        // and reuse them in GetOnlineFeaturesResponse?
        OnlineRead(ctx context.Context, entityKeys []*types.EntityKey, featureViewNames []string, featureNames []string) ([][]FeatureData, error)
        // Destruct must be call once user is done using OnlineStore
        // This is to comply with the Connector since we have to close the plugin
        Destruct()
}

func getOnlineStoreType(onlineStoreConfig map[string]interface{}) (string, bool) <span class="cov0" title="0">{
        if onlineStoreType, ok := onlineStoreConfig["type"]; !ok </span><span class="cov0" title="0">{
                // If online store type isn't specified, default to sqlite
                return "sqlite", true
        }</span> else<span class="cov0" title="0"> {
                result, ok := onlineStoreType.(string)
                return result, ok
        }</span>
}

func NewOnlineStore(config *registry.RepoConfig) (OnlineStore, error) <span class="cov0" title="0">{
        onlineStoreType, ok := getOnlineStoreType(config.OnlineStore)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not get online store type from online store config: %+v", config.OnlineStore)
        }</span> else<span class="cov0" title="0"> if onlineStoreType == "sqlite" </span><span class="cov0" title="0">{
                onlineStore, err := NewSqliteOnlineStore(config.Project, config, config.OnlineStore)
                return onlineStore, err
        }</span> else<span class="cov0" title="0"> if onlineStoreType == "redis" </span><span class="cov0" title="0">{
                onlineStore, err := NewRedisOnlineStore(config.Project, config, config.OnlineStore)
                return onlineStore, err
        }</span> else<span class="cov0" title="0"> {
                return nil, fmt.Errorf("%s online store type is currently not supported; only redis and sqlite are supported", onlineStoreType)
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package onlinestore

import (
        "context"
        "crypto/tls"
        "encoding/binary"
        "errors"
        "fmt"
        "os"
        "sort"
        "strconv"
        "strings"

        "github.com/feast-dev/feast/go/internal/feast/registry"
        "gopkg.in/DataDog/dd-trace-go.v1/ddtrace/tracer"

        "github.com/redis/go-redis/v9"
        "github.com/spaolacci/murmur3"
        "google.golang.org/protobuf/proto"
        "google.golang.org/protobuf/types/known/timestamppb"

        "github.com/feast-dev/feast/go/protos/feast/serving"
        "github.com/feast-dev/feast/go/protos/feast/types"
        redistrace "gopkg.in/DataDog/dd-trace-go.v1/contrib/redis/go-redis.v9"
)

type redisType int

const (
        redisNode    redisType = 0
        redisCluster redisType = 1
)

type RedisOnlineStore struct {

        // Feast project name
        // TODO (woop): Should we remove project as state that is tracked at the store level?
        project string

        // Redis database type, either a single node server (RedisType.Redis) or a cluster (RedisType.RedisCluster)
        t redisType

        // Redis client connector
        client *redis.Client

        // Redis cluster client connector
        clusterClient *redis.ClusterClient

        config *registry.RepoConfig
}

func NewRedisOnlineStore(project string, config *registry.RepoConfig, onlineStoreConfig map[string]interface{}) (*RedisOnlineStore, error) <span class="cov8" title="1">{
        store := RedisOnlineStore{
                project: project,
                config:  config,
        }

        var address []string
        var password string
        var tlsConfig *tls.Config
        var db int // Default to 0

        // Parse redis_type and write it into conf.redisStoreType
        redisStoreType, err := getRedisType(onlineStoreConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">store.t = redisStoreType

        // Parse connection_string and write it into conf.address, conf.password, and conf.ssl
        redisConnJson, ok := onlineStoreConfig["connection_string"]
        if !ok </span><span class="cov0" title="0">{
                // Default to "localhost:6379"
                redisConnJson = "localhost:6379"
        }</span>
        <span class="cov8" title="1">if redisConnStr, ok := redisConnJson.(string); !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to convert connection_string to string: %+v", redisConnJson)
        }</span> else<span class="cov8" title="1"> {
                parts := strings.Split(redisConnStr, ",")
                for _, part := range parts </span><span class="cov8" title="1">{
                        if strings.Contains(part, ":") </span><span class="cov8" title="1">{
                                address = append(address, part)
                        }</span> else<span class="cov8" title="1"> if strings.Contains(part, "=") </span><span class="cov8" title="1">{
                                kv := strings.SplitN(part, "=", 2)
                                if kv[0] == "password" </span><span class="cov8" title="1">{
                                        password = kv[1]
                                }</span> else<span class="cov8" title="1"> if kv[0] == "ssl" </span><span class="cov8" title="1">{
                                        result, err := strconv.ParseBool(kv[1])
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, err
                                        }</span> else<span class="cov8" title="1"> if result </span><span class="cov8" title="1">{
                                                tlsConfig = &amp;tls.Config{}
                                        }</span>
                                } else<span class="cov8" title="1"> if kv[0] == "db" </span><span class="cov8" title="1">{
                                        db, err = strconv.Atoi(kv[1])
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, err
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        return nil, fmt.Errorf("unrecognized option in connection_string: %s. Must be one of 'password', 'ssl'", kv[0])
                                }</span>
                        } else<span class="cov0" title="0"> {
                                return nil, fmt.Errorf("unable to parse a part of connection_string: %s. Must contain either ':' (addresses) or '=' (options", part)
                        }</span>
                }
        }

        // Metrics are not showing up when the service name is set to DD_SERVICE
        <span class="cov8" title="1">redisTraceServiceName := os.Getenv("DD_SERVICE") + "-redis"
        if redisTraceServiceName == "" </span><span class="cov0" title="0">{
                redisTraceServiceName = "redis.client" // default service name if DD_SERVICE is not set
        }</span>

        <span class="cov8" title="1">if redisStoreType == redisNode </span><span class="cov8" title="1">{
                store.client = redis.NewClient(&amp;redis.Options{
                        Addr:      address[0],
                        Password:  password, // No password set
                        DB:        db,
                        TLSConfig: tlsConfig,
                })
                if strings.ToLower(os.Getenv("ENABLE_DATADOG_REDIS_TRACING")) == "true" </span><span class="cov0" title="0">{
                        redistrace.WrapClient(store.client, redistrace.WithServiceName(redisTraceServiceName))
                }</span>
        } else<span class="cov0" title="0"> if redisStoreType == redisCluster </span><span class="cov0" title="0">{
                store.clusterClient = redis.NewClusterClient(&amp;redis.ClusterOptions{
                        Addrs:     []string{address[0]},
                        Password:  password, // No password set
                        TLSConfig: tlsConfig,
                        ReadOnly:  true,
                })
                if strings.ToLower(os.Getenv("ENABLE_DATADOG_REDIS_TRACING")) == "true" </span><span class="cov0" title="0">{
                        redistrace.WrapClient(store.clusterClient, redistrace.WithServiceName(redisTraceServiceName))
                }</span>
        }

        <span class="cov8" title="1">return &amp;store, nil</span>
}

func getRedisType(onlineStoreConfig map[string]interface{}) (redisType, error) <span class="cov8" title="1">{
        var t redisType

        redisTypeJson, ok := onlineStoreConfig["redis_type"]
        if !ok </span><span class="cov8" title="1">{
                // Default to "redis"
                redisTypeJson = "redis"
        }</span> else<span class="cov0" title="0"> if redisTypeStr, ok := redisTypeJson.(string); !ok </span><span class="cov0" title="0">{
                return -1, fmt.Errorf("failed to convert redis_type to string: %+v", redisTypeJson)
        }</span> else<span class="cov0" title="0"> {
                if redisTypeStr == "redis" </span><span class="cov0" title="0">{
                        t = redisNode
                }</span> else<span class="cov0" title="0"> if redisTypeStr == "redis_cluster" </span><span class="cov0" title="0">{
                        t = redisCluster
                }</span> else<span class="cov0" title="0"> {
                        return -1, fmt.Errorf("failed to convert redis_type to enum: %s. Must be one of 'redis', 'redis_cluster'", redisTypeStr)
                }</span>
        }
        <span class="cov8" title="1">return t, nil</span>
}

func (r *RedisOnlineStore) buildFeatureViewIndices(featureViewNames []string, featureNames []string) (map[string]int, map[int]string, int) <span class="cov8" title="1">{
        featureViewIndices := make(map[string]int)
        indicesFeatureView := make(map[int]string)
        index := len(featureNames)
        for _, featureViewName := range featureViewNames </span><span class="cov8" title="1">{
                if _, ok := featureViewIndices[featureViewName]; !ok </span><span class="cov8" title="1">{
                        featureViewIndices[featureViewName] = index
                        indicesFeatureView[index] = featureViewName
                        index += 1
                }</span>
        }
        <span class="cov8" title="1">return featureViewIndices, indicesFeatureView, index</span>
}

func (r *RedisOnlineStore) buildHsetKeys(featureViewNames []string, featureNames []string, indicesFeatureView map[int]string, index int) ([]string, []string) <span class="cov8" title="1">{
        featureCount := len(featureNames)
        var hsetKeys = make([]string, index)
        h := murmur3.New32()
        intBuffer := h.Sum32()
        byteBuffer := make([]byte, 4)

        for i := 0; i &lt; featureCount; i++ </span><span class="cov8" title="1">{
                h.Write([]byte(fmt.Sprintf("%s:%s", featureViewNames[i], featureNames[i])))
                intBuffer = h.Sum32()
                binary.LittleEndian.PutUint32(byteBuffer, intBuffer)
                hsetKeys[i] = string(byteBuffer)
                h.Reset()
        }</span>
        <span class="cov8" title="1">for i := featureCount; i &lt; index; i++ </span><span class="cov8" title="1">{
                view := indicesFeatureView[i]
                tsKey := fmt.Sprintf("_ts:%s", view)
                hsetKeys[i] = tsKey
                featureNames = append(featureNames, tsKey)
        }</span>
        <span class="cov8" title="1">return hsetKeys, featureNames</span>
}

func (r *RedisOnlineStore) buildRedisKeys(entityKeys []*types.EntityKey) ([]*[]byte, map[string]int, error) <span class="cov8" title="1">{
        redisKeys := make([]*[]byte, len(entityKeys))
        redisKeyToEntityIndex := make(map[string]int)
        for i := 0; i &lt; len(entityKeys); i++ </span><span class="cov8" title="1">{
                var key, err = buildRedisKey(r.project, entityKeys[i], r.config.EntityKeySerializationVersion)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, nil, err
                }</span>
                <span class="cov8" title="1">redisKeys[i] = key
                redisKeyToEntityIndex[string(*key)] = i</span>
        }
        <span class="cov8" title="1">return redisKeys, redisKeyToEntityIndex, nil</span>
}

func (r *RedisOnlineStore) OnlineRead(ctx context.Context, entityKeys []*types.EntityKey, featureViewNames []string, featureNames []string) ([][]FeatureData, error) <span class="cov0" title="0">{
        span, _ := tracer.StartSpanFromContext(ctx, "redis.OnlineRead")
        defer span.Finish()

        featureCount := len(featureNames)
        featureViewIndices, indicesFeatureView, index := r.buildFeatureViewIndices(featureViewNames, featureNames)
        hsetKeys, featureNamesWithTimeStamps := r.buildHsetKeys(featureViewNames, featureNames, indicesFeatureView, index)
        redisKeys, redisKeyToEntityIndex, err := r.buildRedisKeys(entityKeys)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">results := make([][]FeatureData, len(entityKeys))
        commands := map[string]*redis.SliceCmd{}

        if r.t == redisNode </span><span class="cov0" title="0">{
                pipe := r.client.Pipeline()
                for _, redisKey := range redisKeys </span><span class="cov0" title="0">{
                        keyString := string(*redisKey)
                        commands[keyString] = pipe.HMGet(ctx, keyString, hsetKeys...)
                }</span>
                <span class="cov0" title="0">_, err = pipe.Exec(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        } else<span class="cov0" title="0"> if r.t == redisCluster </span><span class="cov0" title="0">{
                pipe := r.clusterClient.Pipeline()
                for _, redisKey := range redisKeys </span><span class="cov0" title="0">{
                        keyString := string(*redisKey)
                        commands[keyString] = pipe.HMGet(ctx, keyString, hsetKeys...)
                }</span>
                <span class="cov0" title="0">_, err = pipe.Exec(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov0" title="0">var entityIndex int
        var resContainsNonNil bool
        for redisKey, values := range commands </span><span class="cov0" title="0">{

                entityIndex = redisKeyToEntityIndex[redisKey]
                resContainsNonNil = false

                results[entityIndex] = make([]FeatureData, featureCount)
                res, err := values.Result()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">var timeStamp timestamppb.Timestamp

                for featureIndex, resString := range res </span><span class="cov0" title="0">{
                        if featureIndex == featureCount </span><span class="cov0" title="0">{
                                break</span>
                        }

                        <span class="cov0" title="0">if resString == nil </span><span class="cov0" title="0">{
                                // TODO (Ly): Can there be nil result within each feature or they will all be returned as string proto of types.Value_NullVal proto?
                                featureName := featureNamesWithTimeStamps[featureIndex]
                                featureViewName := featureViewNames[featureIndex]
                                timeStampIndex := featureViewIndices[featureViewName]
                                timeStampInterface := res[timeStampIndex]
                                if timeStampInterface != nil </span><span class="cov0" title="0">{
                                        if timeStampString, ok := timeStampInterface.(string); !ok </span><span class="cov0" title="0">{
                                                return nil, errors.New("error parsing value from redis")
                                        }</span> else<span class="cov0" title="0"> {
                                                if err := proto.Unmarshal([]byte(timeStampString), &amp;timeStamp); err != nil </span><span class="cov0" title="0">{
                                                        return nil, errors.New("error converting parsed redis value to timestamppb.Timestamp")
                                                }</span>
                                        }
                                }

                                <span class="cov0" title="0">results[entityIndex][featureIndex] = FeatureData{Reference: serving.FeatureReferenceV2{FeatureViewName: featureViewName, FeatureName: featureName},
                                        Timestamp: timestamppb.Timestamp{Seconds: timeStamp.Seconds, Nanos: timeStamp.Nanos},
                                        Value:     types.Value{Val: &amp;types.Value_NullVal{NullVal: types.Null_NULL}},
                                }</span>

                        } else<span class="cov0" title="0"> if valueString, ok := resString.(string); !ok </span><span class="cov0" title="0">{
                                return nil, errors.New("error parsing Value from redis")
                        }</span> else<span class="cov0" title="0"> {
                                resContainsNonNil = true
                                var value types.Value
                                if err := proto.Unmarshal([]byte(valueString), &amp;value); err != nil </span><span class="cov0" title="0">{
                                        return nil, errors.New("error converting parsed redis Value to types.Value")
                                }</span> else<span class="cov0" title="0"> {
                                        featureName := featureNamesWithTimeStamps[featureIndex]
                                        featureViewName := featureViewNames[featureIndex]
                                        timeStampIndex := featureViewIndices[featureViewName]
                                        timeStampInterface := res[timeStampIndex]
                                        if timeStampInterface != nil </span><span class="cov0" title="0">{
                                                if timeStampString, ok := timeStampInterface.(string); !ok </span><span class="cov0" title="0">{
                                                        return nil, errors.New("error parsing Value from redis")
                                                }</span> else<span class="cov0" title="0"> {
                                                        if err := proto.Unmarshal([]byte(timeStampString), &amp;timeStamp); err != nil </span><span class="cov0" title="0">{
                                                                return nil, errors.New("error converting parsed redis Value to timestamppb.Timestamp")
                                                        }</span>
                                                }
                                        }
                                        <span class="cov0" title="0">results[entityIndex][featureIndex] = FeatureData{Reference: serving.FeatureReferenceV2{FeatureViewName: featureViewName, FeatureName: featureName},
                                                Timestamp: timestamppb.Timestamp{Seconds: timeStamp.Seconds, Nanos: timeStamp.Nanos},
                                                Value:     types.Value{Val: value.Val},
                                        }</span>
                                }
                        }
                }

                <span class="cov0" title="0">if !resContainsNonNil </span><span class="cov0" title="0">{
                        results[entityIndex] = nil
                }</span>

        }

        <span class="cov0" title="0">return results, nil</span>
}

// Dummy destruct function to conform with plugin OnlineStore interface
func (r *RedisOnlineStore) Destruct() {<span class="cov0" title="0">

}</span>

func buildRedisKey(project string, entityKey *types.EntityKey, entityKeySerializationVersion int64) (*[]byte, error) <span class="cov8" title="1">{
        serKey, err := serializeEntityKey(entityKey, entityKeySerializationVersion)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">fullKey := append(*serKey, []byte(project)...)
        return &amp;fullKey, nil</span>
}

func serializeEntityKey(entityKey *types.EntityKey, entityKeySerializationVersion int64) (*[]byte, error) <span class="cov8" title="1">{
        // Serialize entity key to a bytestring so that it can be used as a lookup key in a hash table.

        // Ensure that we have the right amount of join keys and entity values
        if len(entityKey.JoinKeys) != len(entityKey.EntityValues) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("the amount of join key names and entity values don't match: %s vs %s", entityKey.JoinKeys, entityKey.EntityValues)
        }</span>

        // Make sure that join keys are sorted so that we have consistent key building
        <span class="cov8" title="1">m := make(map[string]*types.Value)

        for i := 0; i &lt; len(entityKey.JoinKeys); i++ </span><span class="cov8" title="1">{
                m[entityKey.JoinKeys[i]] = entityKey.EntityValues[i]
        }</span>

        <span class="cov8" title="1">keys := make([]string, 0, len(m))
        for k := range entityKey.JoinKeys </span><span class="cov8" title="1">{
                keys = append(keys, entityKey.JoinKeys[k])
        }</span>
        <span class="cov8" title="1">sort.Strings(keys)

        // Build the key
        length := 5 * len(keys)
        bufferList := make([][]byte, length)

        for i := 0; i &lt; len(keys); i++ </span><span class="cov8" title="1">{
                offset := i * 2
                byteBuffer := make([]byte, 4)
                binary.LittleEndian.PutUint32(byteBuffer, uint32(types.ValueType_Enum_value["STRING"]))
                bufferList[offset] = byteBuffer
                bufferList[offset+1] = []byte(keys[i])
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; len(keys); i++ </span><span class="cov8" title="1">{
                offset := (2 * len(keys)) + (i * 3)
                value := m[keys[i]].GetVal()

                valueBytes, valueTypeBytes, err := serializeValue(value, entityKeySerializationVersion)
                if err != nil </span><span class="cov0" title="0">{
                        return valueBytes, err
                }</span>

                <span class="cov8" title="1">typeBuffer := make([]byte, 4)
                binary.LittleEndian.PutUint32(typeBuffer, uint32(valueTypeBytes))

                lenBuffer := make([]byte, 4)
                binary.LittleEndian.PutUint32(lenBuffer, uint32(len(*valueBytes)))

                bufferList[offset+0] = typeBuffer
                bufferList[offset+1] = lenBuffer
                bufferList[offset+2] = *valueBytes</span>
        }

        // Convert from an array of byte arrays to a single byte array
        <span class="cov8" title="1">var entityKeyBuffer []byte
        for i := 0; i &lt; len(bufferList); i++ </span><span class="cov8" title="1">{
                entityKeyBuffer = append(entityKeyBuffer, bufferList[i]...)
        }</span>

        <span class="cov8" title="1">return &amp;entityKeyBuffer, nil</span>
}

func serializeValue(value interface{}, entityKeySerializationVersion int64) (*[]byte, types.ValueType_Enum, error) <span class="cov8" title="1">{
        // TODO: Implement support for other types (at least the major types like ints, strings, bytes)
        switch x := (value).(type) </span>{
        case *types.Value_StringVal:<span class="cov0" title="0">
                valueString := []byte(x.StringVal)
                return &amp;valueString, types.ValueType_STRING, nil</span>
        case *types.Value_BytesVal:<span class="cov0" title="0">
                return &amp;x.BytesVal, types.ValueType_BYTES, nil</span>
        case *types.Value_Int32Val:<span class="cov0" title="0">
                valueBuffer := make([]byte, 4)
                binary.LittleEndian.PutUint32(valueBuffer, uint32(x.Int32Val))
                return &amp;valueBuffer, types.ValueType_INT32, nil</span>
        case *types.Value_Int64Val:<span class="cov8" title="1">
                if entityKeySerializationVersion &lt;= 1 </span><span class="cov0" title="0">{
                        //  We unfortunately have to use 32 bit here for backward compatibility :(
                        valueBuffer := make([]byte, 4)
                        binary.LittleEndian.PutUint32(valueBuffer, uint32(x.Int64Val))
                        return &amp;valueBuffer, types.ValueType_INT64, nil
                }</span> else<span class="cov8" title="1"> {
                        valueBuffer := make([]byte, 8)
                        binary.LittleEndian.PutUint64(valueBuffer, uint64(x.Int64Val))
                        return &amp;valueBuffer, types.ValueType_INT64, nil
                }</span>
        case nil:<span class="cov0" title="0">
                return nil, types.ValueType_INVALID, fmt.Errorf("could not detect type for %v", x)</span>
        default:<span class="cov0" title="0">
                return nil, types.ValueType_INVALID, fmt.Errorf("could not detect type for %v", x)</span>
        }
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package onlinestore

import (
        "crypto/sha1"
        "database/sql"
        "encoding/hex"
        "errors"
        "strings"
        "sync"
        "time"

        "github.com/feast-dev/feast/go/internal/feast/registry"

        "context"
        "fmt"

        _ "github.com/mattn/go-sqlite3"
        "google.golang.org/protobuf/proto"
        "google.golang.org/protobuf/types/known/timestamppb"

        "github.com/feast-dev/feast/go/protos/feast/serving"
        "github.com/feast-dev/feast/go/protos/feast/types"
)

type SqliteOnlineStore struct {
        // Feast project name
        project    string
        path       string
        db         *sql.DB
        db_mu      sync.Mutex
        repoConfig *registry.RepoConfig
}

// Creates a new sqlite online store object. onlineStoreConfig should have relative path of database file with respect to repoConfig.repoPath.
func NewSqliteOnlineStore(project string, repoConfig *registry.RepoConfig, onlineStoreConfig map[string]interface{}) (*SqliteOnlineStore, error) <span class="cov8" title="1">{
        store := SqliteOnlineStore{project: project, repoConfig: repoConfig}
        if db_path, ok := onlineStoreConfig["path"]; !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("cannot find sqlite path %s", db_path)
        }</span> else<span class="cov8" title="1"> {
                if dbPathStr, ok := db_path.(string); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("cannot find convert sqlite path to string %s", db_path)
                }</span> else<span class="cov8" title="1"> {
                        store.path = fmt.Sprintf("%s/%s", repoConfig.RepoPath, dbPathStr)

                        db, err := initializeConnection(store.path)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">store.db = db</span>
                }
        }

        <span class="cov8" title="1">return &amp;store, nil</span>
}

func (s *SqliteOnlineStore) Destruct() <span class="cov8" title="1">{
        s.db.Close()
}</span>

// Returns FeatureData 2D array. Each row corresponds to one entity Value and each column corresponds to a single feature where the number of columns should be
// same length as the length of featureNames. Reads from every table in featureViewNames with the entity keys described.
func (s *SqliteOnlineStore) OnlineRead(ctx context.Context, entityKeys []*types.EntityKey, featureViewNames []string, featureNames []string) ([][]FeatureData, error) <span class="cov8" title="1">{
        featureCount := len(featureNames)
        _, err := s.getConnection()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">project := s.project
        results := make([][]FeatureData, len(entityKeys))
        entityNameToEntityIndex := make(map[string]int)
        in_query := make([]string, len(entityKeys))
        serialized_entities := make([]interface{}, len(entityKeys))
        for i := 0; i &lt; len(entityKeys); i++ </span><span class="cov8" title="1">{
                serKey, err := serializeEntityKey(entityKeys[i], s.repoConfig.EntityKeySerializationVersion)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                // TODO: fix this, string conversion is not safe
                <span class="cov8" title="1">entityNameToEntityIndex[hashSerializedEntityKey(serKey)] = i
                // for IN clause in read query
                in_query[i] = "?"
                serialized_entities[i] = *serKey</span>
        }
        <span class="cov8" title="1">featureNamesToIdx := make(map[string]int)
        for idx, name := range featureNames </span><span class="cov8" title="1">{
                featureNamesToIdx[name] = idx
        }</span>

        <span class="cov8" title="1">for _, featureViewName := range featureViewNames </span><span class="cov8" title="1">{
                query_string := fmt.Sprintf(`SELECT entity_key, feature_name, Value, event_ts
                                                                        FROM %s
                                                                        WHERE entity_key IN (%s)
                                                                        ORDER BY entity_key`, tableId(project, featureViewName), strings.Join(in_query, ","))
                rows, err := s.db.Query(query_string, serialized_entities...)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">defer rows.Close()
                for rows.Next() </span><span class="cov8" title="1">{
                        var entity_key []byte
                        var feature_name string
                        var valueString []byte
                        var event_ts time.Time
                        var value types.Value
                        err = rows.Scan(&amp;entity_key, &amp;feature_name, &amp;valueString, &amp;event_ts)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, errors.New("error could not resolve row in query (entity key, feature name, value, event ts)")
                        }</span>
                        <span class="cov8" title="1">if err := proto.Unmarshal(valueString, &amp;value); err != nil </span><span class="cov0" title="0">{
                                return nil, errors.New("error converting parsed value to types.Value")
                        }</span>
                        <span class="cov8" title="1">rowIdx := entityNameToEntityIndex[hashSerializedEntityKey(&amp;entity_key)]
                        if results[rowIdx] == nil </span><span class="cov8" title="1">{
                                results[rowIdx] = make([]FeatureData, featureCount)
                        }</span>
                        <span class="cov8" title="1">results[rowIdx][featureNamesToIdx[feature_name]] = FeatureData{Reference: serving.FeatureReferenceV2{FeatureViewName: featureViewName, FeatureName: feature_name},
                                Timestamp: *timestamppb.New(event_ts),
                                Value:     types.Value{Val: value.Val},
                        }</span>
                }
        }
        <span class="cov8" title="1">return results, nil</span>
}

// Gets a sqlite connection and sets it to the online store and also returns a pointer to the connection.
func (s *SqliteOnlineStore) getConnection() (*sql.DB, error) <span class="cov8" title="1">{
        s.db_mu.Lock()
        defer s.db_mu.Unlock()
        if s.db == nil </span><span class="cov0" title="0">{
                if s.path == "" </span><span class="cov0" title="0">{
                        return nil, errors.New("no database path available")
                }</span>
                <span class="cov0" title="0">db, err := initializeConnection(s.path)
                s.db = db
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">return s.db, nil</span>
}

// Constructs the table id from the project and table(featureViewName) string.
func tableId(project string, featureViewName string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s_%s", project, featureViewName)
}</span>

// Creates a connection to the sqlite database and returns the connection.
func initializeConnection(db_path string) (*sql.DB, error) <span class="cov8" title="1">{
        db, err := sql.Open("sqlite3", db_path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return db, nil</span>
}

func hashSerializedEntityKey(serializedEntityKey *[]byte) string <span class="cov8" title="1">{
        if serializedEntityKey == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">h := sha1.New()
        h.Write(*serializedEntityKey)
        sha1_hash := hex.EncodeToString(h.Sum(nil))
        return sha1_hash</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package registry

import (
        "crypto/tls"
        "fmt"
        "io"
        "net/http"
        "time"

        "github.com/feast-dev/feast/go/protos/feast/core"
        "github.com/rs/zerolog/log"
        "google.golang.org/protobuf/proto"
)

type HttpRegistryStore struct {
        project  string
        endpoint string
        clientId string
        client   http.Client
}

// NotImplementedError represents an error for a function that is not yet implemented.
type NotImplementedError struct {
        FunctionName string
}

// Error implements the error interface for NotImplementedError.
func (e *NotImplementedError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("Function '%s' not implemented", e.FunctionName)
}</span>

func NewHttpRegistryStore(config *RegistryConfig, project string) (*HttpRegistryStore, error) <span class="cov0" title="0">{
        tr := &amp;http.Transport{
                TLSClientConfig: &amp;tls.Config{InsecureSkipVerify: true},
                IdleConnTimeout: 60 * time.Second,
        }

        hrs := &amp;HttpRegistryStore{
                project:  project,
                endpoint: config.Path,
                clientId: config.ClientId,
                client: http.Client{
                        Transport: tr,
                        Timeout:   5 * time.Second,
                },
        }

        if err := hrs.TestConnectivity(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return hrs, nil</span>
}

func (hrs *HttpRegistryStore) TestConnectivity() error <span class="cov0" title="0">{
        resp, err := hrs.client.Get(hrs.endpoint)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return fmt.Errorf("HTTP Registry connectivity check failed with status code: %d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *HttpRegistryStore) makeHttpRequest(url string) (*http.Response, error) <span class="cov8" title="1">{
        req, err := http.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">req.Header.Add("Accept", "application/x-protobuf")
        req.Header.Add("Client-Id", r.clientId)

        resp, err := r.client.Do(req)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if resp.StatusCode != http.StatusOK </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("HTTP Error: %s", resp.Status)
        }</span>

        <span class="cov8" title="1">return resp, nil</span>
}

func (r *HttpRegistryStore) loadProtobufMessages(url string, messageProcessor func([]byte) error) error <span class="cov8" title="1">{
        resp, err := r.makeHttpRequest(url)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        buffer, err := io.ReadAll(resp.Body)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if err := messageProcessor(buffer); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (r *HttpRegistryStore) loadEntities(registry *core.Registry) error <span class="cov8" title="1">{
        url := fmt.Sprintf("%s/projects/%s/entities?allow_cache=true", r.endpoint, r.project)
        return r.loadProtobufMessages(url, func(data []byte) error </span><span class="cov8" title="1">{
                entity_list := &amp;core.EntityList{}
                if err := proto.Unmarshal(data, entity_list); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if len(entity_list.GetEntities()) == 0 </span><span class="cov0" title="0">{
                        log.Warn().Msg(fmt.Sprintf("Feature Registry has no associated Entities for project %s.", r.project))
                }</span>
                <span class="cov8" title="1">registry.Entities = append(registry.Entities, entity_list.GetEntities()...)
                return nil</span>
        })
}

func (r *HttpRegistryStore) loadDatasources(registry *core.Registry) error <span class="cov8" title="1">{
        url := fmt.Sprintf("%s/projects/%s/data_sources?allow_cache=true", r.endpoint, r.project)
        return r.loadProtobufMessages(url, func(data []byte) error </span><span class="cov8" title="1">{
                data_source_list := &amp;core.DataSourceList{}
                if err := proto.Unmarshal(data, data_source_list); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if len(data_source_list.GetDatasources()) == 0 </span><span class="cov0" title="0">{
                        log.Warn().Msg(fmt.Sprintf("Feature Registry has no associated Datasources for project %s.", r.project))
                }</span>
                <span class="cov8" title="1">registry.DataSources = append(registry.DataSources, data_source_list.GetDatasources()...)
                return nil</span>
        })
}

func (r *HttpRegistryStore) loadFeatureViews(registry *core.Registry) error <span class="cov8" title="1">{
        url := fmt.Sprintf("%s/projects/%s/feature_views?allow_cache=true", r.endpoint, r.project)
        return r.loadProtobufMessages(url, func(data []byte) error </span><span class="cov8" title="1">{
                feature_view_list := &amp;core.FeatureViewList{}
                if err := proto.Unmarshal(data, feature_view_list); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if len(feature_view_list.GetFeatureviews()) == 0 </span><span class="cov0" title="0">{
                        log.Warn().Msg(fmt.Sprintf("Feature Registry has no associated FeatureViews for project %s.", r.project))
                }</span>
                <span class="cov8" title="1">registry.FeatureViews = append(registry.FeatureViews, feature_view_list.GetFeatureviews()...)
                return nil</span>
        })
}

func (r *HttpRegistryStore) loadOnDemandFeatureViews(registry *core.Registry) error <span class="cov8" title="1">{
        url := fmt.Sprintf("%s/projects/%s/on_demand_feature_views?allow_cache=true", r.endpoint, r.project)
        return r.loadProtobufMessages(url, func(data []byte) error </span><span class="cov8" title="1">{
                od_feature_view_list := &amp;core.OnDemandFeatureViewList{}
                if err := proto.Unmarshal(data, od_feature_view_list); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">registry.OnDemandFeatureViews = append(registry.OnDemandFeatureViews, od_feature_view_list.GetOndemandfeatureviews()...)
                return nil</span>
        })
}

func (r *HttpRegistryStore) loadFeatureServices(registry *core.Registry) error <span class="cov8" title="1">{
        url := fmt.Sprintf("%s/projects/%s/feature_services?allow_cache=true", r.endpoint, r.project)
        return r.loadProtobufMessages(url, func(data []byte) error </span><span class="cov8" title="1">{
                feature_service_list := &amp;core.FeatureServiceList{}
                if err := proto.Unmarshal(data, feature_service_list); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">registry.FeatureServices = append(registry.FeatureServices, feature_service_list.GetFeatureservices()...)
                return nil</span>
        })
}

func (r *HttpRegistryStore) GetRegistryProto() (*core.Registry, error) <span class="cov8" title="1">{

        registry := core.Registry{}

        if err := r.loadEntities(&amp;registry); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := r.loadDatasources(&amp;registry); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := r.loadFeatureViews(&amp;registry); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := r.loadOnDemandFeatureViews(&amp;registry); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := r.loadFeatureServices(&amp;registry); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;registry, nil</span>
}

func (r *HttpRegistryStore) UpdateRegistryProto(rp *core.Registry) error <span class="cov8" title="1">{
        return &amp;NotImplementedError{FunctionName: "UpdateRegistryProto"}
}</span>

func (r *HttpRegistryStore) Teardown() error <span class="cov8" title="1">{
        return &amp;NotImplementedError{FunctionName: "Teardown"}
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package registry

import (
        "io/ioutil"
        "os"
        "path/filepath"

        "github.com/google/uuid"
        "google.golang.org/protobuf/proto"
        "google.golang.org/protobuf/types/known/timestamppb"

        "github.com/feast-dev/feast/go/protos/feast/core"
)

// A FileRegistryStore is a file-based implementation of the RegistryStore interface.
type FileRegistryStore struct {
        filePath string
}

// NewFileRegistryStore creates a FileRegistryStore with the given configuration and infers
// the file path from the repo path and registry path.
func NewFileRegistryStore(config *RegistryConfig, repoPath string) *FileRegistryStore <span class="cov0" title="0">{
        lr := FileRegistryStore{}
        registryPath := config.Path
        if filepath.IsAbs(registryPath) </span><span class="cov0" title="0">{
                lr.filePath = registryPath
        }</span> else<span class="cov0" title="0"> {
                lr.filePath = filepath.Join(repoPath, registryPath)
        }</span>
        <span class="cov0" title="0">return &amp;lr</span>
}

// GetRegistryProto reads and parses the registry proto from the file path.
func (r *FileRegistryStore) GetRegistryProto() (*core.Registry, error) <span class="cov0" title="0">{
        registry := &amp;core.Registry{}
        in, err := ioutil.ReadFile(r.filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := proto.Unmarshal(in, registry); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return registry, nil</span>
}

func (r *FileRegistryStore) UpdateRegistryProto(rp *core.Registry) error <span class="cov0" title="0">{
        return r.writeRegistry(rp)
}</span>

func (r *FileRegistryStore) Teardown() error <span class="cov0" title="0">{
        return os.Remove(r.filePath)
}</span>

func (r *FileRegistryStore) writeRegistry(rp *core.Registry) error <span class="cov0" title="0">{
        rp.VersionId = uuid.New().String()
        rp.LastUpdated = timestamppb.Now()
        bytes, err := proto.Marshal(rp)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">err = ioutil.WriteFile(r.filePath, bytes, 0644)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package registry

import (
        "errors"
        "fmt"
        "net/url"
        "sync"
        "time"

        "github.com/feast-dev/feast/go/internal/feast/model"
        "github.com/rs/zerolog/log"

        "github.com/feast-dev/feast/go/protos/feast/core"
)

var REGISTRY_SCHEMA_VERSION string = "1"
var REGISTRY_STORE_CLASS_FOR_SCHEME map[string]string = map[string]string{
        "gs":    "GCSRegistryStore",
        "s3":    "S3RegistryStore",
        "file":  "FileRegistryStore",
        "http":  "HttpRegistryStore",
        "https": "HttpRegistryStore",
        "":      "FileRegistryStore",
}

/*
        Store protos of FeatureView, FeatureService, Entity, OnDemandFeatureView
        but return to user copies of non-proto versions of these objects
*/

type Registry struct {
        project                        string
        registryStore                  RegistryStore
        cachedFeatureServices          map[string]map[string]*core.FeatureService
        cachedEntities                 map[string]map[string]*core.Entity
        cachedFeatureViews             map[string]map[string]*core.FeatureView
        cachedStreamFeatureViews       map[string]map[string]*core.StreamFeatureView
        CachedOnDemandFeatureViews     map[string]map[string]*core.OnDemandFeatureView
        cachedRegistry                 *core.Registry
        cachedRegistryProtoLastUpdated time.Time
        cachedRegistryProtoTtl         time.Duration
        mu                             sync.RWMutex
}

func NewRegistry(registryConfig *RegistryConfig, repoPath string, project string) (*Registry, error) <span class="cov0" title="0">{
        registryStoreType := registryConfig.RegistryStoreType
        registryPath := registryConfig.Path
        r := &amp;Registry{
                project:                project,
                cachedRegistryProtoTtl: time.Duration(registryConfig.CacheTtlSeconds) * time.Second,
        }

        if len(registryStoreType) == 0 </span><span class="cov0" title="0">{
                registryStore, err := getRegistryStoreFromScheme(registryPath, registryConfig, repoPath, project)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">r.registryStore = registryStore</span>
        } else<span class="cov0" title="0"> {
                registryStore, err := getRegistryStoreFromType(registryStoreType, registryConfig, repoPath, project)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">r.registryStore = registryStore</span>
        }

        <span class="cov0" title="0">return r, nil</span>
}

func (r *Registry) InitializeRegistry() error <span class="cov0" title="0">{
        _, err := r.getRegistryProto()
        if err != nil </span><span class="cov0" title="0">{
                if _, ok := r.registryStore.(*HttpRegistryStore); ok </span><span class="cov0" title="0">{
                        log.Error().Err(err).Msg("Registry Initialization Failed")
                        return err
                }</span>
                <span class="cov0" title="0">registryProto := &amp;core.Registry{RegistrySchemaVersion: REGISTRY_SCHEMA_VERSION}
                r.registryStore.UpdateRegistryProto(registryProto)</span>
        }
        <span class="cov0" title="0">go r.RefreshRegistryOnInterval()
        return nil</span>
}

func (r *Registry) RefreshRegistryOnInterval() <span class="cov0" title="0">{
        ticker := time.NewTicker(r.cachedRegistryProtoTtl)
        for ; true; &lt;-ticker.C </span><span class="cov0" title="0">{
                err := r.refresh()
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Stack().Err(err).Msg("Registry refresh Failed")
                }</span>
        }
}

func (r *Registry) refresh() error <span class="cov0" title="0">{
        _, err := r.getRegistryProto()
        return err
}</span>

func (r *Registry) getRegistryProto() (*core.Registry, error) <span class="cov0" title="0">{
        expired := r.cachedRegistry == nil || (r.cachedRegistryProtoTtl &gt; 0 &amp;&amp; time.Now().After(r.cachedRegistryProtoLastUpdated.Add(r.cachedRegistryProtoTtl)))
        if !expired </span><span class="cov0" title="0">{
                return r.cachedRegistry, nil
        }</span>
        <span class="cov0" title="0">registryProto, err := r.registryStore.GetRegistryProto()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">r.load(registryProto)
        return registryProto, nil</span>
}

func (r *Registry) load(registry *core.Registry) <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()
        r.cachedRegistry = registry
        r.cachedFeatureServices = make(map[string]map[string]*core.FeatureService)
        r.cachedEntities = make(map[string]map[string]*core.Entity)
        r.cachedFeatureViews = make(map[string]map[string]*core.FeatureView)
        r.cachedStreamFeatureViews = make(map[string]map[string]*core.StreamFeatureView)
        r.CachedOnDemandFeatureViews = make(map[string]map[string]*core.OnDemandFeatureView)
        r.loadEntities(registry)
        r.loadFeatureServices(registry)
        r.loadFeatureViews(registry)
        r.loadStreamFeatureViews(registry)
        r.loadOnDemandFeatureViews(registry)
        r.cachedRegistryProtoLastUpdated = time.Now()
}</span>

func (r *Registry) loadEntities(registry *core.Registry) <span class="cov0" title="0">{
        entities := registry.Entities
        for _, entity := range entities </span><span class="cov0" title="0">{
                if _, ok := r.cachedEntities[r.project]; !ok </span><span class="cov0" title="0">{
                        r.cachedEntities[r.project] = make(map[string]*core.Entity)
                }</span>
                <span class="cov0" title="0">r.cachedEntities[r.project][entity.Spec.Name] = entity</span>
        }
}

func (r *Registry) loadFeatureServices(registry *core.Registry) <span class="cov0" title="0">{
        featureServices := registry.FeatureServices
        for _, featureService := range featureServices </span><span class="cov0" title="0">{
                if _, ok := r.cachedFeatureServices[r.project]; !ok </span><span class="cov0" title="0">{
                        r.cachedFeatureServices[r.project] = make(map[string]*core.FeatureService)
                }</span>
                <span class="cov0" title="0">r.cachedFeatureServices[r.project][featureService.Spec.Name] = featureService</span>
        }
}

func (r *Registry) loadFeatureViews(registry *core.Registry) <span class="cov0" title="0">{
        featureViews := registry.FeatureViews
        for _, featureView := range featureViews </span><span class="cov0" title="0">{
                if _, ok := r.cachedFeatureViews[r.project]; !ok </span><span class="cov0" title="0">{
                        r.cachedFeatureViews[r.project] = make(map[string]*core.FeatureView)
                }</span>
                <span class="cov0" title="0">r.cachedFeatureViews[r.project][featureView.Spec.Name] = featureView</span>
        }
}

func (r *Registry) loadStreamFeatureViews(registry *core.Registry) <span class="cov0" title="0">{
        streamFeatureViews := registry.StreamFeatureViews
        for _, streamFeatureView := range streamFeatureViews </span><span class="cov0" title="0">{
                if _, ok := r.cachedStreamFeatureViews[r.project]; !ok </span><span class="cov0" title="0">{
                        r.cachedStreamFeatureViews[r.project] = make(map[string]*core.StreamFeatureView)
                }</span>
                <span class="cov0" title="0">r.cachedStreamFeatureViews[r.project][streamFeatureView.Spec.Name] = streamFeatureView</span>
        }
}

func (r *Registry) loadOnDemandFeatureViews(registry *core.Registry) <span class="cov0" title="0">{
        onDemandFeatureViews := registry.OnDemandFeatureViews
        for _, onDemandFeatureView := range onDemandFeatureViews </span><span class="cov0" title="0">{
                if _, ok := r.CachedOnDemandFeatureViews[r.project]; !ok </span><span class="cov0" title="0">{
                        r.CachedOnDemandFeatureViews[r.project] = make(map[string]*core.OnDemandFeatureView)
                }</span>
                <span class="cov0" title="0">r.CachedOnDemandFeatureViews[r.project][onDemandFeatureView.Spec.Name] = onDemandFeatureView</span>
        }
}

/*
        Look up Entities inside project
        Returns empty list if project not found
*/

func (r *Registry) ListEntities(project string) ([]*model.Entity, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        if cachedEntities, ok := r.cachedEntities[project]; !ok </span><span class="cov0" title="0">{
                return []*model.Entity{}, nil
        }</span> else<span class="cov0" title="0"> {
                entities := make([]*model.Entity, len(cachedEntities))
                index := 0
                for _, entityProto := range cachedEntities </span><span class="cov0" title="0">{
                        entities[index] = model.NewEntityFromProto(entityProto)
                        index += 1
                }</span>
                <span class="cov0" title="0">return entities, nil</span>
        }
}

/*
        Look up Feature Views inside project
        Returns empty list if project not found
*/

func (r *Registry) ListFeatureViews(project string) ([]*model.FeatureView, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        if cachedFeatureViews, ok := r.cachedFeatureViews[project]; !ok </span><span class="cov0" title="0">{
                return []*model.FeatureView{}, nil
        }</span> else<span class="cov0" title="0"> {
                featureViews := make([]*model.FeatureView, len(cachedFeatureViews))
                index := 0
                for _, featureViewProto := range cachedFeatureViews </span><span class="cov0" title="0">{
                        featureViews[index] = model.NewFeatureViewFromProto(featureViewProto)
                        index += 1
                }</span>
                <span class="cov0" title="0">return featureViews, nil</span>
        }
}

/*
        Look up Stream Feature Views inside project
        Returns empty list if project not found
*/

func (r *Registry) ListStreamFeatureViews(project string) ([]*model.FeatureView, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        if cachedStreamFeatureViews, ok := r.cachedStreamFeatureViews[project]; !ok </span><span class="cov0" title="0">{
                return []*model.FeatureView{}, nil
        }</span> else<span class="cov0" title="0"> {
                streamFeatureViews := make([]*model.FeatureView, len(cachedStreamFeatureViews))
                index := 0
                for _, streamFeatureViewProto := range cachedStreamFeatureViews </span><span class="cov0" title="0">{
                        streamFeatureViews[index] = model.NewFeatureViewFromStreamFeatureViewProto(streamFeatureViewProto)
                        index += 1
                }</span>
                <span class="cov0" title="0">return streamFeatureViews, nil</span>
        }
}

/*
        Look up Feature Services inside project
        Returns empty list if project not found
*/

func (r *Registry) ListFeatureServices(project string) ([]*model.FeatureService, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        if cachedFeatureServices, ok := r.cachedFeatureServices[project]; !ok </span><span class="cov0" title="0">{
                return []*model.FeatureService{}, nil
        }</span> else<span class="cov0" title="0"> {
                featureServices := make([]*model.FeatureService, len(cachedFeatureServices))
                index := 0
                for _, featureServiceProto := range cachedFeatureServices </span><span class="cov0" title="0">{
                        featureServices[index] = model.NewFeatureServiceFromProto(featureServiceProto)
                        index += 1
                }</span>
                <span class="cov0" title="0">return featureServices, nil</span>
        }
}

/*
        Look up On Demand Feature Views inside project
        Returns empty list if project not found
*/

func (r *Registry) ListOnDemandFeatureViews(project string) ([]*model.OnDemandFeatureView, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        if cachedOnDemandFeatureViews, ok := r.CachedOnDemandFeatureViews[project]; !ok </span><span class="cov0" title="0">{
                return []*model.OnDemandFeatureView{}, nil
        }</span> else<span class="cov0" title="0"> {
                onDemandFeatureViews := make([]*model.OnDemandFeatureView, len(cachedOnDemandFeatureViews))
                index := 0
                for _, onDemandFeatureViewProto := range cachedOnDemandFeatureViews </span><span class="cov0" title="0">{
                        onDemandFeatureViews[index] = model.NewOnDemandFeatureViewFromProto(onDemandFeatureViewProto)
                        index += 1
                }</span>
                <span class="cov0" title="0">return onDemandFeatureViews, nil</span>
        }
}

func (r *Registry) GetEntity(project, entityName string) (*model.Entity, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        if cachedEntities, ok := r.cachedEntities[project]; !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no cached entities found for project %s", project)
        }</span> else<span class="cov0" title="0"> {
                if entity, ok := cachedEntities[entityName]; !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("no cached entity %s found for project %s", entityName, project)
                }</span> else<span class="cov0" title="0"> {
                        return model.NewEntityFromProto(entity), nil
                }</span>
        }
}

func (r *Registry) GetFeatureView(project, featureViewName string) (*model.FeatureView, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        if cachedFeatureViews, ok := r.cachedFeatureViews[project]; !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no cached feature views found for project %s", project)
        }</span> else<span class="cov0" title="0"> {
                if featureViewProto, ok := cachedFeatureViews[featureViewName]; !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("no cached feature view %s found for project %s", featureViewName, project)
                }</span> else<span class="cov0" title="0"> {
                        return model.NewFeatureViewFromProto(featureViewProto), nil
                }</span>
        }
}

func (r *Registry) GetStreamFeatureView(project, streamFeatureViewName string) (*model.FeatureView, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        if cachedStreamFeatureViews, ok := r.cachedStreamFeatureViews[project]; !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no cached stream feature views found for project %s", project)
        }</span> else<span class="cov0" title="0"> {
                if streamFeatureViewProto, ok := cachedStreamFeatureViews[streamFeatureViewName]; !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("no cached stream feature view %s found for project %s", streamFeatureViewName, project)
                }</span> else<span class="cov0" title="0"> {
                        return model.NewFeatureViewFromStreamFeatureViewProto(streamFeatureViewProto), nil
                }</span>
        }
}

func (r *Registry) GetFeatureService(project, featureServiceName string) (*model.FeatureService, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        if cachedFeatureServices, ok := r.cachedFeatureServices[project]; !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no cached feature services found for project %s", project)
        }</span> else<span class="cov0" title="0"> {
                if featureServiceProto, ok := cachedFeatureServices[featureServiceName]; !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("no cached feature service %s found for project %s", featureServiceName, project)
                }</span> else<span class="cov0" title="0"> {
                        return model.NewFeatureServiceFromProto(featureServiceProto), nil
                }</span>
        }
}

func (r *Registry) GetOnDemandFeatureView(project, onDemandFeatureViewName string) (*model.OnDemandFeatureView, error) <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()
        if cachedOnDemandFeatureViews, ok := r.CachedOnDemandFeatureViews[project]; !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no cached on demand feature views found for project %s", project)
        }</span> else<span class="cov0" title="0"> {
                if onDemandFeatureViewProto, ok := cachedOnDemandFeatureViews[onDemandFeatureViewName]; !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("no cached on demand feature view %s found for project %s", onDemandFeatureViewName, project)
                }</span> else<span class="cov0" title="0"> {
                        return model.NewOnDemandFeatureViewFromProto(onDemandFeatureViewProto), nil
                }</span>
        }
}

func getRegistryStoreFromScheme(registryPath string, registryConfig *RegistryConfig, repoPath string, project string) (RegistryStore, error) <span class="cov0" title="0">{
        uri, err := url.Parse(registryPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if registryStoreType, ok := REGISTRY_STORE_CLASS_FOR_SCHEME[uri.Scheme]; ok </span><span class="cov0" title="0">{
                return getRegistryStoreFromType(registryStoreType, registryConfig, repoPath, project)
        }</span>
        <span class="cov0" title="0">return nil, fmt.Errorf("registry path %s has unsupported scheme %s. Supported schemes are file, s3 and gs", registryPath, uri.Scheme)</span>
}

func getRegistryStoreFromType(registryStoreType string, registryConfig *RegistryConfig, repoPath string, project string) (RegistryStore, error) <span class="cov0" title="0">{
        switch registryStoreType </span>{
        case "FileRegistryStore":<span class="cov0" title="0">
                return NewFileRegistryStore(registryConfig, repoPath), nil</span>
        case "HttpRegistryStore":<span class="cov0" title="0">
                return NewHttpRegistryStore(registryConfig, project)</span>
        }
        <span class="cov0" title="0">return nil, errors.New("only FileRegistryStore or HttpRegistryStore as a RegistryStore is supported at this moment")</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package registry

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "time"

        "github.com/feast-dev/feast/go/internal/feast/server/logging"
        "github.com/ghodss/yaml"
)

const (
        defaultCacheTtlSeconds = int64(600)
        defaultClientID        = "Unknown"
)

type RepoConfig struct {
        // Feast project name
        Project string `json:"project"`
        // Feast provider name
        Provider string `json:"provider"`
        // Path to the registry. Custom registry loaders are not yet supported
        // Registry string `json:"registry"`
        Registry interface{} `json:"registry"`
        // Online store config
        OnlineStore map[string]interface{} `json:"online_store"`
        // Offline store config
        OfflineStore map[string]interface{} `json:"offline_store"`
        // Feature server config (currently unrelated to Go server)
        FeatureServer map[string]interface{} `json:"feature_server"`
        // Feature flags for experimental features
        Flags map[string]interface{} `json:"flags"`
        // RepoPath
        RepoPath string `json:"repo_path"`
        // EntityKeySerializationVersion
        EntityKeySerializationVersion int64 `json:"entity_key_serialization_version"`
}

type RegistryConfig struct {
        RegistryStoreType string `json:"registry_store_type"`
        Path              string `json:"path"`
        ClientId          string `json:"client_id" default:"Unknown"`
        CacheTtlSeconds   int64  `json:"cache_ttl_seconds" default:"600"`
}

// NewRepoConfigFromJSON converts a JSON string into a RepoConfig struct and also sets the repo path.
func NewRepoConfigFromJSON(repoPath, configJSON string) (*RepoConfig, error) <span class="cov8" title="1">{
        config := RepoConfig{}
        if err := json.Unmarshal([]byte(configJSON), &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">repoPath, err := filepath.Abs(repoPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">config.RepoPath = repoPath
        return &amp;config, nil</span>
}

// NewRepoConfigFromFile reads the `feature_store.yaml` file in the repo path and converts it
// into a RepoConfig struct.
func NewRepoConfigFromFile(repoPath string) (*RepoConfig, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(filepath.Join(repoPath, "feature_store.yaml"))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">repoPath, err = filepath.Abs(repoPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">repoConfigWithEnv := os.ExpandEnv(string(data))

        config := RepoConfig{}
        if err = yaml.Unmarshal([]byte(repoConfigWithEnv), &amp;config); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">config.RepoPath = repoPath
        return &amp;config, nil</span>
}

func (r *RepoConfig) GetLoggingOptions() (*logging.LoggingOptions, error) <span class="cov8" title="1">{
        loggingOptions := logging.LoggingOptions{}
        if loggingOptionsMap, ok := r.FeatureServer["feature_logging"].(map[string]interface{}); ok </span><span class="cov8" title="1">{
                loggingOptions = logging.DefaultOptions
                for k, v := range loggingOptionsMap </span><span class="cov8" title="1">{
                        switch k </span>{
                        case "queue_capacity":<span class="cov8" title="1">
                                if value, ok := v.(int); ok </span><span class="cov8" title="1">{
                                        loggingOptions.ChannelCapacity = value
                                }</span>
                        case "emit_timeout_micro_secs":<span class="cov8" title="1">
                                if value, ok := v.(int); ok </span><span class="cov8" title="1">{
                                        loggingOptions.EmitTimeout = time.Duration(value) * time.Microsecond
                                }</span>
                        case "write_to_disk_interval_secs":<span class="cov8" title="1">
                                if value, ok := v.(int); ok </span><span class="cov8" title="1">{
                                        loggingOptions.WriteInterval = time.Duration(value) * time.Second
                                }</span>
                        case "flush_interval_secs":<span class="cov8" title="1">
                                if value, ok := v.(int); ok </span><span class="cov8" title="1">{
                                        loggingOptions.FlushInterval = time.Duration(value) * time.Second
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return &amp;loggingOptions, nil</span>
}

func (r *RepoConfig) GetRegistryConfig() (*RegistryConfig, error) <span class="cov8" title="1">{
        if registryConfigMap, ok := r.Registry.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                registryConfig := RegistryConfig{CacheTtlSeconds: defaultCacheTtlSeconds, ClientId: defaultClientID}
                for k, v := range registryConfigMap </span><span class="cov8" title="1">{
                        switch k </span>{
                        case "path":<span class="cov8" title="1">
                                if value, ok := v.(string); ok </span><span class="cov8" title="1">{
                                        registryConfig.Path = value
                                }</span>
                        case "registry_store_type":<span class="cov8" title="1">
                                if value, ok := v.(string); ok </span><span class="cov8" title="1">{
                                        registryConfig.RegistryStoreType = value
                                }</span>
                        case "client_id":<span class="cov8" title="1">
                                if value, ok := v.(string); ok </span><span class="cov8" title="1">{
                                        registryConfig.ClientId = value
                                }</span>
                        case "cache_ttl_seconds":<span class="cov8" title="1">
                                // cache_ttl_seconds defaulted to type float64. Ex: "cache_ttl_seconds": 60 in registryConfigMap
                                switch value := v.(type) </span>{
                                case float64:<span class="cov8" title="1">
                                        registryConfig.CacheTtlSeconds = int64(value)</span>
                                case int:<span class="cov8" title="1">
                                        registryConfig.CacheTtlSeconds = int64(value)</span>
                                case int32:<span class="cov8" title="1">
                                        registryConfig.CacheTtlSeconds = int64(value)</span>
                                case int64:<span class="cov8" title="1">
                                        registryConfig.CacheTtlSeconds = value</span>
                                default:<span class="cov0" title="0">
                                        return nil, fmt.Errorf("unexpected type %T for CacheTtlSeconds", v)</span>
                                }
                        }
                }
                <span class="cov8" title="1">return &amp;registryConfig, nil</span>
        } else<span class="cov8" title="1"> {
                return &amp;RegistryConfig{Path: r.Registry.(string), ClientId: defaultClientID, CacheTtlSeconds: defaultCacheTtlSeconds}, nil
        }</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package server

import (
        "context"
        "fmt"
        "github.com/feast-dev/feast/go/internal/feast"
        "github.com/feast-dev/feast/go/internal/feast/server/logging"
        "github.com/feast-dev/feast/go/protos/feast/serving"
        prototypes "github.com/feast-dev/feast/go/protos/feast/types"
        "github.com/feast-dev/feast/go/types"
        "github.com/google/uuid"
        "gopkg.in/DataDog/dd-trace-go.v1/ddtrace/tracer"
)

const feastServerVersion = "0.0.1"

type grpcServingServiceServer struct {
        fs             *feast.FeatureStore
        loggingService *logging.LoggingService
        serving.UnimplementedServingServiceServer
}

func NewGrpcServingServiceServer(fs *feast.FeatureStore, loggingService *logging.LoggingService) *grpcServingServiceServer <span class="cov8" title="1">{
        return &amp;grpcServingServiceServer{fs: fs, loggingService: loggingService}
}</span>

func (s *grpcServingServiceServer) GetFeastServingInfo(ctx context.Context, request *serving.GetFeastServingInfoRequest) (*serving.GetFeastServingInfoResponse, error) <span class="cov8" title="1">{
        return &amp;serving.GetFeastServingInfoResponse{
                Version: feastServerVersion,
        }, nil
}</span>

// GetOnlineFeatures Returns an object containing the response to GetOnlineFeatures.
// Metadata contains feature names that corresponds to the number of rows in response.Results.
// Results contains values including the value of the feature, the event timestamp, and feature status in a columnar format.
func (s *grpcServingServiceServer) GetOnlineFeatures(ctx context.Context, request *serving.GetOnlineFeaturesRequest) (*serving.GetOnlineFeaturesResponse, error) <span class="cov8" title="1">{

        span, ctx := tracer.StartSpanFromContext(ctx, "getOnlineFeatures", tracer.ResourceName("ServingService/GetOnlineFeatures"))
        defer span.Finish()

        logSpanContext := LogWithSpanContext(span)

        requestId := GenerateRequestId()
        featuresOrService, err := s.fs.ParseFeatures(request.GetKind())

        if err != nil </span><span class="cov0" title="0">{
                logSpanContext.Error().Err(err).Msg("Error parsing feature service or feature list from request")
                return nil, err
        }</span>

        <span class="cov8" title="1">featureVectors, err := s.fs.GetOnlineFeatures(
                ctx,
                featuresOrService.FeaturesRefs,
                featuresOrService.FeatureService,
                request.GetEntities(),
                request.GetRequestContext(),
                request.GetFullFeatureNames())

        if err != nil </span><span class="cov0" title="0">{
                logSpanContext.Error().Err(err).Msg("Error getting online features")
                return nil, err
        }</span>

        <span class="cov8" title="1">resp := &amp;serving.GetOnlineFeaturesResponse{
                Results: make([]*serving.GetOnlineFeaturesResponse_FeatureVector, 0),
                Metadata: &amp;serving.GetOnlineFeaturesResponseMetadata{
                        FeatureNames: &amp;serving.FeatureList{Val: make([]string, 0)},
                },
        }
        // JoinKeys are currently part of the features as a value and the order that we add it to the resp MetaData
        // Need to figure out a way to map the correct entities to the correct ordering
        entityValuesMap := make(map[string][]*prototypes.Value, 0)
        featureNames := make([]string, len(featureVectors))
        for idx, vector := range featureVectors </span><span class="cov8" title="1">{
                resp.Metadata.FeatureNames.Val = append(resp.Metadata.FeatureNames.Val, vector.Name)
                featureNames[idx] = vector.Name
                values, err := types.ArrowValuesToProtoValues(vector.Values)
                if err != nil </span><span class="cov0" title="0">{
                        logSpanContext.Error().Err(err).Msg("Error converting Arrow values to proto values")
                        return nil, err
                }</span>
                <span class="cov8" title="1">if _, ok := request.Entities[vector.Name]; ok </span><span class="cov8" title="1">{
                        entityValuesMap[vector.Name] = values
                }</span>

                <span class="cov8" title="1">resp.Results = append(resp.Results, &amp;serving.GetOnlineFeaturesResponse_FeatureVector{
                        Values:          values,
                        Statuses:        vector.Statuses,
                        EventTimestamps: vector.Timestamps,
                })</span>
        }

        <span class="cov8" title="1">featureService := featuresOrService.FeatureService
        if featureService != nil &amp;&amp; featureService.LoggingConfig != nil &amp;&amp; s.loggingService != nil </span><span class="cov8" title="1">{
                logger, err := s.loggingService.GetOrCreateLogger(featureService)
                if err != nil </span><span class="cov0" title="0">{
                        logSpanContext.Error().Err(err).Msg("Error to instantiating logger for feature service: " + featuresOrService.FeatureService.Name)
                        fmt.Printf("Couldn't instantiate logger for feature service %s: %+v", featuresOrService.FeatureService.Name, err)
                }</span>

                <span class="cov8" title="1">err = logger.Log(request.Entities, resp.Results[len(request.Entities):], resp.Metadata.FeatureNames.Val[len(request.Entities):], request.RequestContext, requestId)
                if err != nil </span><span class="cov0" title="0">{
                        logSpanContext.Error().Err(err).Msg("Error to logging to feature service: " + featuresOrService.FeatureService.Name)
                        fmt.Printf("LoggerImpl error[%s]: %+v", featuresOrService.FeatureService.Name, err)
                }</span>
        }
        <span class="cov8" title="1">return resp, nil</span>
}

func GenerateRequestId() string <span class="cov8" title="1">{
        id := uuid.New()
        return id.String()
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package server

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "os"
        "runtime"
        "strconv"
        "strings"
        "time"

        "github.com/feast-dev/feast/go/internal/feast"
        "github.com/feast-dev/feast/go/internal/feast/model"
        "github.com/feast-dev/feast/go/internal/feast/onlineserving"
        "github.com/feast-dev/feast/go/internal/feast/server/logging"
        "github.com/feast-dev/feast/go/protos/feast/serving"
        prototypes "github.com/feast-dev/feast/go/protos/feast/types"
        "github.com/feast-dev/feast/go/types"
        "github.com/rs/zerolog/log"
        httptrace "gopkg.in/DataDog/dd-trace-go.v1/contrib/net/http"
        "gopkg.in/DataDog/dd-trace-go.v1/ddtrace/tracer"
)

type httpServer struct {
        fs             *feast.FeatureStore
        loggingService *logging.LoggingService
        server         *http.Server
}

// Some Feast types aren't supported during JSON conversion
type repeatedValue struct {
        stringVal     []string
        int32Val      []int32
        int64Val      []int64
        doubleVal     []float64
        boolVal       []bool
        stringListVal [][]string
        int32ListVal  [][]int32
        int64ListVal  [][]int64
        doubleListVal [][]float64
        boolListVal   [][]bool
}

func (u *repeatedValue) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        isString := false
        isDouble := false
        isInt64 := false
        isArray := false
        openBraketCounter := 0
        for _, b := range data </span><span class="cov8" title="1">{
                if b == '"' </span><span class="cov8" title="1">{
                        isString = true
                }</span>
                <span class="cov8" title="1">if b == '.' </span><span class="cov8" title="1">{
                        isDouble = true
                }</span>
                <span class="cov8" title="1">if b &gt;= '0' &amp;&amp; b &lt;= '9' </span><span class="cov8" title="1">{
                        isInt64 = true
                }</span>
                <span class="cov8" title="1">if b == '[' </span><span class="cov8" title="1">{
                        openBraketCounter++
                        if openBraketCounter &gt; 1 </span><span class="cov8" title="1">{
                                isArray = true
                        }</span>
                }
        }
        <span class="cov8" title="1">var err error
        if !isArray </span><span class="cov8" title="1">{
                if isString </span><span class="cov8" title="1">{
                        err = json.Unmarshal(data, &amp;u.stringVal)
                }</span> else<span class="cov8" title="1"> if isDouble </span><span class="cov8" title="1">{
                        err = json.Unmarshal(data, &amp;u.doubleVal)
                }</span> else<span class="cov8" title="1"> if isInt64 </span><span class="cov8" title="1">{
                        err = json.Unmarshal(data, &amp;u.int64Val)
                }</span> else<span class="cov8" title="1"> {
                        err = json.Unmarshal(data, &amp;u.boolVal)
                }</span>
        } else<span class="cov8" title="1"> {
                if isString </span><span class="cov8" title="1">{
                        err = json.Unmarshal(data, &amp;u.stringListVal)
                }</span> else<span class="cov8" title="1"> if isDouble </span><span class="cov8" title="1">{
                        err = json.Unmarshal(data, &amp;u.doubleListVal)
                }</span> else<span class="cov8" title="1"> if isInt64 </span><span class="cov8" title="1">{
                        err = json.Unmarshal(data, &amp;u.int64ListVal)
                }</span> else<span class="cov8" title="1"> {
                        err = json.Unmarshal(data, &amp;u.boolListVal)
                }</span>
        }
        <span class="cov8" title="1">return err</span>
}

func (u *repeatedValue) ToProto() *prototypes.RepeatedValue <span class="cov0" title="0">{
        proto := new(prototypes.RepeatedValue)
        if u.stringVal != nil </span><span class="cov0" title="0">{
                for _, val := range u.stringVal </span><span class="cov0" title="0">{
                        proto.Val = append(proto.Val, &amp;prototypes.Value{Val: &amp;prototypes.Value_StringVal{StringVal: val}})
                }</span>
        }
        <span class="cov0" title="0">if u.int64Val != nil </span><span class="cov0" title="0">{
                for _, val := range u.int64Val </span><span class="cov0" title="0">{
                        proto.Val = append(proto.Val, &amp;prototypes.Value{Val: &amp;prototypes.Value_Int64Val{Int64Val: val}})
                }</span>
        }
        <span class="cov0" title="0">if u.int32Val != nil </span><span class="cov0" title="0">{
                for _, val := range u.int32Val </span><span class="cov0" title="0">{
                        proto.Val = append(proto.Val, &amp;prototypes.Value{Val: &amp;prototypes.Value_Int32Val{Int32Val: val}})
                }</span>
        }
        <span class="cov0" title="0">if u.doubleVal != nil </span><span class="cov0" title="0">{
                for _, val := range u.doubleVal </span><span class="cov0" title="0">{
                        proto.Val = append(proto.Val, &amp;prototypes.Value{Val: &amp;prototypes.Value_DoubleVal{DoubleVal: val}})
                }</span>
        }
        <span class="cov0" title="0">if u.boolVal != nil </span><span class="cov0" title="0">{
                for _, val := range u.boolVal </span><span class="cov0" title="0">{
                        proto.Val = append(proto.Val, &amp;prototypes.Value{Val: &amp;prototypes.Value_BoolVal{BoolVal: val}})
                }</span>
        }
        <span class="cov0" title="0">if u.stringListVal != nil </span><span class="cov0" title="0">{
                for _, val := range u.stringListVal </span><span class="cov0" title="0">{
                        proto.Val = append(proto.Val, &amp;prototypes.Value{Val: &amp;prototypes.Value_StringListVal{StringListVal: &amp;prototypes.StringList{Val: val}}})
                }</span>
        }
        <span class="cov0" title="0">if u.int32ListVal != nil </span><span class="cov0" title="0">{
                for _, val := range u.int32ListVal </span><span class="cov0" title="0">{
                        proto.Val = append(proto.Val, &amp;prototypes.Value{Val: &amp;prototypes.Value_Int32ListVal{Int32ListVal: &amp;prototypes.Int32List{Val: val}}})
                }</span>
        }
        <span class="cov0" title="0">if u.int64ListVal != nil </span><span class="cov0" title="0">{
                for _, val := range u.int64ListVal </span><span class="cov0" title="0">{
                        proto.Val = append(proto.Val, &amp;prototypes.Value{Val: &amp;prototypes.Value_Int64ListVal{Int64ListVal: &amp;prototypes.Int64List{Val: val}}})
                }</span>
        }
        <span class="cov0" title="0">if u.doubleListVal != nil </span><span class="cov0" title="0">{
                for _, val := range u.doubleListVal </span><span class="cov0" title="0">{
                        proto.Val = append(proto.Val, &amp;prototypes.Value{Val: &amp;prototypes.Value_DoubleListVal{DoubleListVal: &amp;prototypes.DoubleList{Val: val}}})
                }</span>
        }
        <span class="cov0" title="0">if u.boolListVal != nil </span><span class="cov0" title="0">{
                for _, val := range u.boolListVal </span><span class="cov0" title="0">{
                        proto.Val = append(proto.Val, &amp;prototypes.Value{Val: &amp;prototypes.Value_BoolListVal{BoolListVal: &amp;prototypes.BoolList{Val: val}}})
                }</span>
        }
        <span class="cov0" title="0">return proto</span>
}

type getOnlineFeaturesRequest struct {
        FeatureService   *string                  `json:"feature_service"`
        Features         []string                 `json:"features"`
        Entities         map[string]repeatedValue `json:"entities"`
        FullFeatureNames bool                     `json:"full_feature_names"`
        RequestContext   map[string]repeatedValue `json:"request_context"`
}

func NewHttpServer(fs *feast.FeatureStore, loggingService *logging.LoggingService) *httpServer <span class="cov8" title="1">{
        return &amp;httpServer{fs: fs, loggingService: loggingService}
}</span>

/*
*
Used to align a field specified in the request with its defined schema type.
*/
func typecastToFieldSchemaType(val *repeatedValue, fieldType prototypes.ValueType_Enum) <span class="cov0" title="0">{
        if val.int64Val != nil </span><span class="cov0" title="0">{
                if fieldType == prototypes.ValueType_INT32 </span><span class="cov0" title="0">{
                        for _, v := range val.int64Val </span><span class="cov0" title="0">{
                                val.int32Val = append(val.int32Val, int32(v))
                        }</span>
                        <span class="cov0" title="0">val.int64Val = nil</span>
                }
        }
}

func (s *httpServer) getOnlineFeatures(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        var err error

        span, ctx := tracer.StartSpanFromContext(r.Context(), "getOnlineFeatures", tracer.ResourceName("/get-online-features"))
        defer span.Finish(tracer.WithError(err))

        logSpanContext := LogWithSpanContext(span)

        if r.Method != "POST" </span><span class="cov0" title="0">{
                http.NotFound(w, r)
                return
        }</span>

        <span class="cov8" title="1">statusQuery := r.URL.Query().Get("status")

        status := false
        if statusQuery != "" </span><span class="cov0" title="0">{
                status, err = strconv.ParseBool(statusQuery)
                if err != nil </span><span class="cov0" title="0">{
                        logSpanContext.Error().Err(err).Msg("Error parsing status query parameter")
                        writeJSONError(w, fmt.Errorf("Error parsing status query parameter: %+v", err), http.StatusBadRequest)
                        return
                }</span>
        }

        <span class="cov8" title="1">decoder := json.NewDecoder(r.Body)
        var request getOnlineFeaturesRequest
        err = decoder.Decode(&amp;request)
        if err != nil </span><span class="cov8" title="1">{
                logSpanContext.Error().Err(err).Msg("Error decoding JSON request data")
                writeJSONError(w, fmt.Errorf("Error decoding JSON request data: %+v", err), http.StatusInternalServerError)
                return
        }</span>
        <span class="cov0" title="0">var featureService *model.FeatureService
        var entitiesProto = make(map[string]*prototypes.RepeatedValue)
        var requestContextProto = make(map[string]*prototypes.RepeatedValue)
        var odfVList = make([]*model.OnDemandFeatureView, 0)
        var requestSources = make(map[string]prototypes.ValueType_Enum)

        if request.FeatureService != nil &amp;&amp; *request.FeatureService != "" </span><span class="cov0" title="0">{
                featureService, err = s.fs.GetFeatureService(*request.FeatureService)
                if err != nil </span><span class="cov0" title="0">{
                        logSpanContext.Error().Err(err).Msg("Error getting feature service from registry")
                        writeJSONError(w, fmt.Errorf("Error getting feature service from registry: %+v", err), http.StatusInternalServerError)
                        return
                }</span>
                <span class="cov0" title="0">for _, fv := range featureService.Projections </span><span class="cov0" title="0">{
                        odfv, _ := s.fs.GetOnDemandFeatureView(fv.Name)
                        if odfv != nil </span><span class="cov0" title="0">{
                                odfVList = append(odfVList, odfv)
                        }</span>
                }
        } else<span class="cov0" title="0"> if len(request.Features) &gt; 0 </span><span class="cov0" title="0">{
                log.Info().Msgf("request.Features %v", request.Features)
                for _, featureName := range request.Features </span><span class="cov0" title="0">{
                        _, _, err := onlineserving.ParseFeatureReference(featureName)
                        if err != nil </span><span class="cov0" title="0">{
                                logSpanContext.Error().Err(err)
                                writeJSONError(w, fmt.Errorf("Error parsing feature reference %s", featureName), http.StatusBadRequest)
                                return
                        }</span>
                        <span class="cov0" title="0">fv, odfv, _ := s.fs.ListAllViews()
                        if _, ok1 := odfv[featureName]; ok1 </span><span class="cov0" title="0">{
                                odfVList = append(odfVList, odfv[featureName])
                        }</span> else<span class="cov0" title="0"> if _, ok1 := fv[featureName]; !ok1 </span><span class="cov0" title="0">{
                                logSpanContext.Error().Msg("Feature View not found")
                                writeJSONError(w, fmt.Errorf("Feature View %s not found", featureName), http.StatusInternalServerError)
                                return
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                logSpanContext.Error().Msg("No Feature Views or Feature Services specified in the request")
                writeJSONError(w, errors.New("No Feature Views or Feature Services specified in the request"), http.StatusBadRequest)
                return
        }</span>
        <span class="cov0" title="0">if odfVList != nil </span><span class="cov0" title="0">{
                requestSources, _ = s.fs.GetRequestSources(odfVList)
        }</span>
        <span class="cov0" title="0">if len(request.Entities) &gt; 0 </span><span class="cov0" title="0">{
                var entityType prototypes.ValueType_Enum
                for key, value := range request.Entities </span><span class="cov0" title="0">{
                        entity, err := s.fs.GetEntity(key, false)
                        if err != nil </span><span class="cov0" title="0">{
                                if requestSources == nil </span><span class="cov0" title="0">{
                                        logSpanContext.Error().Msgf("Entity %s not found ", key)
                                        writeJSONError(w, fmt.Errorf("Entity %s not found ", key), http.StatusNotFound)
                                        return
                                }</span>
                                <span class="cov0" title="0">requestSourceType, ok := requestSources[key]
                                if !ok </span><span class="cov0" title="0">{
                                        logSpanContext.Error().Msgf("Entity nor Request Source of name %s not found ", key)
                                        writeJSONError(w, fmt.Errorf("Entity nor Request Source of name %s not found ", key), http.StatusNotFound)
                                        return
                                }</span>
                                <span class="cov0" title="0">entityType = requestSourceType</span>
                        } else<span class="cov0" title="0"> {
                                entityType = entity.ValueType
                        }</span>
                        <span class="cov0" title="0">typecastToFieldSchemaType(&amp;value, entityType)
                        entitiesProto[key] = value.ToProto()</span>
                }
        }
        <span class="cov0" title="0">if request.RequestContext != nil &amp;&amp; len(request.RequestContext) &gt; 0 </span><span class="cov0" title="0">{
                for key, value := range request.RequestContext </span><span class="cov0" title="0">{
                        requestSourceType, ok := requestSources[key]
                        if !ok </span><span class="cov0" title="0">{
                                logSpanContext.Error().Msgf("Request Source %s not found ", key)
                                writeJSONError(w, fmt.Errorf("Request Source %s not found ", key), http.StatusNotFound)
                                return
                        }</span>
                        <span class="cov0" title="0">typecastToFieldSchemaType(&amp;value, requestSourceType)
                        requestContextProto[key] = value.ToProto()</span>
                }
        }

        <span class="cov0" title="0">featureVectors, err := s.fs.GetOnlineFeatures(
                ctx,
                request.Features,
                featureService,
                entitiesProto,
                requestContextProto,
                request.FullFeatureNames)

        if err != nil </span><span class="cov0" title="0">{
                logSpanContext.Error().Err(err).Msg("Error getting feature vector")
                writeJSONError(w, fmt.Errorf("Error getting feature vector: %+v", err), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">var featureNames []string
        var results []map[string]interface{}
        for _, vector := range featureVectors </span><span class="cov0" title="0">{
                featureNames = append(featureNames, vector.Name)
                result := make(map[string]interface{})
                if status </span><span class="cov0" title="0">{
                        var statuses []string
                        for _, status := range vector.Statuses </span><span class="cov0" title="0">{
                                statuses = append(statuses, status.String())
                        }</span>
                        <span class="cov0" title="0">var timestamps []string
                        for _, timestamp := range vector.Timestamps </span><span class="cov0" title="0">{
                                timestamps = append(timestamps, timestamp.AsTime().Format(time.RFC3339))
                        }</span>

                        <span class="cov0" title="0">result["statuses"] = statuses
                        result["event_timestamps"] = timestamps</span>
                }
                // Note, that vector.Values is an Arrow Array, but this type implements JSON Marshaller.
                // So, it's not necessary to pre-process it in any way.
                <span class="cov0" title="0">result["values"] = vector.Values

                results = append(results, result)</span>
        }

        <span class="cov0" title="0">response := map[string]interface{}{
                "metadata": map[string]interface{}{
                        "feature_names": featureNames,
                },
                "results": results,
        }

        w.Header().Set("Content-Type", "application/json")

        err = json.NewEncoder(w).Encode(response)

        if err != nil </span><span class="cov0" title="0">{
                logSpanContext.Error().Err(err).Msg("Error encoding response")
                writeJSONError(w, fmt.Errorf("Error encoding response: %+v", err), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">if featureService != nil &amp;&amp; featureService.LoggingConfig != nil &amp;&amp; s.loggingService != nil </span><span class="cov0" title="0">{
                logger, err := s.loggingService.GetOrCreateLogger(featureService)
                if err != nil </span><span class="cov0" title="0">{
                        logSpanContext.Error().Err(err).Msgf("Couldn't instantiate logger for feature service %s", featureService.Name)
                        writeJSONError(w, fmt.Errorf("Couldn't instantiate logger for feature service %s: %+v", featureService.Name, err), http.StatusInternalServerError)
                        return
                }</span>

                <span class="cov0" title="0">requestId := GenerateRequestId()

                // Note: we're converting arrow to proto for feature logging. In the future we should
                // base feature logging on arrow so that we don't have to do this extra conversion.
                var featureVectorProtos []*serving.GetOnlineFeaturesResponse_FeatureVector
                for _, vector := range featureVectors[len(request.Entities):] </span><span class="cov0" title="0">{
                        values, err := types.ArrowValuesToProtoValues(vector.Values)
                        if err != nil </span><span class="cov0" title="0">{
                                logSpanContext.Error().Err(err).Msg("Couldn't convert arrow values into protobuf")
                                writeJSONError(w, fmt.Errorf("Couldn't convert arrow values into protobuf: %+v", err), http.StatusInternalServerError)
                                return
                        }</span>
                        <span class="cov0" title="0">featureVectorProtos = append(featureVectorProtos, &amp;serving.GetOnlineFeaturesResponse_FeatureVector{
                                Values:          values,
                                Statuses:        vector.Statuses,
                                EventTimestamps: vector.Timestamps,
                        })</span>
                }

                <span class="cov0" title="0">err = logger.Log(entitiesProto, featureVectorProtos, featureNames[len(request.Entities):], requestContextProto, requestId)
                if err != nil </span><span class="cov0" title="0">{
                        writeJSONError(w, fmt.Errorf("LoggerImpl error[%s]: %+v", featureService.Name, err), http.StatusInternalServerError)
                        return
                }</span>
        }

        <span class="cov0" title="0">go releaseCGOMemory(featureVectors)</span>
}

func releaseCGOMemory(featureVectors []*onlineserving.FeatureVector) <span class="cov0" title="0">{
        for _, vector := range featureVectors </span><span class="cov0" title="0">{
                vector.Values.Release()
        }</span>
}

func logStackTrace() <span class="cov0" title="0">{
        // Start with a small buffer and grow it until the full stack trace fits.
        buf := make([]byte, 1024)
        for </span><span class="cov0" title="0">{
                stackSize := runtime.Stack(buf, false)
                if stackSize &lt; len(buf) </span><span class="cov0" title="0">{
                        // The stack trace fits in the buffer, so we can log it now.
                        log.Error().Str("stack_trace", string(buf[:stackSize])).Msg("")
                        return
                }</span>
                // The stack trace doesn't fit in the buffer, so we need to grow the buffer and try again.
                <span class="cov0" title="0">buf = make([]byte, 2*len(buf))</span>
        }
}

func writeJSONError(w http.ResponseWriter, err error, statusCode int) <span class="cov8" title="1">{
        errMap := map[string]interface{}{
                "error":       fmt.Sprintf("%+v", err),
                "status_code": statusCode,
        }
        errJSON, _ := json.Marshal(errMap)

        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(statusCode)
        w.Write(errJSON)
}</span>

func recoverMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                log.Error().Err(fmt.Errorf("Panic recovered: %v", r)).Msg("A panic occurred in the server")
                                // Log the stack trace
                                logStackTrace()

                                writeJSONError(w, fmt.Errorf("Internal Server Error: %v", r), http.StatusInternalServerError)
                        }</span>
                }()
                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}

func (s *httpServer) Serve(host string, port int) error <span class="cov0" title="0">{
        if strings.ToLower(os.Getenv("ENABLE_DATADOG_TRACING")) == "true" </span><span class="cov0" title="0">{
                tracer.Start(tracer.WithRuntimeMetrics())
                defer tracer.Stop()
        }</span>
        <span class="cov0" title="0">mux := httptrace.NewServeMux()
        mux.Handle("/get-online-features", recoverMiddleware(http.HandlerFunc(s.getOnlineFeatures)))
        mux.HandleFunc("/health", healthCheckHandler)
        s.server = &amp;http.Server{Addr: fmt.Sprintf("%s:%d", host, port), Handler: mux, ReadTimeout: 5 * time.Second, WriteTimeout: 10 * time.Second, IdleTimeout: 15 * time.Second}
        err := s.server.ListenAndServe()
        // Don't return the error if it's caused by graceful shutdown using Stop()
        if err == http.ErrServerClosed </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">log.Fatal().Stack().Err(err).Msg("Failed to start HTTP server")
        return err</span>
}

func healthCheckHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        w.WriteHeader(http.StatusOK)
        fmt.Fprintf(w, "Healthy")
}</span>
func (s *httpServer) Stop() error <span class="cov0" title="0">{
        if s.server != nil </span><span class="cov0" title="0">{
                return s.server.Shutdown(context.Background())
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package logging

import (
        "fmt"

        "github.com/feast-dev/feast/go/internal/feast/model"
        "github.com/feast-dev/feast/go/protos/feast/types"
)

type FeatureServiceSchema struct {
        JoinKeys    []string
        Features    []string
        RequestData []string

        JoinKeysTypes    map[string]types.ValueType_Enum
        FeaturesTypes    map[string]types.ValueType_Enum
        RequestDataTypes map[string]types.ValueType_Enum
}

func GenerateSchemaFromFeatureService(fs FeatureStore, featureServiceName string) (*FeatureServiceSchema, error) <span class="cov0" title="0">{
        entityMap, fvMap, odFvMap, err := fs.GetFcosMap()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">featureService, err := fs.GetFeatureService(featureServiceName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return generateSchema(featureService, entityMap, fvMap, odFvMap)</span>
}

func generateSchema(featureService *model.FeatureService, entityMap map[string]*model.Entity, fvMap map[string]*model.FeatureView, odFvMap map[string]*model.OnDemandFeatureView) (*FeatureServiceSchema, error) <span class="cov8" title="1">{
        joinKeys := make([]string, 0)
        features := make([]string, 0)
        requestData := make([]string, 0)

        joinKeysSet := make(map[string]interface{})

        entityJoinKeyToType := make(map[string]types.ValueType_Enum)
        allFeatureTypes := make(map[string]types.ValueType_Enum)
        requestDataTypes := make(map[string]types.ValueType_Enum)

        for _, featureProjection := range featureService.Projections </span><span class="cov8" title="1">{
                // Create copies of FeatureView that may contains the same *FeatureView but
                // each differentiated by a *FeatureViewProjection
                featureViewName := featureProjection.Name
                if fv, ok := fvMap[featureViewName]; ok </span><span class="cov8" title="1">{
                        for _, f := range featureProjection.Features </span><span class="cov8" title="1">{
                                fullFeatureName := getFullFeatureName(featureProjection.NameToUse(), f.Name)
                                features = append(features, fullFeatureName)
                                allFeatureTypes[fullFeatureName] = f.Dtype
                        }</span>
                        <span class="cov8" title="1">for _, entityColumn := range fv.EntityColumns </span><span class="cov8" title="1">{
                                var joinKey string
                                if joinKeyAlias, ok := featureProjection.JoinKeyMap[entityColumn.Name]; ok </span><span class="cov0" title="0">{
                                        joinKey = joinKeyAlias
                                }</span> else<span class="cov8" title="1"> {
                                        joinKey = entityColumn.Name
                                }</span>

                                <span class="cov8" title="1">if _, ok := joinKeysSet[joinKey]; !ok </span><span class="cov8" title="1">{
                                        joinKeys = append(joinKeys, joinKey)
                                }</span>

                                <span class="cov8" title="1">joinKeysSet[joinKey] = nil
                                entityJoinKeyToType[joinKey] = entityColumn.Dtype</span>
                        }
                } else<span class="cov8" title="1"> if odFv, ok := odFvMap[featureViewName]; ok </span><span class="cov8" title="1">{
                        for _, f := range featureProjection.Features </span><span class="cov8" title="1">{
                                fullFeatureName := getFullFeatureName(featureProjection.NameToUse(), f.Name)
                                features = append(features, fullFeatureName)
                                allFeatureTypes[fullFeatureName] = f.Dtype
                        }</span>
                        <span class="cov8" title="1">for paramName, paramType := range odFv.GetRequestDataSchema() </span><span class="cov8" title="1">{
                                requestData = append(requestData, paramName)
                                requestDataTypes[paramName] = paramType
                        }</span>
                } else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("no such feature view %s found (referenced from feature service %s)",
                                featureViewName, featureService.Name)
                }</span>
        }

        <span class="cov8" title="1">schema := &amp;FeatureServiceSchema{
                JoinKeys:    joinKeys,
                Features:    features,
                RequestData: requestData,

                JoinKeysTypes:    entityJoinKeyToType,
                FeaturesTypes:    allFeatureTypes,
                RequestDataTypes: requestDataTypes,
        }
        return schema, nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package logging

import (
        "fmt"
        "io"
        "os"
        "path/filepath"

        "github.com/pkg/errors"

        "github.com/apache/arrow/go/v8/arrow"
        "github.com/google/uuid"

        "github.com/apache/arrow/go/v8/arrow/array"
        "github.com/apache/arrow/go/v8/parquet"
        "github.com/apache/arrow/go/v8/parquet/pqarrow"
)

type FileLogSink struct {
        path string
}

// FileLogSink is currently only used for testing. It will be instantiated during go unit tests to log to file
// and the parquet files will be cleaned up after the test is run.
func NewFileLogSink(path string) (*FileLogSink, error) <span class="cov8" title="1">{
        if path == "" </span><span class="cov0" title="0">{
                return nil, errors.New("need path for file log sink")
        }</span>

        <span class="cov8" title="1">absPath, err := filepath.Abs(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;FileLogSink{path: absPath}, nil</span>
}

func (s *FileLogSink) Write(records []arrow.Record) error <span class="cov8" title="1">{
        fileName, _ := uuid.NewUUID()

        var writer io.Writer
        writer, err := os.Create(filepath.Join(s.path, fmt.Sprintf("%s.parquet", fileName.String())))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">table := array.NewTableFromRecords(records[0].Schema(), records)

        props := parquet.NewWriterProperties(parquet.WithDictionaryDefault(false))
        arrProps := pqarrow.DefaultWriterProps()
        return pqarrow.WriteTable(table, writer, 100, props, arrProps)</span>
}

func (s *FileLogSink) Flush(featureServiceName string) error <span class="cov0" title="0">{
        // files are already flushed during Write
        return nil
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package logging

import (
        "fmt"
        "log"
        "math/rand"
        "strings"
        "sync"
        "time"

        "github.com/apache/arrow/go/v8/arrow"
        "github.com/pkg/errors"
        "google.golang.org/protobuf/types/known/timestamppb"

        "github.com/feast-dev/feast/go/protos/feast/serving"
        "github.com/feast-dev/feast/go/protos/feast/types"
)

type Log struct {
        // Example: val{int64_val: 5017}, val{int64_val: 1003}
        EntityValue []*types.Value
        RequestData []*types.Value

        FeatureValues   []*types.Value
        FeatureStatuses []serving.FieldStatus
        EventTimestamps []*timestamppb.Timestamp

        RequestId    string
        LogTimestamp time.Time
}

type LogSink interface {
        // Write is used to unload logs from memory buffer.
        // Logs are not guaranteed to be flushed to sink on this point.
        // The data can just be written to local disk (depending on implementation).
        Write(data []arrow.Record) error

        // Flush actually send data to a sink.
        // We want to control amount to interaction with sink, since it could be a costly operation.
        // Also, some sinks like BigQuery might have quotes and physically limit amount of write requests per day.
        Flush(featureServiceName string) error
}

type Logger interface {
        Log(joinKeyToEntityValues map[string]*types.RepeatedValue, featureVectors []*serving.GetOnlineFeaturesResponse_FeatureVector, featureNames []string, requestData map[string]*types.RepeatedValue, requestId string) error
}

type LoggerImpl struct {
        featureServiceName string

        buffer *MemoryBuffer
        schema *FeatureServiceSchema

        logCh    chan *Log
        signalCh chan interface{}

        sink   LogSink
        config LoggerConfig

        isStopped bool
        cond      *sync.Cond
}

type LoggerConfig struct {
        LoggingOptions

        SampleRate float32
}

func NewLoggerConfig(sampleRate float32, opts LoggingOptions) LoggerConfig <span class="cov0" title="0">{
        return LoggerConfig{
                LoggingOptions: opts,
                SampleRate:     sampleRate,
        }
}</span>

func NewLogger(schema *FeatureServiceSchema, featureServiceName string, sink LogSink, config LoggerConfig) (*LoggerImpl, error) <span class="cov8" title="1">{
        buffer, err := NewMemoryBuffer(schema)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">logger := &amp;LoggerImpl{
                featureServiceName: featureServiceName,

                logCh:    make(chan *Log, config.ChannelCapacity),
                signalCh: make(chan interface{}, 2),
                sink:     sink,

                buffer: buffer,
                schema: schema,
                config: config,

                isStopped: false,
                cond:      sync.NewCond(&amp;sync.Mutex{}),
        }

        logger.startLoggerLoop()
        return logger, nil</span>
}

func (l *LoggerImpl) EmitLog(log *Log) error <span class="cov8" title="1">{
        select </span>{
        case l.logCh &lt;- log:<span class="cov8" title="1">
                return nil</span>
        case &lt;-time.After(l.config.EmitTimeout):<span class="cov8" title="1">
                return fmt.Errorf("could not add to log channel with capacity %d. Operation timed out. Current log channel length is %d", cap(l.logCh), len(l.logCh))</span>
        }
}

func (l *LoggerImpl) startLoggerLoop() <span class="cov8" title="1">{
        go func() </span><span class="cov8" title="1">{
                for </span><span class="cov8" title="1">{
                        if err := l.loggerLoop(); err != nil </span><span class="cov0" title="0">{
                                log.Printf("LoggerImpl[%s] recovered from panic: %+v", l.featureServiceName, err)

                                // Sleep for a couple of milliseconds to avoid CPU load from a potential infinite panic-recovery loop
                                time.Sleep(5 * time.Millisecond)
                                continue</span> // try again
                        }

                        // graceful stop
                        <span class="cov8" title="1">return</span>
                }
        }()
}

// Select that either ingests new logs that are added to the logging channel, one at a time to add
// to the in-memory buffer or flushes all of them synchronously to the OfflineStorage on a time interval.
func (l *LoggerImpl) loggerLoop() (lErr error) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                // Recover from panic in the logger loop, so that it doesn't bring down the entire feature server
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        rErr, ok := r.(error)
                        if !ok </span><span class="cov0" title="0">{
                                rErr = fmt.Errorf("%v", r)
                        }</span>
                        <span class="cov0" title="0">lErr = errors.WithStack(rErr)</span>
                }
        }()

        <span class="cov8" title="1">writeTicker := time.NewTicker(l.config.WriteInterval)
        flushTicker := time.NewTicker(l.config.FlushInterval)

        for </span><span class="cov8" title="1">{
                shouldStop := false

                select </span>{
                case &lt;-l.signalCh:<span class="cov8" title="1">
                        err := l.buffer.writeBatch(l.sink)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Log write failed: %+v", err)
                        }</span>
                        <span class="cov8" title="1">err = l.sink.Flush(l.featureServiceName)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Log flush failed: %+v", err)
                        }</span>
                        <span class="cov8" title="1">shouldStop = true</span>
                case &lt;-writeTicker.C:<span class="cov8" title="1">
                        err := l.buffer.writeBatch(l.sink)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Log write failed: %+v", err)
                        }</span>
                case &lt;-flushTicker.C:<span class="cov0" title="0">
                        err := l.sink.Flush(l.featureServiceName)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Log flush failed: %+v", err)
                        }</span>
                case logItem := &lt;-l.logCh:<span class="cov8" title="1">
                        err := l.buffer.Append(logItem)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Printf("Append log failed: %+v", err)
                        }</span>
                }

                <span class="cov8" title="1">if shouldStop </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">writeTicker.Stop()
        flushTicker.Stop()

        // Notify all waiters for graceful stop
        l.cond.L.Lock()
        l.isStopped = true
        l.cond.Broadcast()
        l.cond.L.Unlock()
        return nil</span>
}

// Stop the loop goroutine gracefully
func (l *LoggerImpl) Stop() <span class="cov8" title="1">{
        select </span>{
        case l.signalCh &lt;- nil:<span class="cov8" title="1"></span>
        default:<span class="cov0" title="0"></span>
        }
}

func (l *LoggerImpl) WaitUntilStopped() <span class="cov8" title="1">{
        l.cond.L.Lock()
        defer l.cond.L.Unlock()
        for !l.isStopped </span><span class="cov8" title="1">{
                l.cond.Wait()
        }</span>
}

func getFullFeatureName(featureViewName string, featureName string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%s__%s", featureViewName, featureName)
}</span>

func (l *LoggerImpl) Log(joinKeyToEntityValues map[string]*types.RepeatedValue, featureVectors []*serving.GetOnlineFeaturesResponse_FeatureVector, featureNames []string, requestData map[string]*types.RepeatedValue, requestId string) error <span class="cov8" title="1">{
        if len(featureVectors) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">if rand.Float32() &gt; l.config.SampleRate </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">numFeatures := len(l.schema.Features)
        // Should be equivalent to how many entities there are(each feature row has (entity) number of features)
        numRows := len(featureVectors[0].Values)

        featureNameToVectorIdx := make(map[string]int)
        for idx, name := range featureNames </span><span class="cov8" title="1">{
                featureNameToVectorIdx[name] = idx
        }</span>

        <span class="cov8" title="1">for rowIdx := 0; rowIdx &lt; numRows; rowIdx++ </span><span class="cov8" title="1">{
                featureValues := make([]*types.Value, numFeatures)
                featureStatuses := make([]serving.FieldStatus, numFeatures)
                eventTimestamps := make([]*timestamppb.Timestamp, numFeatures)

                for idx, featureName := range l.schema.Features </span><span class="cov8" title="1">{
                        featureIdx, ok := featureNameToVectorIdx[featureName]
                        if !ok </span><span class="cov0" title="0">{
                                featureNameParts := strings.Split(featureName, "__")
                                featureIdx, ok = featureNameToVectorIdx[featureNameParts[1]]
                                if !ok </span><span class="cov0" title="0">{
                                        return errors.Errorf("Missing feature %s in log data", featureName)
                                }</span>
                        }
                        <span class="cov8" title="1">featureValues[idx] = featureVectors[featureIdx].Values[rowIdx]
                        featureStatuses[idx] = featureVectors[featureIdx].Statuses[rowIdx]
                        eventTimestamps[idx] = featureVectors[featureIdx].EventTimestamps[rowIdx]</span>
                }

                <span class="cov8" title="1">entityValues := make([]*types.Value, len(l.schema.JoinKeys))
                for idx, joinKey := range l.schema.JoinKeys </span><span class="cov8" title="1">{
                        rows, ok := joinKeyToEntityValues[joinKey]
                        if !ok </span><span class="cov0" title="0">{
                                return errors.Errorf("Missing join key %s in log data", joinKey)
                        }</span>
                        <span class="cov8" title="1">entityValues[idx] = rows.Val[rowIdx]</span>
                }

                <span class="cov8" title="1">requestDataValues := make([]*types.Value, len(l.schema.RequestData))
                for idx, requestParam := range l.schema.RequestData </span><span class="cov0" title="0">{
                        rows, ok := requestData[requestParam]
                        if !ok </span><span class="cov0" title="0">{
                                return errors.Errorf("Missing request parameter %s in log data", requestParam)
                        }</span>
                        <span class="cov0" title="0">requestDataValues[idx] = rows.Val[rowIdx]</span>
                }

                <span class="cov8" title="1">newLog := Log{
                        EntityValue: entityValues,
                        RequestData: requestDataValues,

                        FeatureValues:   featureValues,
                        FeatureStatuses: featureStatuses,
                        EventTimestamps: eventTimestamps,

                        RequestId:    requestId,
                        LogTimestamp: time.Now().UTC(),
                }
                err := l.EmitLog(&amp;newLog)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

type DummyLoggerImpl struct{}

func (l *DummyLoggerImpl) Log(joinKeyToEntityValues map[string]*types.RepeatedValue, featureVectors []*serving.GetOnlineFeaturesResponse_FeatureVector, featureNames []string, requestData map[string]*types.RepeatedValue, requestId string) error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package logging

import (
        "fmt"

        "github.com/apache/arrow/go/v8/arrow"
        "github.com/apache/arrow/go/v8/arrow/array"
        "github.com/apache/arrow/go/v8/arrow/memory"

        "github.com/feast-dev/feast/go/protos/feast/types"
        gotypes "github.com/feast-dev/feast/go/types"
)

type MemoryBuffer struct {
        logs   []*Log
        schema *FeatureServiceSchema

        arrowSchema *arrow.Schema
        records     []arrow.Record
}

const (
        LOG_TIMESTAMP_FIELD  = "__log_timestamp"
        LOG_DATE_FIELD       = "__log_date"
        LOG_REQUEST_ID_FIELD = "__request_id"
        RECORD_SIZE          = 1000
)

func NewMemoryBuffer(schema *FeatureServiceSchema) (*MemoryBuffer, error) <span class="cov8" title="1">{
        arrowSchema, err := getArrowSchema(schema)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;MemoryBuffer{
                logs:        make([]*Log, 0),
                records:     make([]arrow.Record, 0),
                schema:      schema,
                arrowSchema: arrowSchema,
        }, nil</span>
}

// Acquires the logging schema from the feature service, converts the memory buffer array of rows of logs and flushes
// them to the offline storage.
func (b *MemoryBuffer) writeBatch(sink LogSink) error <span class="cov8" title="1">{
        if len(b.logs) &gt; 0 </span><span class="cov8" title="1">{
                err := b.Compact()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">if len(b.records) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">err := sink.Write(b.records)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">b.records = b.records[:0]
        return nil</span>
}

func (b *MemoryBuffer) Append(log *Log) error <span class="cov8" title="1">{
        b.logs = append(b.logs, log)

        if len(b.logs) == RECORD_SIZE </span><span class="cov0" title="0">{
                return b.Compact()
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (b *MemoryBuffer) Compact() error <span class="cov8" title="1">{
        rec, err := b.convertToArrowRecord()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">b.records = append(b.records, rec)
        b.logs = b.logs[:0]
        return nil</span>
}

func getArrowSchema(schema *FeatureServiceSchema) (*arrow.Schema, error) <span class="cov8" title="1">{
        fields := make([]arrow.Field, 0)

        for _, joinKey := range schema.JoinKeys </span><span class="cov8" title="1">{
                arrowType, err := gotypes.ValueTypeEnumToArrowType(schema.JoinKeysTypes[joinKey])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">fields = append(fields, arrow.Field{Name: joinKey, Type: arrowType})</span>
        }

        <span class="cov8" title="1">for _, requestParam := range schema.RequestData </span><span class="cov0" title="0">{
                arrowType, err := gotypes.ValueTypeEnumToArrowType(schema.RequestDataTypes[requestParam])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">fields = append(fields, arrow.Field{Name: requestParam, Type: arrowType})</span>
        }

        <span class="cov8" title="1">for _, featureName := range schema.Features </span><span class="cov8" title="1">{
                arrowType, err := gotypes.ValueTypeEnumToArrowType(schema.FeaturesTypes[featureName])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">fields = append(fields, arrow.Field{Name: featureName, Type: arrowType})
                fields = append(fields, arrow.Field{
                        Name: fmt.Sprintf("%s__timestamp", featureName),
                        Type: arrow.FixedWidthTypes.Timestamp_s})
                fields = append(fields, arrow.Field{
                        Name: fmt.Sprintf("%s__status", featureName),
                        Type: arrow.PrimitiveTypes.Int32})</span>
        }

        <span class="cov8" title="1">fields = append(fields, arrow.Field{Name: LOG_TIMESTAMP_FIELD, Type: arrow.FixedWidthTypes.Timestamp_us})
        fields = append(fields, arrow.Field{Name: LOG_DATE_FIELD, Type: arrow.FixedWidthTypes.Date32})
        fields = append(fields, arrow.Field{Name: LOG_REQUEST_ID_FIELD, Type: arrow.BinaryTypes.String})

        return arrow.NewSchema(fields, nil), nil</span>
}

// convertToArrowRecord Takes memory buffer of logs in array row and converts them to columnar with generated fcoschema generated by GetFcoSchema
// and writes them to arrow table.
// Returns arrow table that contains all of the logs in columnar format.
func (b *MemoryBuffer) convertToArrowRecord() (arrow.Record, error) <span class="cov8" title="1">{
        arrowMemory := memory.NewGoAllocator()
        numRows := len(b.logs)

        columns := make(map[string][]*types.Value)
        fieldNameToIdx := make(map[string]int)
        for idx, field := range b.arrowSchema.Fields() </span><span class="cov8" title="1">{
                fieldNameToIdx[field.Name] = idx
        }</span>

        <span class="cov8" title="1">builder := array.NewRecordBuilder(arrowMemory, b.arrowSchema)
        defer builder.Release()

        builder.Reserve(numRows)

        for rowIdx, logRow := range b.logs </span><span class="cov8" title="1">{
                for colIdx, joinKey := range b.schema.JoinKeys </span><span class="cov8" title="1">{
                        if _, ok := columns[joinKey]; !ok </span><span class="cov8" title="1">{
                                columns[joinKey] = make([]*types.Value, numRows)
                        }</span>
                        <span class="cov8" title="1">columns[joinKey][rowIdx] = logRow.EntityValue[colIdx]</span>
                }
                <span class="cov8" title="1">for colIdx, requestParam := range b.schema.RequestData </span><span class="cov0" title="0">{
                        if _, ok := columns[requestParam]; !ok </span><span class="cov0" title="0">{
                                columns[requestParam] = make([]*types.Value, numRows)
                        }</span>
                        <span class="cov0" title="0">columns[requestParam][rowIdx] = logRow.RequestData[colIdx]</span>
                }
                <span class="cov8" title="1">for colIdx, featureName := range b.schema.Features </span><span class="cov8" title="1">{
                        if _, ok := columns[featureName]; !ok </span><span class="cov8" title="1">{
                                columns[featureName] = make([]*types.Value, numRows)
                        }</span>
                        <span class="cov8" title="1">columns[featureName][rowIdx] = logRow.FeatureValues[colIdx]

                        timestamp := arrow.Timestamp(logRow.EventTimestamps[colIdx].GetSeconds())
                        timestampFieldIdx := fieldNameToIdx[fmt.Sprintf("%s__timestamp", featureName)]
                        statusFieldIdx := fieldNameToIdx[fmt.Sprintf("%s__status", featureName)]

                        builder.Field(timestampFieldIdx).(*array.TimestampBuilder).UnsafeAppend(timestamp)
                        builder.Field(statusFieldIdx).(*array.Int32Builder).UnsafeAppend(int32(logRow.FeatureStatuses[colIdx]))</span>
                }

                <span class="cov8" title="1">logTimestamp := arrow.Timestamp(logRow.LogTimestamp.UnixMicro())
                logDate := arrow.Date32FromTime(logRow.LogTimestamp)

                builder.Field(fieldNameToIdx[LOG_TIMESTAMP_FIELD]).(*array.TimestampBuilder).UnsafeAppend(logTimestamp)
                builder.Field(fieldNameToIdx[LOG_DATE_FIELD]).(*array.Date32Builder).UnsafeAppend(logDate)
                builder.Field(fieldNameToIdx[LOG_REQUEST_ID_FIELD]).(*array.StringBuilder).Append(logRow.RequestId)</span>
        }

        <span class="cov8" title="1">for columnName, protoArray := range columns </span><span class="cov8" title="1">{
                fieldIdx := fieldNameToIdx[columnName]
                err := gotypes.CopyProtoValuesToArrowArray(builder.Field(fieldIdx), protoArray)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">return builder.NewRecord(), nil</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package logging

import (
        "fmt"
        "io"
        "io/ioutil"
        "log"
        "os"
        "path/filepath"

        "github.com/apache/arrow/go/v8/arrow"
        "github.com/apache/arrow/go/v8/arrow/array"
        "github.com/apache/arrow/go/v8/parquet"
        "github.com/apache/arrow/go/v8/parquet/pqarrow"
        "github.com/google/uuid"
)

type OfflineStoreWriteCallback func(featureServiceName, datasetDir string) string

type OfflineStoreSink struct {
        datasetDir    string
        writeCallback OfflineStoreWriteCallback
}

func NewOfflineStoreSink(writeCallback OfflineStoreWriteCallback) (*OfflineStoreSink, error) <span class="cov0" title="0">{
        return &amp;OfflineStoreSink{
                datasetDir:    "",
                writeCallback: writeCallback,
        }, nil
}</span>

func (s *OfflineStoreSink) getOrCreateDatasetDir() (string, error) <span class="cov0" title="0">{
        if s.datasetDir != "" </span><span class="cov0" title="0">{
                return s.datasetDir, nil
        }</span>
        <span class="cov0" title="0">dir, err := ioutil.TempDir("", "*")
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">s.datasetDir = dir
        return s.datasetDir, nil</span>
}

func (s *OfflineStoreSink) Write(records []arrow.Record) error <span class="cov0" title="0">{
        fileName, _ := uuid.NewUUID()
        datasetDir, err := s.getOrCreateDatasetDir()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var writer io.Writer
        writer, err = os.Create(filepath.Join(datasetDir, fmt.Sprintf("%s.parquet", fileName.String())))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">table := array.NewTableFromRecords(records[0].Schema(), records)

        props := parquet.NewWriterProperties(parquet.WithDictionaryDefault(false))
        arrProps := pqarrow.DefaultWriterProps()
        return pqarrow.WriteTable(table, writer, 1000, props, arrProps)</span>
}

func (s *OfflineStoreSink) Flush(featureServiceName string) error <span class="cov0" title="0">{
        if s.datasetDir == "" </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">datasetDir := s.datasetDir
        s.datasetDir = ""

        go func() </span><span class="cov0" title="0">{
                errMsg := s.writeCallback(featureServiceName, datasetDir)
                if errMsg != "" </span><span class="cov0" title="0">{
                        log.Println(errMsg)
                }</span>
                <span class="cov0" title="0">os.RemoveAll(datasetDir)</span>
        }()

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package logging

import (
        "sync"
        "time"

        "github.com/pkg/errors"

        "github.com/feast-dev/feast/go/internal/feast/model"
)

type FeatureStore interface {
        GetFcosMap() (map[string]*model.Entity, map[string]*model.FeatureView, map[string]*model.OnDemandFeatureView, error)
        GetFeatureService(name string) (*model.FeatureService, error)
}

type LoggingOptions struct {
        // How many log items can be buffered in channel
        ChannelCapacity int

        // Waiting time when inserting new log into the channel
        EmitTimeout time.Duration

        // Interval on which logs buffered in memory will be written to sink
        WriteInterval time.Duration

        // Interval on which sink will be flushed
        // (see LogSink interface for better explanation on differences with Write)
        FlushInterval time.Duration
}

type LoggingService struct {
        // feature service name -&gt; LoggerImpl
        loggers map[string]*LoggerImpl

        fs   FeatureStore
        sink LogSink
        opts LoggingOptions

        creationLock *sync.Mutex
}

var (
        DefaultOptions = LoggingOptions{
                ChannelCapacity: 100000,
                FlushInterval:   10 * time.Minute,
                WriteInterval:   10 * time.Second,
                EmitTimeout:     10 * time.Millisecond,
        }
)

func NewLoggingService(fs FeatureStore, sink LogSink, opts ...LoggingOptions) (*LoggingService, error) <span class="cov0" title="0">{
        if len(opts) == 0 </span><span class="cov0" title="0">{
                opts = append(opts, DefaultOptions)
        }</span>

        <span class="cov0" title="0">return &amp;LoggingService{
                fs:           fs,
                loggers:      make(map[string]*LoggerImpl),
                sink:         sink,
                opts:         opts[0],
                creationLock: &amp;sync.Mutex{},
        }, nil</span>
}

func (s *LoggingService) GetOrCreateLogger(featureService *model.FeatureService) (Logger, error) <span class="cov0" title="0">{
        if logger, ok := s.loggers[featureService.Name]; ok </span><span class="cov0" title="0">{
                return logger, nil
        }</span>

        <span class="cov0" title="0">if featureService.LoggingConfig == nil </span><span class="cov0" title="0">{
                return nil, errors.New("Only feature services with configured logging can be used")
        }</span>

        <span class="cov0" title="0">s.creationLock.Lock()
        defer s.creationLock.Unlock()

        // could be created by another go-routine on this point
        if logger, ok := s.loggers[featureService.Name]; ok </span><span class="cov0" title="0">{
                return logger, nil
        }</span>

        <span class="cov0" title="0">if s.sink == nil </span><span class="cov0" title="0">{
                return &amp;DummyLoggerImpl{}, nil
        }</span>

        <span class="cov0" title="0">config := NewLoggerConfig(featureService.LoggingConfig.SampleRate, s.opts)
        schema, err := GenerateSchemaFromFeatureService(s.fs, featureService.Name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">logger, err := NewLogger(schema, featureService.Name, s.sink, config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">s.loggers[featureService.Name] = logger

        return logger, nil</span>
}

func (s *LoggingService) Stop() <span class="cov0" title="0">{
        for _, logger := range s.loggers </span><span class="cov0" title="0">{
                logger.Stop()
                logger.WaitUntilStopped()
        }</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package server

import (
        "github.com/rs/zerolog"
        "gopkg.in/DataDog/dd-trace-go.v1/ddtrace/tracer"
        "os"
)

func LogWithSpanContext(span tracer.Span) zerolog.Logger <span class="cov8" title="1">{
        spanContext := span.Context()

        var logger = zerolog.New(os.Stderr).With().
                Int64("trace_id", int64(spanContext.TraceID())).
                Int64("span_id", int64(spanContext.SpanID())).
                Timestamp().
                Logger()

        return logger
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package main

import (
        "flag"
        "fmt"
        "net"
        "os"
        "os/signal"
        "strings"
        "syscall"

        "github.com/feast-dev/feast/go/internal/feast"
        "github.com/feast-dev/feast/go/internal/feast/registry"
        "github.com/feast-dev/feast/go/internal/feast/server"
        "github.com/feast-dev/feast/go/internal/feast/server/logging"
        "github.com/feast-dev/feast/go/protos/feast/serving"
        "github.com/rs/zerolog/log"
        "google.golang.org/grpc"
        "google.golang.org/grpc/health"
        "google.golang.org/grpc/health/grpc_health_v1"

        grpctrace "gopkg.in/DataDog/dd-trace-go.v1/contrib/google.golang.org/grpc"
        "gopkg.in/DataDog/dd-trace-go.v1/ddtrace/tracer"
)

type ServerStarter interface {
        StartHttpServer(fs *feast.FeatureStore, host string, port int, writeLoggedFeaturesCallback logging.OfflineStoreWriteCallback, loggingOpts *logging.LoggingOptions) error
        StartGrpcServer(fs *feast.FeatureStore, host string, port int, writeLoggedFeaturesCallback logging.OfflineStoreWriteCallback, loggingOpts *logging.LoggingOptions) error
}

type RealServerStarter struct{}

func (s *RealServerStarter) StartHttpServer(fs *feast.FeatureStore, host string, port int, writeLoggedFeaturesCallback logging.OfflineStoreWriteCallback, loggingOpts *logging.LoggingOptions) error <span class="cov0" title="0">{
        return StartHttpServer(fs, host, port, writeLoggedFeaturesCallback, loggingOpts)
}</span>

func (s *RealServerStarter) StartGrpcServer(fs *feast.FeatureStore, host string, port int, writeLoggedFeaturesCallback logging.OfflineStoreWriteCallback, loggingOpts *logging.LoggingOptions) error <span class="cov0" title="0">{
        return StartGrpcServer(fs, host, port, writeLoggedFeaturesCallback, loggingOpts)
}</span>

func main() <span class="cov0" title="0">{
        // Default values
        serverType := "http"
        host := ""
        port := 8080
        server := RealServerStarter{}
        // Current Directory
        repoPath, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                log.Error().Stack().Err(err).Msg("Failed to get current directory")
        }</span>

        <span class="cov0" title="0">flag.StringVar(&amp;serverType, "type", serverType, "Specify the server type (http or grpc)")
        flag.StringVar(&amp;repoPath, "chdir", repoPath, "Repository path where feature store yaml file is stored")

        flag.StringVar(&amp;host, "host", host, "Specify a host for the server")
        flag.IntVar(&amp;port, "port", port, "Specify a port for the server")
        flag.Parse()

        repoConfig, err := registry.NewRepoConfigFromFile(repoPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal().Stack().Err(err).Msg("Failed to convert to RepoConfig")
        }</span>

        <span class="cov0" title="0">fs, err := feast.NewFeatureStore(repoConfig, nil)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal().Stack().Err(err).Msg("Failed to create NewFeatureStore")
        }</span>

        <span class="cov0" title="0">loggingOptions, err := repoConfig.GetLoggingOptions()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal().Stack().Err(err).Msg("Failed to get LoggingOptions")
        }</span>

        // TODO: writeLoggedFeaturesCallback is defaulted to nil. write_logged_features functionality needs to be
        // implemented in Golang specific to OfflineStoreSink. Python Feature Server doesn't support this.
        <span class="cov0" title="0">if serverType == "http" </span><span class="cov0" title="0">{
                err = server.StartHttpServer(fs, host, port, nil, loggingOptions)
        }</span> else<span class="cov0" title="0"> if serverType == "grpc" </span><span class="cov0" title="0">{
                err = server.StartGrpcServer(fs, host, port, nil, loggingOptions)
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("Unknown server type. Please specify 'http' or 'grpc'.")
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Fatal().Stack().Err(err).Msg("Failed to start server")
        }</span>

}

func constructLoggingService(fs *feast.FeatureStore, writeLoggedFeaturesCallback logging.OfflineStoreWriteCallback, loggingOpts *logging.LoggingOptions) (*logging.LoggingService, error) <span class="cov8" title="1">{
        var loggingService *logging.LoggingService = nil
        if writeLoggedFeaturesCallback != nil </span><span class="cov0" title="0">{
                sink, err := logging.NewOfflineStoreSink(writeLoggedFeaturesCallback)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">loggingService, err = logging.NewLoggingService(fs, sink, logging.LoggingOptions{
                        ChannelCapacity: loggingOpts.ChannelCapacity,
                        EmitTimeout:     loggingOpts.EmitTimeout,
                        WriteInterval:   loggingOpts.WriteInterval,
                        FlushInterval:   loggingOpts.FlushInterval,
                })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">return loggingService, nil</span>
}

// StartGprcServerWithLogging starts gRPC server with enabled feature logging
func StartGrpcServer(fs *feast.FeatureStore, host string, port int, writeLoggedFeaturesCallback logging.OfflineStoreWriteCallback, loggingOpts *logging.LoggingOptions) error <span class="cov0" title="0">{
        if strings.ToLower(os.Getenv("ENABLE_DATADOG_TRACING")) == "true" </span><span class="cov0" title="0">{
                tracer.Start(tracer.WithRuntimeMetrics())
                defer tracer.Stop()
        }</span>
        <span class="cov0" title="0">loggingService, err := constructLoggingService(fs, writeLoggedFeaturesCallback, loggingOpts)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">ser := server.NewGrpcServingServiceServer(fs, loggingService)
        log.Info().Msgf("Starting a gRPC server on host %s port %d", host, port)
        lis, err := net.Listen("tcp", fmt.Sprintf("%s:%d", host, port))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">grpcServer := grpc.NewServer(grpc.UnaryInterceptor(grpctrace.UnaryServerInterceptor()))
        serving.RegisterServingServiceServer(grpcServer, ser)
        healthService := health.NewServer()
        grpc_health_v1.RegisterHealthServer(grpcServer, healthService)

        stop := make(chan os.Signal, 1)
        signal.Notify(stop, syscall.SIGINT, syscall.SIGTERM)

        go func() </span><span class="cov0" title="0">{
                // As soon as these signals are received from OS, try to gracefully stop the gRPC server
                &lt;-stop
                log.Info().Msg("Stopping the gRPC server...")
                grpcServer.GracefulStop()
                if loggingService != nil </span><span class="cov0" title="0">{
                        loggingService.Stop()
                }</span>
                <span class="cov0" title="0">log.Info().Msg("gRPC server terminated")</span>
        }()

        <span class="cov0" title="0">return grpcServer.Serve(lis)</span>
}

// StartHttpServerWithLogging starts HTTP server with enabled feature logging
// Go does not allow direct assignment to package-level functions as a way to
// mock them for tests
func StartHttpServer(fs *feast.FeatureStore, host string, port int, writeLoggedFeaturesCallback logging.OfflineStoreWriteCallback, loggingOpts *logging.LoggingOptions) error <span class="cov0" title="0">{
        loggingService, err := constructLoggingService(fs, writeLoggedFeaturesCallback, loggingOpts)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">ser := server.NewHttpServer(fs, loggingService)
        log.Info().Msgf("Starting a HTTP server on host %s, port %d", host, port)

        stop := make(chan os.Signal, 1)
        signal.Notify(stop, syscall.SIGINT, syscall.SIGTERM)

        go func() </span><span class="cov0" title="0">{
                // As soon as these signals are received from OS, try to gracefully stop the gRPC server
                &lt;-stop
                log.Info().Msg("Stopping the HTTP server...")
                err := ser.Stop()
                if err != nil </span><span class="cov0" title="0">{
                        log.Error().Err(err).Msg("Error when stopping the HTTP server")
                }</span>
                <span class="cov0" title="0">if loggingService != nil </span><span class="cov0" title="0">{
                        loggingService.Stop()
                }</span>
                <span class="cov0" title="0">log.Info().Msg("HTTP server terminated")</span>
        }()

        <span class="cov0" title="0">return ser.Serve(host, port)</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package types

import (
        "fmt"

        "github.com/apache/arrow/go/v8/arrow"
        "github.com/apache/arrow/go/v8/arrow/array"
        "github.com/apache/arrow/go/v8/arrow/memory"

        "github.com/feast-dev/feast/go/protos/feast/types"
)

func ProtoTypeToArrowType(sample *types.Value) (arrow.DataType, error) <span class="cov8" title="1">{
        if sample.Val == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">switch sample.Val.(type) </span>{
        case *types.Value_BytesVal:<span class="cov8" title="1">
                return arrow.BinaryTypes.Binary, nil</span>
        case *types.Value_StringVal:<span class="cov8" title="1">
                return arrow.BinaryTypes.String, nil</span>
        case *types.Value_Int32Val:<span class="cov8" title="1">
                return arrow.PrimitiveTypes.Int32, nil</span>
        case *types.Value_Int64Val:<span class="cov8" title="1">
                return arrow.PrimitiveTypes.Int64, nil</span>
        case *types.Value_FloatVal:<span class="cov8" title="1">
                return arrow.PrimitiveTypes.Float32, nil</span>
        case *types.Value_DoubleVal:<span class="cov8" title="1">
                return arrow.PrimitiveTypes.Float64, nil</span>
        case *types.Value_BoolVal:<span class="cov8" title="1">
                return arrow.FixedWidthTypes.Boolean, nil</span>
        case *types.Value_BoolListVal:<span class="cov8" title="1">
                return arrow.ListOf(arrow.FixedWidthTypes.Boolean), nil</span>
        case *types.Value_StringListVal:<span class="cov8" title="1">
                return arrow.ListOf(arrow.BinaryTypes.String), nil</span>
        case *types.Value_BytesListVal:<span class="cov8" title="1">
                return arrow.ListOf(arrow.BinaryTypes.Binary), nil</span>
        case *types.Value_Int32ListVal:<span class="cov8" title="1">
                return arrow.ListOf(arrow.PrimitiveTypes.Int32), nil</span>
        case *types.Value_Int64ListVal:<span class="cov8" title="1">
                return arrow.ListOf(arrow.PrimitiveTypes.Int64), nil</span>
        case *types.Value_FloatListVal:<span class="cov8" title="1">
                return arrow.ListOf(arrow.PrimitiveTypes.Float32), nil</span>
        case *types.Value_DoubleListVal:<span class="cov8" title="1">
                return arrow.ListOf(arrow.PrimitiveTypes.Float64), nil</span>
        case *types.Value_UnixTimestampVal:<span class="cov8" title="1">
                return arrow.FixedWidthTypes.Timestamp_s, nil</span>
        case *types.Value_UnixTimestampListVal:<span class="cov8" title="1">
                return arrow.ListOf(arrow.FixedWidthTypes.Timestamp_s), nil</span>
        default:<span class="cov0" title="0">
                return nil,
                        fmt.Errorf("unsupported proto type in proto to arrow conversion: %s", sample.Val)</span>
        }
}

func ValueTypeEnumToArrowType(t types.ValueType_Enum) (arrow.DataType, error) <span class="cov0" title="0">{
        switch t </span>{
        case types.ValueType_BYTES:<span class="cov0" title="0">
                return arrow.BinaryTypes.Binary, nil</span>
        case types.ValueType_STRING:<span class="cov0" title="0">
                return arrow.BinaryTypes.String, nil</span>
        case types.ValueType_INT32:<span class="cov0" title="0">
                return arrow.PrimitiveTypes.Int32, nil</span>
        case types.ValueType_INT64:<span class="cov0" title="0">
                return arrow.PrimitiveTypes.Int64, nil</span>
        case types.ValueType_FLOAT:<span class="cov0" title="0">
                return arrow.PrimitiveTypes.Float32, nil</span>
        case types.ValueType_DOUBLE:<span class="cov0" title="0">
                return arrow.PrimitiveTypes.Float64, nil</span>
        case types.ValueType_BOOL:<span class="cov0" title="0">
                return arrow.FixedWidthTypes.Boolean, nil</span>
        case types.ValueType_BOOL_LIST:<span class="cov0" title="0">
                return arrow.ListOf(arrow.FixedWidthTypes.Boolean), nil</span>
        case types.ValueType_STRING_LIST:<span class="cov0" title="0">
                return arrow.ListOf(arrow.BinaryTypes.String), nil</span>
        case types.ValueType_BYTES_LIST:<span class="cov0" title="0">
                return arrow.ListOf(arrow.BinaryTypes.Binary), nil</span>
        case types.ValueType_INT32_LIST:<span class="cov0" title="0">
                return arrow.ListOf(arrow.PrimitiveTypes.Int32), nil</span>
        case types.ValueType_INT64_LIST:<span class="cov0" title="0">
                return arrow.ListOf(arrow.PrimitiveTypes.Int64), nil</span>
        case types.ValueType_FLOAT_LIST:<span class="cov0" title="0">
                return arrow.ListOf(arrow.PrimitiveTypes.Float32), nil</span>
        case types.ValueType_DOUBLE_LIST:<span class="cov0" title="0">
                return arrow.ListOf(arrow.PrimitiveTypes.Float64), nil</span>
        case types.ValueType_UNIX_TIMESTAMP:<span class="cov0" title="0">
                return arrow.FixedWidthTypes.Timestamp_s, nil</span>
        case types.ValueType_UNIX_TIMESTAMP_LIST:<span class="cov0" title="0">
                return arrow.ListOf(arrow.FixedWidthTypes.Timestamp_s), nil</span>
        default:<span class="cov0" title="0">
                return nil,
                        fmt.Errorf("unsupported value type enum in enum to arrow type conversion: %s", t)</span>
        }
}

func CopyProtoValuesToArrowArray(builder array.Builder, values []*types.Value) error <span class="cov8" title="1">{
        for _, value := range values </span><span class="cov8" title="1">{
                if value == nil || value.Val == nil </span><span class="cov8" title="1">{
                        builder.AppendNull()
                        continue</span>
                }

                <span class="cov8" title="1">switch fieldBuilder := builder.(type) </span>{

                case *array.BooleanBuilder:<span class="cov8" title="1">
                        fieldBuilder.Append(value.GetBoolVal())</span>
                case *array.BinaryBuilder:<span class="cov8" title="1">
                        fieldBuilder.Append(value.GetBytesVal())</span>
                case *array.StringBuilder:<span class="cov8" title="1">
                        fieldBuilder.Append(value.GetStringVal())</span>
                case *array.Int32Builder:<span class="cov8" title="1">
                        fieldBuilder.Append(value.GetInt32Val())</span>
                case *array.Int64Builder:<span class="cov8" title="1">
                        fieldBuilder.Append(value.GetInt64Val())</span>
                case *array.Float32Builder:<span class="cov8" title="1">
                        fieldBuilder.Append(value.GetFloatVal())</span>
                case *array.Float64Builder:<span class="cov8" title="1">
                        fieldBuilder.Append(value.GetDoubleVal())</span>
                case *array.TimestampBuilder:<span class="cov8" title="1">
                        fieldBuilder.Append(arrow.Timestamp(value.GetUnixTimestampVal()))</span>
                case *array.ListBuilder:<span class="cov8" title="1">
                        fieldBuilder.Append(true)

                        switch valueBuilder := fieldBuilder.ValueBuilder().(type) </span>{

                        case *array.BooleanBuilder:<span class="cov8" title="1">
                                for _, v := range value.GetBoolListVal().GetVal() </span><span class="cov8" title="1">{
                                        valueBuilder.Append(v)
                                }</span>
                        case *array.BinaryBuilder:<span class="cov8" title="1">
                                for _, v := range value.GetBytesListVal().GetVal() </span><span class="cov8" title="1">{
                                        valueBuilder.Append(v)
                                }</span>
                        case *array.StringBuilder:<span class="cov8" title="1">
                                for _, v := range value.GetStringListVal().GetVal() </span><span class="cov8" title="1">{
                                        valueBuilder.Append(v)
                                }</span>
                        case *array.Int32Builder:<span class="cov8" title="1">
                                for _, v := range value.GetInt32ListVal().GetVal() </span><span class="cov8" title="1">{
                                        valueBuilder.Append(v)
                                }</span>
                        case *array.Int64Builder:<span class="cov8" title="1">
                                for _, v := range value.GetInt64ListVal().GetVal() </span><span class="cov8" title="1">{
                                        valueBuilder.Append(v)
                                }</span>
                        case *array.Float32Builder:<span class="cov8" title="1">
                                for _, v := range value.GetFloatListVal().GetVal() </span><span class="cov8" title="1">{
                                        valueBuilder.Append(v)
                                }</span>
                        case *array.Float64Builder:<span class="cov8" title="1">
                                for _, v := range value.GetDoubleListVal().GetVal() </span><span class="cov8" title="1">{
                                        valueBuilder.Append(v)
                                }</span>
                        case *array.TimestampBuilder:<span class="cov8" title="1">
                                for _, v := range value.GetUnixTimestampListVal().GetVal() </span><span class="cov8" title="1">{
                                        valueBuilder.Append(arrow.Timestamp(v))
                                }</span>
                        }
                default:<span class="cov0" title="0">
                        return fmt.Errorf("unsupported array builder: %s", builder)</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func ArrowValuesToProtoValues(arr arrow.Array) ([]*types.Value, error) <span class="cov8" title="1">{
        values := make([]*types.Value, 0)

        if listArr, ok := arr.(*array.List); ok </span><span class="cov8" title="1">{
                listValues := listArr.ListValues()
                offsets := listArr.Offsets()[1:]
                pos := 0
                for idx := 0; idx &lt; listArr.Len(); idx++ </span><span class="cov8" title="1">{
                        switch listValues.DataType() </span>{
                        case arrow.PrimitiveTypes.Int32:<span class="cov8" title="1">
                                vals := make([]int32, int(offsets[idx])-pos)
                                for j := pos; j &lt; int(offsets[idx]); j++ </span><span class="cov8" title="1">{
                                        vals[j-pos] = listValues.(*array.Int32).Value(j)
                                }</span>
                                <span class="cov8" title="1">values = append(values,
                                        &amp;types.Value{Val: &amp;types.Value_Int32ListVal{Int32ListVal: &amp;types.Int32List{Val: vals}}})</span>
                        case arrow.PrimitiveTypes.Int64:<span class="cov8" title="1">
                                vals := make([]int64, int(offsets[idx])-pos)
                                for j := pos; j &lt; int(offsets[idx]); j++ </span><span class="cov8" title="1">{
                                        vals[j-pos] = listValues.(*array.Int64).Value(j)
                                }</span>
                                <span class="cov8" title="1">values = append(values,
                                        &amp;types.Value{Val: &amp;types.Value_Int64ListVal{Int64ListVal: &amp;types.Int64List{Val: vals}}})</span>
                        case arrow.PrimitiveTypes.Float32:<span class="cov8" title="1">
                                vals := make([]float32, int(offsets[idx])-pos)
                                for j := pos; j &lt; int(offsets[idx]); j++ </span><span class="cov8" title="1">{
                                        vals[j-pos] = listValues.(*array.Float32).Value(j)
                                }</span>
                                <span class="cov8" title="1">values = append(values,
                                        &amp;types.Value{Val: &amp;types.Value_FloatListVal{FloatListVal: &amp;types.FloatList{Val: vals}}})</span>
                        case arrow.PrimitiveTypes.Float64:<span class="cov8" title="1">
                                vals := make([]float64, int(offsets[idx])-pos)
                                for j := pos; j &lt; int(offsets[idx]); j++ </span><span class="cov8" title="1">{
                                        vals[j-pos] = listValues.(*array.Float64).Value(j)
                                }</span>
                                <span class="cov8" title="1">values = append(values,
                                        &amp;types.Value{Val: &amp;types.Value_DoubleListVal{DoubleListVal: &amp;types.DoubleList{Val: vals}}})</span>
                        case arrow.BinaryTypes.Binary:<span class="cov8" title="1">
                                vals := make([][]byte, int(offsets[idx])-pos)
                                for j := pos; j &lt; int(offsets[idx]); j++ </span><span class="cov8" title="1">{
                                        vals[j-pos] = listValues.(*array.Binary).Value(j)
                                }</span>
                                <span class="cov8" title="1">values = append(values,
                                        &amp;types.Value{Val: &amp;types.Value_BytesListVal{BytesListVal: &amp;types.BytesList{Val: vals}}})</span>
                        case arrow.BinaryTypes.String:<span class="cov8" title="1">
                                vals := make([]string, int(offsets[idx])-pos)
                                for j := pos; j &lt; int(offsets[idx]); j++ </span><span class="cov8" title="1">{
                                        vals[j-pos] = listValues.(*array.String).Value(j)
                                }</span>
                                <span class="cov8" title="1">values = append(values,
                                        &amp;types.Value{Val: &amp;types.Value_StringListVal{StringListVal: &amp;types.StringList{Val: vals}}})</span>
                        case arrow.FixedWidthTypes.Boolean:<span class="cov8" title="1">
                                vals := make([]bool, int(offsets[idx])-pos)
                                for j := pos; j &lt; int(offsets[idx]); j++ </span><span class="cov8" title="1">{
                                        vals[j-pos] = listValues.(*array.Boolean).Value(j)
                                }</span>
                                <span class="cov8" title="1">values = append(values,
                                        &amp;types.Value{Val: &amp;types.Value_BoolListVal{BoolListVal: &amp;types.BoolList{Val: vals}}})</span>
                        case arrow.FixedWidthTypes.Timestamp_s:<span class="cov8" title="1">
                                vals := make([]int64, int(offsets[idx])-pos)
                                for j := pos; j &lt; int(offsets[idx]); j++ </span><span class="cov8" title="1">{
                                        vals[j-pos] = int64(listValues.(*array.Timestamp).Value(j))
                                }</span>

                                <span class="cov8" title="1">values = append(values,
                                        &amp;types.Value{Val: &amp;types.Value_UnixTimestampListVal{
                                                UnixTimestampListVal: &amp;types.Int64List{Val: vals}}})</span>

                        }

                        // set the end of current element as start of the next
                        <span class="cov8" title="1">pos = int(offsets[idx])</span>
                }

                <span class="cov8" title="1">return values, nil</span>
        }

        <span class="cov8" title="1">switch arr.DataType() </span>{
        case arrow.PrimitiveTypes.Int32:<span class="cov8" title="1">
                for idx := 0; idx &lt; arr.Len(); idx++ </span><span class="cov8" title="1">{
                        if arr.IsNull(idx) </span><span class="cov8" title="1">{
                                values = append(values, &amp;types.Value{})
                        }</span> else<span class="cov8" title="1"> {
                                values = append(values, &amp;types.Value{Val: &amp;types.Value_Int32Val{Int32Val: arr.(*array.Int32).Value(idx)}})
                        }</span>
                }
        case arrow.PrimitiveTypes.Int64:<span class="cov8" title="1">
                for idx := 0; idx &lt; arr.Len(); idx++ </span><span class="cov8" title="1">{
                        if arr.IsNull(idx) </span><span class="cov8" title="1">{
                                values = append(values, &amp;types.Value{})
                        }</span> else<span class="cov8" title="1"> {
                                values = append(values, &amp;types.Value{Val: &amp;types.Value_Int64Val{Int64Val: arr.(*array.Int64).Value(idx)}})
                        }</span>
                }
        case arrow.PrimitiveTypes.Float32:<span class="cov8" title="1">
                for idx := 0; idx &lt; arr.Len(); idx++ </span><span class="cov8" title="1">{
                        if arr.IsNull(idx) </span><span class="cov8" title="1">{
                                values = append(values, &amp;types.Value{})
                        }</span> else<span class="cov8" title="1"> {
                                values = append(values, &amp;types.Value{Val: &amp;types.Value_FloatVal{FloatVal: arr.(*array.Float32).Value(idx)}})
                        }</span>
                }
        case arrow.PrimitiveTypes.Float64:<span class="cov8" title="1">
                for idx := 0; idx &lt; arr.Len(); idx++ </span><span class="cov8" title="1">{
                        if arr.IsNull(idx) </span><span class="cov8" title="1">{
                                values = append(values, &amp;types.Value{})
                        }</span> else<span class="cov8" title="1"> {
                                values = append(values, &amp;types.Value{Val: &amp;types.Value_DoubleVal{DoubleVal: arr.(*array.Float64).Value(idx)}})
                        }</span>
                }
        case arrow.FixedWidthTypes.Boolean:<span class="cov8" title="1">
                for idx := 0; idx &lt; arr.Len(); idx++ </span><span class="cov8" title="1">{
                        if arr.IsNull(idx) </span><span class="cov8" title="1">{
                                values = append(values, &amp;types.Value{})
                        }</span> else<span class="cov8" title="1"> {
                                values = append(values, &amp;types.Value{Val: &amp;types.Value_BoolVal{BoolVal: arr.(*array.Boolean).Value(idx)}})
                        }</span>
                }
        case arrow.BinaryTypes.Binary:<span class="cov8" title="1">
                for idx := 0; idx &lt; arr.Len(); idx++ </span><span class="cov8" title="1">{
                        if arr.IsNull(idx) </span><span class="cov8" title="1">{
                                values = append(values, &amp;types.Value{})
                        }</span> else<span class="cov8" title="1"> {
                                values = append(values, &amp;types.Value{Val: &amp;types.Value_BytesVal{BytesVal: arr.(*array.Binary).Value(idx)}})
                        }</span>
                }
        case arrow.BinaryTypes.String:<span class="cov8" title="1">
                for idx := 0; idx &lt; arr.Len(); idx++ </span><span class="cov8" title="1">{
                        if arr.IsNull(idx) </span><span class="cov8" title="1">{
                                values = append(values, &amp;types.Value{})
                        }</span> else<span class="cov8" title="1"> {
                                values = append(values, &amp;types.Value{Val: &amp;types.Value_StringVal{StringVal: arr.(*array.String).Value(idx)}})
                        }</span>
                }
        case arrow.FixedWidthTypes.Timestamp_s:<span class="cov8" title="1">
                for idx := 0; idx &lt; arr.Len(); idx++ </span><span class="cov8" title="1">{
                        if arr.IsNull(idx) </span><span class="cov8" title="1">{
                                values = append(values, &amp;types.Value{})
                        }</span> else<span class="cov8" title="1"> {
                                values = append(values, &amp;types.Value{Val: &amp;types.Value_UnixTimestampVal{UnixTimestampVal: int64(arr.(*array.Timestamp).Value(idx))}})
                        }</span>
                }
        case arrow.Null:<span class="cov8" title="1">
                for idx := 0; idx &lt; arr.Len(); idx++ </span><span class="cov8" title="1">{
                        values = append(values, &amp;types.Value{})
                }</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported arrow to proto conversion for type %s", arr.DataType())</span>
        }

        <span class="cov8" title="1">return values, nil</span>
}

func ProtoValuesToArrowArray(protoValues []*types.Value, arrowAllocator memory.Allocator, numRows int) (arrow.Array, error) <span class="cov8" title="1">{
        var fieldType arrow.DataType
        var err error

        for _, val := range protoValues </span><span class="cov8" title="1">{
                if val != nil </span><span class="cov8" title="1">{
                        fieldType, err = ProtoTypeToArrowType(val)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">if fieldType != nil </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">if fieldType != nil </span><span class="cov8" title="1">{
                builder := array.NewBuilder(arrowAllocator, fieldType)
                err = CopyProtoValuesToArrowArray(builder, protoValues)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">return builder.NewArray(), nil</span>
        } else<span class="cov8" title="1"> {
                return array.NewNull(numRows), nil
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
